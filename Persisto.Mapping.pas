unit Persisto.Mapping;

interface

uses System.Rtti, System.TypInfo, System.SysUtils{$IFDEF PAS2JS}, JS, Web{$ENDIF};

type
  TAutoGeneratedType = (agtNotDefined, agtCurrentDate, agtCurrentTime, agtCurrentDateTime, agtNewUniqueIdentifier, agtNewGuid, agtSequence, agtFixedValue);
  TDatabaseSpecialType = (stNotDefined, stDate, stDateTime, stTime, stText, stUniqueIdentifier, stBoolean);
  TNullEnumerator = (NULL);

  TCustomNameAttribute = class(TCustomAttribute)
  private
    FName: String;
  public
    constructor Create(const Name: String);

    property Name: String read FName;
  end;

  EntityAttribute = class(TCustomAttribute);
  FieldNameAttribute = class(TCustomNameAttribute);
  ForeignKeyNameAttribute = class(TCustomNameAttribute);
  ManyValueAssociationLinkNameAttribute = class(TCustomNameAttribute);
  PrimaryKeyAttribute = class(TCustomNameAttribute);
  SingleTableInheritanceAttribute = class(TCustomAttribute);
  TableNameAttribute = class(TCustomNameAttribute);

  IndexAttribute = class(TCustomNameAttribute)
  private
    FFields: String;
  public
    constructor Create(const Name, Fields: String);

    property Fields: String read FFields;
  end;

  UniqueKeyAttribute = class(IndexAttribute);

  FieldInfoAttribute = class(TCustomAttribute)
  private
    FPrecision: Word;
    FScale: Word;
    FSize: Word;
    FSpecialType: TDatabaseSpecialType;

    constructor Create(const SpecialType: TDatabaseSpecialType; const Size, Scale: Word); overload;
  public
    constructor Create(const Precision, Scale: Word); overload;
    constructor Create(const Size: Word); overload;
    constructor Create(const SpecialType: TDatabaseSpecialType); overload;

    property Precision: Word read FPrecision;
    property Scale: Word read FScale;
    property Size: Word read FSize;
    property SpecialType: TDatabaseSpecialType read FSpecialType;
  end;

  UniqueIdentifierAttribute = class(FieldInfoAttribute)
  public
    constructor Create;
  end;

  TextAttribute = class(FieldInfoAttribute)
  public
    constructor Create;
  end;

  SizeAttribute = class(FieldInfoAttribute)
  public
    constructor Create(const Size: Word);
  end;

  PrecisionAttribute = class(FieldInfoAttribute)
  public
    constructor Create(const Precision, Scale: Word);
  end;

  RequiredAttribute = class(TCustomAttribute)
  end;

  TAutoGeneratedAttribute = class(TCustomAttribute)
  private
    FType: TAutoGeneratedType;

    constructor Create(const &Type: TAutoGeneratedType);
  public
    property &Type: TAutoGeneratedType read FType write FType;
  end;

  CurrentDateAttribute = class(TAutoGeneratedAttribute)
  public
    constructor Create;
  end;

  CurrentTimeAttribute = class(TAutoGeneratedAttribute)
  public
    constructor Create;
  end;

  CurrentDateTimeAttribute = class(TAutoGeneratedAttribute)
  public
    constructor Create;
  end;

  FixedValueAttribute = class(TAutoGeneratedAttribute)
  private
    FValue: String;
  public
    constructor Create(const Value: String);

    property Value: String read FValue write FValue;
  end;

  NewUniqueIdentifierAttribute = class(TAutoGeneratedAttribute)
  public
    constructor Create;
  end;

  NewGuidAttribute = class(TAutoGeneratedAttribute)
  public
    constructor Create;
  end;

  SequenceAttribute = class(TAutoGeneratedAttribute)
  private
    FName: String;
  public
    constructor Create(const Name: String);

    property Name: String read FName write FName;
  end;

  ILazyLoader = {$IFDEF DCC}interface{$ELSE}class
  public
{$ENDIF}
    function GetKey: TValue;{$IFDEF PAS2JS} virtual; abstract;{$ENDIF}
    function LoadValue: TValue;{$IFDEF PAS2JS} virtual; abstract;{$ENDIF}
{$IFDEF PAS2JS}
    function LoadValueAsync: TValue; virtual; abstract; async;
{$ENDIF}
  end;

  Lazy<T> = record
  private
    FLoaded: Boolean;
    FLoader: ILazyLoader;
    FValue: TValue;

    function NeedLoadValue: Boolean;

    procedure SetTValue(const Value: TValue);
  public
    function GetHasValue: Boolean;
    function GetValue: T;
{$IFDEF PAS2JS}
    function GetValueAsync: T; async;
{$ENDIF}

    procedure SetValue(const Value: T);

{$IFDEF DCC}
    class operator Implicit(const Value: Lazy<T>): T;
    class operator Implicit(const Value: T): Lazy<T>;
{$ENDIF}

    property HasValue: Boolean read GetHasValue;
    property Loaded: Boolean read FLoaded;
    property Value: T read GetValue write SetValue;
  end;

  ILazyManipulator = interface
    function GetHasValue: Boolean;
    function GetKey: TValue;
    function GetLoaded: Boolean;
    function GetLoader: ILazyLoader;
    function GetRttiType: TRttiType;
    function GetValue: TValue;

    procedure SetLoaded(const Value: Boolean);
    procedure SetLoader(const Value: ILazyLoader);
    procedure SetValue(const Value: TValue);

    property HasValue: Boolean read GetHasValue;
    property Key: TValue read GetKey;
    property Loaded: Boolean read GetLoaded write SetLoaded;
    property Loader: ILazyLoader read GetLoader write SetLoader;
    property RttiType: TRttiType read GetRttiType;
    property Value: TValue read GetValue write SetValue;
  end;

  TLazyManipulator = class(TInterfacedObject, ILazyManipulator)
  private
    FLazyInstance: Pointer;
    FLazyType: TRttiType;

    function GetHasValue: Boolean;
    function GetKey: TValue;
    function GetLazyLoadedField: TRttiField;
    function GetLazyLoaderField: TRttiField;
    function GetLazyValueField: TRttiField;
    function GetLoaded: Boolean;
    function GetLoader: ILazyLoader;
    function GetRttiType: TRttiType;
    function GetValue: TValue;

    procedure SetLoaded(const Value: Boolean);
    procedure SetLoader(const Value: ILazyLoader);
    procedure SetValue(const Value: TValue);

    property LazyLoadedField: TRttiField read GetLazyLoadedField;
    property LazyLoaderField: TRttiField read GetLazyLoaderField;
    property LazyValueField: TRttiField read GetLazyValueField;
  public
    constructor Create(const LazyInstance: Pointer; const LazyType: TRttiType);

    class function GetManipulator(const ObjectInstance: TObject; const LazyProperty: TRttiProperty): ILazyManipulator; overload;
    class function GetManipulator(const LazyInstance: Pointer; const LazyType: TRttiType): ILazyManipulator; overload;
    class function GetManipulator<T>(const LazyInstance: T): ILazyManipulator; overload;
    class function GetLazyLoadingType(const LazyProperty: TRttiProperty): TRttiType; overload;
    class function GetLazyLoadingType(const LazyType: TRttiType): TRttiType; overload;
    class function IsLazyLoading(const LazyProperty: TRttiProperty): Boolean; overload;
    class function IsLazyLoading(const LazyType: TRttiType): Boolean; overload;
  end;

  Nullable<T> = record
  private
    FLoaded: Boolean;
    FValue: TValue;
  public
    function GetValue: T;
    function IsNull: Boolean;

    procedure Clear;
    procedure SetValue(const Value: T);

{$IFDEF DCC}
    class operator Implicit(const Value: Nullable<T>): T; overload;
    class operator Implicit(const Value: T): Nullable<T>; overload;
    class operator Implicit(const Value: TNullEnumerator): Nullable<T>; overload;
{$ENDIF}

    property Value: T read GetValue write SetValue;
  end;

  INullableManipulator = interface
    ['{495AE37A-7DDE-467B-8453-EB234DEB7D10}']
    function GetRttiType: TRttiType;
    function GetValue: TValue;
    function IsNull: Boolean;

    procedure SetValue(const Value: TValue);

    property RttiType: TRttiType read GetRttiType;
    property Value: TValue read GetValue write SetValue;
  end;

  TNullableManipulator = class(TInterfacedObject, INullableManipulator)
  private
    FNullableInstance: TValue;
    FNullableType: TRttiType;

    function GetRttiType: TRttiType;
    function GetValue: TValue;
    function IsNull: Boolean;

    procedure SetValue(const Value: TValue);
  public
    constructor Create(const NullableInstance: Pointer; const NullableType: TRttiType);

    class function GetManipulator(const ObjectInstance: TObject; const NullableProperty: TRttiProperty): INullableManipulator; overload;
    class function GetManipulator(const Instance: Pointer; const NullableType: TRttiType): INullableManipulator; overload;
    class function GetNullableType(const NullableProperty: TRttiProperty): TRttiType; overload;
    class function GetNullableType(const NullableType: TRttiType): TRttiType; overload;
    class function IsNullable(const NullableProperty: TRttiProperty): Boolean; overload;
    class function IsNullable(const NullableType: TRttiType): Boolean; overload;
  end;

  TRttiTypeHelper = class helper for TRttiObject
  public
    function AsArray: TRttiDynamicArrayType;
    function IsArray: Boolean;
  end;

  TRttiPropertyHelper = class helper for TRttiInstanceProperty
  public
    function GetRawValue(Instance: Pointer): Pointer;
  end;

  TValueHelper = record helper for TValue
  private
    class var GFFormatSettings: TFormatSettings;

    function GetArrayElementInternal(Index: Integer): TValue; inline;
    function GetArrayLengthInternal: Integer; inline;

    procedure SetArrayElementInternal(Index: Integer; const Value: TValue); inline;
    procedure SetArrayLengthInternal(const Size: Integer); inline;
  public
    function GetAsString: String;

    property ArrayElement[Index: Integer]: TValue read GetArrayElementInternal write SetArrayElementInternal;
    property ArrayLength: Integer read GetArrayLengthInternal write SetArrayLengthInternal;

    class property FormatSettings: TFormatSettings read GFFormatSettings;
  end;

function GetRttiType(const AClass: TClass): TRttiType; overload;
function GetRttiType(const TypeInfo: PTypeInfo): TRttiType; overload;

implementation

uses {$IFDEF PAS2JS}RTLConsts, JS{$ELSE}System.Variants, System.SysConst{$ENDIF};

const
  LAZY_NAME = 'Lazy<';
  NULLABLE_TYPE_NAME = 'Nullable<';

function GetRttiType(const AClass: TClass): TRttiType;
begin
  Result := GetRttiType(AClass.ClassInfo);
end;

function GetRttiType(const TypeInfo: PTypeInfo): TRttiType;
var
  Context: TRttiContext;

begin
  Context := TRttiContext.Create;

  Result := Context.GetType(TypeInfo);

  Context.Free;
end;

{ Lazy<T> }

function Lazy<T>.GetHasValue: Boolean;
begin
  Result := not FValue.IsEmpty or Assigned(FLoader);
end;

function Lazy<T>.GetValue: T;
begin
  if NeedLoadValue then
    SetTValue(FLoader.LoadValue);

  Result := FValue.AsType<T>;
end;

{$IFDEF PAS2JS}
function Lazy<T>.GetValueAsync: T;
begin
  if NeedLoadValue then
    SetTValue(await(FLoader.LoadValueAsync));

  Result := FValue.AsType<T>;
end;
{$ENDIF}

{$IFDEF DCC}
class operator Lazy<T>.Implicit(const Value: T): Lazy<T>;
begin
  Result.Value := Value;
end;

class operator Lazy<T>.Implicit(const Value: Lazy<T>): T;
begin
  Result := Value.Value;
end;
{$ENDIF}

function Lazy<T>.NeedLoadValue: Boolean;
begin
  Result := not FLoaded and Assigned(FLoader);

  if not FLoaded and not Assigned(FLoader) then
    SetTValue(TValue.Empty);
end;

procedure Lazy<T>.SetTValue(const Value: TValue);
begin
  FLoaded := True;
  FLoader := nil;
  FValue := Value;
end;

procedure Lazy<T>.SetValue(const Value: T);
begin
  SetTValue(TValue.From<T>(Value));
end;

{ TCustomNameAttribute }

constructor TCustomNameAttribute.Create(const Name: String);
begin
  inherited Create;

  FName := Name;
end;

{ IndexAttribute }

constructor IndexAttribute.Create(const Name, Fields: String);
begin
  inherited Create(Name);

  FFields := Fields;
end;

{ FieldInfoAttribute }

constructor FieldInfoAttribute.Create(const Precision, Scale: Word);
begin
  Create(stNotDefined, Precision, Scale);
end;

constructor FieldInfoAttribute.Create(const Size: Word);
begin
  Create(stNotDefined, Size, 0);
end;

constructor FieldInfoAttribute.Create(const SpecialType: TDatabaseSpecialType);
begin
  Create(SpecialType, 0, 0);
end;

constructor FieldInfoAttribute.Create(const SpecialType: TDatabaseSpecialType; const Size, Scale: Word);
begin
  inherited Create;

  FScale := Scale;
  FSize := Size;
  FSpecialType := SpecialType;
end;

{ UniqueIdentifierAttribute }

constructor UniqueIdentifierAttribute.Create;
begin
  inherited Create(stUniqueIdentifier, 0, 0);
end;

{ SizeAttribute }

constructor SizeAttribute.Create(const Size: Word);
begin
  inherited Create(Size);
end;

{ PrecisionAttribute }

constructor PrecisionAttribute.Create(const Precision, Scale: Word);
begin
  inherited Create(Precision, Scale);
end;

{ TextAttribute }

constructor TextAttribute.Create;
begin
  inherited Create(stText, 0, 0);
end;

{ TAutoGeneratedAttribute }

constructor TAutoGeneratedAttribute.Create(const &Type: TAutoGeneratedType);
begin
  inherited Create;

  FType := &Type;
end;

{ CurrentDateAttribute }

constructor CurrentDateAttribute.Create;
begin
  inherited Create(agtCurrentDate);
end;

{ CurrentTimeAttribute }

constructor CurrentTimeAttribute.Create;
begin
  inherited Create(agtCurrentTime);
end;

{ CurrentDateTimeAttribute }

constructor CurrentDateTimeAttribute.Create;
begin
  inherited Create(agtCurrentDateTime);
end;

{ NewUniqueIdentifierAttribute }

constructor NewUniqueIdentifierAttribute.Create;
begin
  inherited Create(agtNewUniqueIdentifier);
end;

{ NewGuidAttribute }

constructor NewGuidAttribute.Create;
begin
  inherited Create(agtNewGuid);
end;

{ SequenceAttribute }

constructor SequenceAttribute.Create(const Name: String);
begin
  inherited Create(agtSequence);

  FName := Name;
end;

{ FixedValueAttribute }

constructor FixedValueAttribute.Create(const Value: String);
begin
  inherited Create(agtFixedValue);

  FValue := Value;
end;

{ TLazyManipulator }

constructor TLazyManipulator.Create(const LazyInstance: Pointer; const LazyType: TRttiType);
begin
  inherited Create;

  FLazyInstance := LazyInstance;
  FLazyType := LazyType;
end;

function TLazyManipulator.GetHasValue: Boolean;
begin
  Result := FLazyType.GetMethod('GetHasValue').Invoke(TValue.From(FLazyInstance), []).AsBoolean;
end;

function TLazyManipulator.GetLazyLoadedField: TRttiField;
begin
  Result := FLazyType.GetField('FLoaded');
end;

function TLazyManipulator.GetLazyLoaderField: TRttiField;
begin
  Result := FLazyType.GetField('FLoader');
end;

class function TLazyManipulator.GetLazyLoadingType(const LazyType: TRttiType): TRttiType;
begin
  Result := LazyType.GetMethod('GetValue').ReturnType;
end;

function TLazyManipulator.GetLazyValueField: TRttiField;
begin
  Result := FLazyType.GetField('FValue');
end;

class function TLazyManipulator.GetLazyLoadingType(const LazyProperty: TRttiProperty): TRttiType;
begin
  Result := GetLazyLoadingType(LazyProperty.PropertyType);
end;

function TLazyManipulator.GetLoaded: Boolean;
begin
{$IFDEF DCC}
  Result := LazyLoadedField.GetValue(FLazyInstance).AsBoolean;
{$ELSE}
  Result := Boolean(TJSObject(FLazyInstance)['FLoaded']);
{$ENDIF}
end;

function TLazyManipulator.GetLoader: ILazyLoader;
begin
{$IFDEF DCC}
  Result := LazyLoaderField.GetValue(FLazyInstance).AsType<ILazyLoader>;
{$ELSE}
  Result := ILazyLoader(TJSObject(FLazyInstance)['FLoader']);
{$ENDIF}
end;

class function TLazyManipulator.GetManipulator(const ObjectInstance: TObject; const LazyProperty: TRttiProperty): ILazyManipulator;
begin
  Result := GetManipulator(TRttiInstanceProperty(LazyProperty).GetRawValue(ObjectInstance), LazyProperty.PropertyType)
end;

class function TLazyManipulator.GetManipulator(const LazyInstance: Pointer; const LazyType: TRttiType): ILazyManipulator;
begin
  Result := TLazyManipulator.Create(LazyInstance, LazyType);
end;

class function TLazyManipulator.GetManipulator<T>(const LazyInstance: T): ILazyManipulator;
begin
  Result := GetManipulator(@LazyInstance, Persisto.Mapping.GetRttiType(TypeInfo(T)));
end;

function TLazyManipulator.GetRttiType: TRttiType;
begin
  Result := GetLazyLoadingType(FLazyType);
end;

function TLazyManipulator.GetValue: TValue;
begin
{$IFDEF DCC}
  Result := PValue(PByte(FLazyInstance) + LazyValueField.Offset)^;
{$ELSE}
  Result := TValue(TJSObject(FLazyInstance)['FValue']);
{$ENDIF}
end;

function TLazyManipulator.GetKey: TValue;
var
  Loader: ILazyLoader;

begin
  Loader := GetLoader;

  if Assigned(Loader) then
    Result := Loader.GetKey
  else
    Result := TValue.Empty;
end;

class function TLazyManipulator.IsLazyLoading(const LazyType: TRttiType): Boolean;
begin
  Result := LazyType.Name.StartsWith(LAZY_NAME);
end;

class function TLazyManipulator.IsLazyLoading(const LazyProperty: TRttiProperty): Boolean;
begin
  Result := IsLazyLoading(LazyProperty.PropertyType);
end;

procedure TLazyManipulator.SetLoaded(const Value: Boolean);
begin
{$IFDEF DCC}
  LazyLoadedField.SetValue(FLazyInstance, TValue.From(Value));
{$ELSE}
  TJSObject(FLazyInstance)['FLoaded'] := Value;
{$ENDIF}
end;

procedure TLazyManipulator.SetLoader(const Value: ILazyLoader);
begin
  SetLoaded(False);

{$IFDEF DCC}
  LazyLoaderField.SetValue(FLazyInstance, TValue.From(Value));
{$ELSE}
  TJSObject(FLazyInstance)['FLoader'] := Value;
{$ENDIF}
end;

procedure TLazyManipulator.SetValue(const Value: TValue);
begin
  FLazyType.GetMethod('SetValue').Invoke(TValue.From(FLazyInstance), [Value]);
end;

{ TNullableManipulator }

constructor TNullableManipulator.Create(const NullableInstance: Pointer; const NullableType: TRttiType);
begin
  inherited Create;

  FNullableInstance := TValue.From(NullableInstance);
  FNullableType := NullableType;
end;

class function TNullableManipulator.GetManipulator(const ObjectInstance: TObject; const NullableProperty: TRttiProperty): INullableManipulator;
begin
  Result := GetManipulator(TRttiInstanceProperty(NullableProperty).GetRawValue(ObjectInstance), NullableProperty.PropertyType);
end;

class function TNullableManipulator.GetManipulator(const Instance: Pointer; const NullableType: TRttiType): INullableManipulator;
begin
  Result := TNullableManipulator.Create(Instance, NullableType);
end;

class function TNullableManipulator.GetNullableType(const NullableType: TRttiType): TRttiType;
begin
  Result := NullableType.GetMethod('GetValue').ReturnType;
end;

class function TNullableManipulator.GetNullableType(const NullableProperty: TRttiProperty): TRttiType;
begin
  Result := GetNullableType(NullableProperty.PropertyType);
end;

function TNullableManipulator.GetRttiType: TRttiType;
begin
  Result := GetNullableType(FNullableType);
end;

function TNullableManipulator.GetValue: TValue;
begin
  if IsNull then
    Result := TValue.Empty
  else
    Result := FNullableType.GetMethod('GetValue').Invoke(FNullableInstance, []);
end;

function TNullableManipulator.IsNull: Boolean;
begin
  Result := FNullableType.GetMethod('IsNull').Invoke(FNullableInstance, []).AsBoolean;
end;

class function TNullableManipulator.IsNullable(const NullableType: TRttiType): Boolean;
begin
  Result := NullableType.Name.StartsWith(NULLABLE_TYPE_NAME);
end;

class function TNullableManipulator.IsNullable(const NullableProperty: TRttiProperty): Boolean;
begin
  Result := IsNullable(NullableProperty.PropertyType);
end;

procedure TNullableManipulator.SetValue(const Value: TValue);
begin
  if Value.IsEmpty then
    FNullableType.GetMethod('Clear').Invoke(FNullableInstance, [])
  else
    FNullableType.GetMethod('SetValue').Invoke(FNullableInstance, [Value])
end;

{ Nullable<T> }

{$IFDEF DCC}
class operator Nullable<T>.Implicit(const Value: Nullable<T>): T;
begin
  Result := Value.Value;
end;

class operator Nullable<T>.Implicit(const Value: T): Nullable<T>;
begin
  Result.Value := Value;
end;

class operator Nullable<T>.Implicit(const Value: TNullEnumerator): Nullable<T>;
begin
  Result.Clear;
end;
{$ENDIF}

procedure Nullable<T>.Clear;
begin
  FLoaded := False;
end;

function Nullable<T>.GetValue: T;
begin
  Result := FValue.AsType<T>;
end;

function Nullable<T>.IsNull: Boolean;
begin
  Result := not FLoaded;
end;

procedure Nullable<T>.SetValue(const Value: T);
begin
  FLoaded := True;

  TValue.Make<T>(Value, FValue);
end;

{ TRttiTypeHelper }

function TRttiTypeHelper.AsArray: TRttiDynamicArrayType;
begin
  Result := Self as TRttiDynamicArrayType;
end;

function TRttiTypeHelper.IsArray: Boolean;
begin
  Result := Self is TRttiDynamicArrayType;
end;

{ TValueHelper }

function TValueHelper.GetArrayElementInternal(Index: Integer): TValue;
begin
  Result := GetArrayElement(Index);
end;

function TValueHelper.GetArrayLengthInternal: Integer;
begin
  Result := GetArrayLength;
end;

function TValueHelper.GetAsString: String;
begin
  if IsEmpty then
    Exit(EmptyStr);

  case Kind of
{$IFDEF DCC}
    tkWChar,
    tkLString,
    tkWString,
    tkUString,
{$ENDIF}
    tkChar,
    tkString:
      Result := Self.ToString;

{$IFDEF DCC}
    tkInt64,
{$ENDIF}
    tkInteger:
      Result := Self.ToString;

    tkEnumeration: Result := AsOrdinal.ToString;

    tkFloat:
    begin
      if TypeInfo = System.TypeInfo(TDate) then
        Result := DateToStr(AsExtended, FormatSettings)
      else if TypeInfo = System.TypeInfo(TTime) then
        Result := TimeToStr(AsExtended, FormatSettings)
      else if TypeInfo = System.TypeInfo(TDateTime) then
        Result := DateTimeToStr(AsExtended, FormatSettings)
      else
        Result := FloatToStr(AsExtended, FormatSettings);
    end;

    tkRecord: Result := AsType<TGUID>.ToString;
  end;
end;

procedure TValueHelper.SetArrayElementInternal(Index: Integer; const Value: TValue);
begin
  SetArrayElement(Index, Value);
end;

procedure TValueHelper.SetArrayLengthInternal(const Size: Integer);
begin
  if TypeInfo{$IFDEF DCC}^{$ENDIF}.Kind <> tkDynArray then
    raise EInvalidCast.{$IFDEF PAS2JS}Create(SErrInvalidTypecast){$ELSE}CreateRes(@SInvalidCast){$ENDIF};

{$IFDEF PAS2JS}
  SetArrayLength(Size);
{$ELSE}
  var NativeSize: NativeInt := Size;

  DynArraySetLength(PPointer(GetReferenceToRawData)^, TypeInfo, 1, @NativeSize);
{$ENDIF}
end;

{ TRttiPropertyHelper }

function TRttiPropertyHelper.GetRawValue(Instance: Pointer): Pointer;
{$IFDEF DCC}
type
  PIntPtr = ^IntPtr;

var
  getter: Pointer;
  code: Pointer;
  args: TArray<TValue>;
{$ENDIF}
begin
{$IFDEF DCC}
  getter := PropInfo^.GetProc;
  if (IntPtr(getter) and PROPSLOT_MASK) = PROPSLOT_FIELD then
    // Field
    Exit(PByte(Instance) + (IntPtr(getter) and (not PROPSLOT_MASK)));

  if (IntPtr(getter) and PROPSLOT_MASK) = PROPSLOT_VIRTUAL then
  begin
    // Virtual dispatch, but with offset, not slot
    code := PPointer(PIntPtr(Instance)^ + SmallInt(IntPtr(getter)))^;
  end
  else
  begin
    // Static dispatch
    code := getter;
  end;

//  CheckCodeAddress(code);

  if Index = Integer($80000000) then
  begin
    // no index
    SetLength(args, 1);
    args[0] := TObject(Instance);
    Result := Invoke(code, args, ccReg, PropertyType.Handle, False).AsType<Pointer>; // not static
  end
  else
  begin
    SetLength(args, 2);
    args[0] := TObject(Instance);
    args[1] := Index;
    Result := Invoke(code, args, ccReg, PropertyType.Handle, False).AsType<Pointer>; // not static
  end;
{$ELSE}
  Result := Pointer(TJSObject(Instance)[PropertyTypeInfo.Getter]);
{$ENDIF}
end;

initialization
  TValue.GFFormatSettings := TFormatSettings.Invariant;
  TValue.GFFormatSettings.ShortDateFormat := 'yyyy-mm-dd';
  TValue.GFFormatSettings.LongDateFormat := 'yyyy-mm-dd"T"hh":"mm":"ss.zzz';
  TValue.GFFormatSettings.LongTimeFormat := 'hh":"mm":"ss';

end.

