unit Persisto.SQLServer;

interface

uses Data.DB, Persisto;

type
  TDatabaseManipulatorSQLServer = class(TDatabaseManipulator, IDatabaseManipulator)
  private
    function GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetFieldType(const Field: TField): String;
    function GetSchemaTablesScripts: TArray<String>;
    function GetSpecialFieldType(const Field: TField): String;
    function MakeInsertStatement(const Table: TTable; const Params: TParams): String;
  end;

implementation

uses System.SysUtils, Persisto.Mapping;

{ TDatabaseManipulatorSQLServer }

function TDatabaseManipulatorSQLServer.GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
const
  INTERNAL_FUNCTIONS: array [TAutoGeneratedType] of String = ('', 'cast(getdate() as date)', 'cast(getdate() as time)', 'getdate()', 'newsequentialid()', 'newid()',
    'next value for [%0:s]', '%1:s');

begin
  var SequenceName := EmptyStr;

  if Assigned(DefaultConstraint.Sequence) then
    SequenceName := DefaultConstraint.Sequence.Name;

  Result := Format(INTERNAL_FUNCTIONS[DefaultConstraint.AutoGeneratedType], [SequenceName, DefaultConstraint.FixedValue]);
end;

function TDatabaseManipulatorSQLServer.GetFieldType(const Field: TField): String;
begin
  case Field.FieldType.TypeKind of
    tkInteger:
      Result := 'int';
    tkEnumeration:
      Result := 'tinyint';
    tkFloat:
      Result := 'numeric';
    tkChar, tkWChar:
      Result := 'char';
    tkInt64:
      Result := 'bigint';
    tkString, tkLString, tkWString, tkUString:
      Result := 'varchar';
  else
    Result := EmptyStr;
  end;
end;

function TDatabaseManipulatorSQLServer.GetSchemaTablesScripts: TArray<String>;
begin
  Result := [
    'create or alter view PersistoDatabaseSequence as (select cast(object_id as varchar(20)) Id, Name from sys.sequences)',
    'create or alter view PersistoDatabaseTable as (select cast(object_id as varchar(20)) Id, Name from sys.tables)',
    'create or alter view PersistoDatabaseTableField as (select cast(column_id as varchar(500)) Id, cast(T.object_id as varchar(20)) IdTable, C.Name from sys.all_columns C, sys.tables T where T.object_id = C.object_id)'
    ];
end;

function TDatabaseManipulatorSQLServer.GetSpecialFieldType(const Field: TField): String;
const
  FIELD_SPECIAL_TYPE_MAPPING: array [TDatabaseSpecialType] of String = ('', 'date', 'datetime', 'time', 'varchar(max)', 'uniqueidentifier', 'bit');

begin
  Result := FIELD_SPECIAL_TYPE_MAPPING[Field.SpecialType];
end;

function TDatabaseManipulatorSQLServer.MakeInsertStatement(const Table: TTable; const Params: TParams): String;
begin
  var FieldNames := EmptyStr;
  var ParamNames := EmptyStr;
  var ReturningFields := EmptyStr;

  for var A := 0 to Pred(Params.Count) do
  begin
    if not FieldNames.IsEmpty then
    begin
      FieldNames := FieldNames + ',';
      ParamNames := ParamNames + ',';
    end;

    FieldNames := FieldNames + Params[A].Name;
    ParamNames := ParamNames + ':' + Params[A].Name;
  end;

  for var Field in Table.ReturningFields do
  begin
    if not ReturningFields.IsEmpty then
      ReturningFields := ReturningFields + ',';

    ReturningFields := ReturningFields + Format('Inserted.%s', [Field.DatabaseName]);
  end;

  Result := 'insert into %s(%s)';

  if not ReturningFields.IsEmpty then
    Result := Result + Format('output %s ', [ReturningFields]);

  Result := Result + 'values(%s)';

  Result := Format(Result, [Table.DatabaseName, FieldNames, ParamNames]);
end;

end.

