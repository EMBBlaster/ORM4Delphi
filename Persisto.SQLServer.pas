unit Persisto.SQLServer;

interface

uses Data.DB, Persisto;

type
  TDatabaseManipulatorSQLServer = class(TDatabaseManipulator, IDatabaseManipulator)
  private
    function GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetFieldType(const Field: TField): String;
    function GetSchemaTablesScripts: TArray<String>;
    function GetSpecialFieldType(const Field: TField): String;
    function MakeInsertStatement(const Table: TTable; const Params: TParams): String;
  end;

implementation

uses System.SysUtils, System.Classes, Persisto.Mapping;

{ TDatabaseManipulatorSQLServer }

function TDatabaseManipulatorSQLServer.GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
const
  INTERNAL_FUNCTIONS: array [TAutoGeneratedType] of String = ('', 'cast(getdate() as date)', 'cast(getdate() as time)', 'getdate()', 'newsequentialid()', 'newid()',
    'next value for [%0:s]', '%1:s');

begin
  var SequenceName := EmptyStr;

  if Assigned(DefaultConstraint.Sequence) then
    SequenceName := DefaultConstraint.Sequence.Name;

  Result := Format(INTERNAL_FUNCTIONS[DefaultConstraint.AutoGeneratedType], [SequenceName, DefaultConstraint.FixedValue]);
end;

function TDatabaseManipulatorSQLServer.GetFieldType(const Field: TField): String;
begin
  case Field.FieldType.TypeKind of
    tkInteger:
      Result := 'int';
    tkEnumeration:
      Result := 'tinyint';
    tkFloat:
      Result := 'numeric';
    tkChar, tkWChar:
      Result := 'char';
    tkInt64:
      Result := 'bigint';
    tkString, tkLString, tkWString, tkUString:
      Result := 'varchar';
  else
    Result := EmptyStr;
  end;
end;

function TDatabaseManipulatorSQLServer.GetSchemaTablesScripts: TArray<String>;
const
  FOREING_KEY_SQL =
      'select cast(object_id as varchar(20)) Id,' +
             'name,' +
             'cast(parent_object_id as varchar(20)) IdTable,' +
             'cast(referenced_object_id as varchar(20)) IdReferenceTable ' +
        'from sys.foreign_keys FK';

  FOREING_KEY_COLUMS_SQL =
      'select cast(FKC.constraint_object_id as varchar(20)) + ''.'' + cast(constraint_column_id as varchar(20)) Id,' +
             'cast(FKC.constraint_object_id as varchar(20)) IdForeignKey,' +
             'RC.name ' +
        'from sys.foreign_keys FK ' +
        'join sys.foreign_key_columns FKC ' +
          'on FKC.constraint_object_id = FK.object_id ' +
        'join sys.columns RC ' +
          'on RC.object_id = FKC.referenced_object_id ' +
         'and RC.column_id = FKC.referenced_column_id';

  SEQUENCES_SQL =
    'select cast(object_id as varchar(20)) Id,' +
            'name ' +
      'from sys.sequences';

  TABLE_SQL =
    'select cast(object_id as varchar(20)) Id,' +
           'Name ' +
      'from sys.tables';

  COLUMNS_SQL =
    'select cast(T.object_id as varchar(20)) + ''.'' + cast(column_id as varchar(500)) Id,' +
           'cast(T.object_id as varchar(20)) IdTable,' +
           'C.Name ' +
      'from sys.all_columns C ' +
      'join sys.tables T ' +
        'on T.object_id = C.object_id';

  function CreateView(const Name, SQL: String): String;
  begin
    Result := Format('create or alter view %s as (%s)', [Name, SQL]);
  end;

begin
  Result := [CreateView('PersistoDatabaseForeignKey', FOREING_KEY_SQL), CreateView('PersistoDatabaseForeignKeyField', FOREING_KEY_COLUMS_SQL),
    CreateView('PersistoDatabaseSequence', SEQUENCES_SQL), CreateView('PersistoDatabaseTable', TABLE_SQL), CreateView('PersistoDatabaseTableField', COLUMNS_SQL)
    ];
end;

function TDatabaseManipulatorSQLServer.GetSpecialFieldType(const Field: TField): String;
const
  FIELD_SPECIAL_TYPE_MAPPING: array [TDatabaseSpecialType] of String = ('', 'date', 'datetime', 'time', 'varchar(max)', 'uniqueidentifier', 'bit');

begin
  Result := FIELD_SPECIAL_TYPE_MAPPING[Field.SpecialType];
end;

function TDatabaseManipulatorSQLServer.MakeInsertStatement(const Table: TTable; const Params: TParams): String;
begin
  var FieldNames := EmptyStr;
  var ParamNames := EmptyStr;
  var ReturningFields := EmptyStr;

  for var A := 0 to Pred(Params.Count) do
  begin
    if not FieldNames.IsEmpty then
    begin
      FieldNames := FieldNames + ',';
      ParamNames := ParamNames + ',';
    end;

    FieldNames := FieldNames + Params[A].Name;
    ParamNames := ParamNames + ':' + Params[A].Name;
  end;

  for var Field in Table.ReturningFields do
  begin
    if not ReturningFields.IsEmpty then
      ReturningFields := ReturningFields + ',';

    ReturningFields := ReturningFields + Format('Inserted.%s', [Field.DatabaseName]);
  end;

  Result := 'insert into %s(%s)';

  if not ReturningFields.IsEmpty then
    Result := Result + Format('output %s ', [ReturningFields]);

  Result := Result + 'values(%s)';

  Result := Format(Result, [Table.DatabaseName, FieldNames, ParamNames]);
end;

end.

