unit Persisto.SQLite;

interface

uses Persisto, Persisto.Mapping;

type
  TDatabaseManipulatorSQLite = class(TDatabaseManipulator, IDatabaseManipulator)
  private
    function CreateSequence(const Sequence: TSequence): String;
    function DropSequence(const Sequence: TDatabaseSequence): String;
    function GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetFieldType(const Field: TField): String;
    function GetSchemaTablesScripts: TArray<String>;
    function GetSpecialFieldType(const Field: TField): String;
    function IsSQLite: Boolean;
  end;

implementation

uses System.SysUtils;

{ TDatabaseManipulatorSQLite }

function TDatabaseManipulatorSQLite.CreateSequence(const Sequence: TSequence): String;
begin
  Result := Format('insert into sqlite_sequence (name, seq) values (''%s'', 0)', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.DropSequence(const Sequence: TDatabaseSequence): String;
begin
  Result := Format('delete from sqlite_sequence where name = ''%s''', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
const
  AUTO_GENERATED_VALUE_MAPPING: array [TAutoGeneratedType] of String = ('', 'date()', 'time()', 'datetime(''now'', ''localtime'')', 'uuid()', 'newguid()', '', '');

begin
  case DefaultConstraint.AutoGeneratedType of
    agtFixedValue:
      Result := DefaultConstraint.FixedValue;
    agtSequence:
      Result := Format('next_value_for(''%s'')', [DefaultConstraint.Sequence.Name]);
  else
    Result := AUTO_GENERATED_VALUE_MAPPING[DefaultConstraint.AutoGeneratedType];
  end;
end;

function TDatabaseManipulatorSQLite.GetFieldType(const Field: TField): String;
begin
  case Field.FieldType.TypeKind of
    tkInteger:
      Result := 'integer';
    tkEnumeration:
      Result := 'smallint';
    tkFloat:
      Result := 'numeric';
    tkChar, tkWChar:
      Result := 'char';
    tkInt64:
      Result := 'bigint';
    tkString, tkLString, tkWString, tkUString:
      Result := 'varchar';
  else
    Result := EmptyStr;
  end;
end;

function TDatabaseManipulatorSQLite.GetSchemaTablesScripts: TArray<String>;
const
  PRIMARY_KEY_CONSTRAINT_FILTER_SQL =
           'pragma_index_list(T.name) PK,' +
           'pragma_index_info(PK.name) PKF ' +
     'where PK.origin = ''pk''';

  PRIMARY_KEY_CONSTRAINT_SQL =
    'select cast(PK.name as varchar(250)) Id,' +
           'cast(''PK_'' || T.name as varchar(250)) Name,' +
           'cast(PKF.name as varchar(250)) FieldName ' +
      'from PersistoDatabaseTable T,' +
            PRIMARY_KEY_CONSTRAINT_FILTER_SQL;

  DEFAULT_CONSTRAINT_SQL =
    'select null Id, null Name, null Value';

  FOREING_KEY_SQL =
    'select cast(FK.id || ''.'' || FK."table" as varchar(250)) Id,' +
           'cast(''FK_'' || T.name || ''_'' || FK."from" as varchar(250)) Name,' +
           'cast(T.name as varchar(250)) IdTable,' +
           'cast(FK."table" as varchar(250)) IdReferenceTable ' +
      'from PersistoDatabaseTable T,' +
           'pragma_foreign_key_list(T.name) FK';

  FOREING_KEY_COLUMS_SQL =
    'select null Id, null Name, null IdForeignKey';

  SEQUENCES_SQL =
    'select cast(name as varchar(250)) Id,' +
           'cast(name as varchar(250)) Name ' +
      'from sqlite_sequence';

  TABLE_SQL =
    'select cast(T.name as varchar(250)) Id,' +
           'cast((select PK.name ' +
                   'from ' + PRIMARY_KEY_CONSTRAINT_FILTER_SQL + ') as varchar(250)) IdPrimaryKeyConstraint,' +
           'cast(T.name as varchar(250)) Name ' +
      'from sqlite_master T ' +
     'where T.type = ''table'' ' +
       'and not T.name like ''sqlite_%''';

  COLUMNS_SQL =
    'select cast(T.name || ''#'' || C.name as varchar(250)) Id,' +
           'null IdDefaultConstraint,' +
           'cast(T.name as varchar(250)) IdTable,' +
           'case lower(substr(type, 1, iif(instr(type, ''('') > 0, 7, length(type)))) ' +
              'when ''varchar'' then 5 ' +
              'when ''integer'' then 1 ' +
              'when ''char'' then 2 ' +
              'when ''smallint'' then 3 ' +
              'when ''numeric'' then 4 ' +
              'when ''bigint'' then 16 ' +
              'else 0 ' +
           'end FieldType,' +
           'cast(C.name as varchar(250)) Name,' +
           '"notnull" Required,' +
           'cast(substr(type, instr(type, '','') + 1, length(type) - instr(type, '','') - 1) as integer) Scale,' +
           'cast(substr(type, instr(type, ''('') + 1, coalesce(nullif(instr(type, '',''), 0), length(type)) - instr(type, ''('') - 1) as integer) Size,' +
           'case lower(type)' +
              // Date
              'when ''date'' then 1 ' +
              // DateTime
              'when ''datetime'' then 2 ' +
              // Time
              'when ''time'' then 3 ' +
              // Text
              'when ''text'' then 4 ' +
              // Unique Identifier
              'when ''uniqueidentifier'' then 5 ' +
              // Boolean
              'when ''boolean'' then 6 ' +
              'else 0 ' +
           'end SpecialType ' +
      'from PersistoDatabaseTable T,' +
           'pragma_table_info(T.name) C';

  function CreateTable(const Name, SQL: String): TArray<String>;
  begin
    Result := [Format('create view if not exists PersistoDatabase%s as %s', [Name, SQL])];
  end;

begin
  Result := ['create table if not exists PersistoDatabaseSequenceWorkArround (sequence integer primary key autoincrement)']
    + CreateTable('Sequence', SEQUENCES_SQL)
    + CreateTable('Table', TABLE_SQL)
    + CreateTable('DefaultConstraint', DEFAULT_CONSTRAINT_SQL)
    + CreateTable('ForeignKey', FOREING_KEY_SQL)
    + CreateTable('ForeignKeyField', FOREING_KEY_COLUMS_SQL)
    + CreateTable('TableField', COLUMNS_SQL)
    + CreateTable('PrimaryKeyConstraint', PRIMARY_KEY_CONSTRAINT_SQL);
end;

function TDatabaseManipulatorSQLite.GetSpecialFieldType(const Field: TField): String;
const
  SPECIAL_TYPE_MAPPING: array [TDatabaseSpecialType] of String = ('', 'date', 'datetime', 'time', 'text', 'uniqueidentifier', 'boolean');

begin
  Result := SPECIAL_TYPE_MAPPING[Field.SpecialType];
end;

function TDatabaseManipulatorSQLite.IsSQLite: Boolean;
begin
  Result := True;
end;

end.

