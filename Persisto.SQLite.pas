unit Persisto.SQLite;

interface

uses Persisto, Persisto.Mapping;

type
  TDatabaseManipulatorSQLite = class(TDatabaseManipulator, IDatabaseManipulator)
  private
    function CreateSequence(const Sequence: TSequence): String;
    function DropSequence(const Sequence: TDatabaseSequence): String;
    function GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetFieldType(const Field: TField): String;
    function GetSchemaTablesScripts: TArray<String>;
    function GetSpecialFieldType(const Field: TField): String;
  end;

implementation

uses System.SysUtils;

{ TDatabaseManipulatorSQLite }

function TDatabaseManipulatorSQLite.CreateSequence(const Sequence: TSequence): String;
begin
  Result := Format('insert into sqlite_sequence (name, seq) values (''%s'', 0)', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.DropSequence(const Sequence: TDatabaseSequence): String;
begin
  Result := Format('delete from sqlite_sequence where name = ''%s''', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
const
  AUTO_GENERATED_VALUE_MAPPING: array [TAutoGeneratedType] of String = ('', 'date()', 'time()', 'datetime(''now'', ''localtime'')', 'uuid()', 'newguid()', '', '');

begin
  case DefaultConstraint.AutoGeneratedType of
    agtFixedValue:
      Result := DefaultConstraint.FixedValue;
    agtSequence:
      Result := Format('next_value_for(''%s'')', [DefaultConstraint.Sequence.Name]);
  else
    Result := AUTO_GENERATED_VALUE_MAPPING[DefaultConstraint.AutoGeneratedType];
  end;
end;

function TDatabaseManipulatorSQLite.GetFieldType(const Field: TField): String;
begin
  case Field.FieldType.TypeKind of
    tkInteger:
      Result := 'int';
    tkEnumeration:
      Result := 'smallint';
    tkFloat:
      Result := 'numeric';
    tkChar, tkWChar:
      Result := 'char';
    tkInt64:
      Result := 'bigint';
    tkString, tkLString, tkWString, tkUString:
      Result := 'varchar';
  else
    Result := EmptyStr;
  end;
end;

function TDatabaseManipulatorSQLite.GetSchemaTablesScripts: TArray<String>;
const
  DEFAULT_CONSTRAINT_SQL =
    'select null Id, null Name, null Value';

  FOREING_KEY_SQL =
    'select null Id, null Name, null IdTable, null IdReferenceTable';

  FOREING_KEY_COLUMS_SQL =
    'select null Id, null Name, null IdForeignKey';

  SEQUENCES_SQL =
    'select Name Id,' +
           'Name ' +
      'from sqlite_sequence';

  TABLE_SQL =
    'select name Id,' +
           'name Name ' +
      'from sqlite_master ' +
     'where type = ''table'' ' +
       'and not name like ''sqlite_%''';

  COLUMNS_SQL =
    'select T.name || ''#'' || C.name Id,' +
           'null IdDefaultConstraint,' +
           'T.name IdTable,' +
           '0 FieldType,' +
           'C.name Name,' +
           '0 Required,' +
           '0 Scale,' +
           '0 Size,' +
           '0 SpecialType ' +
      'from PersistoDatabaseTable T,' +
           'pragma_table_info(T.name) C';

  function CreateTable(const Name: String; const Fields: TArray<String>; const SQL: String): TArray<String>;

    function GetFieldList: String;
    begin
      Result := EmptyStr;

      for var Field in Fields do
        Result := Result + Format('%s,', [Field.Split([' '])[0]]);

      Result := Result.Substring(0, Pred(Result.Length));
    end;

    function GetCreateFieldList: String;
    begin
      Result := EmptyStr;

      for var Field in Fields do
        Result := Result + Format('%s,', [Field]);

      Result := Result.Substring(0, Pred(Result.Length));
    end;

  begin
    Result := [Format('create table if not exists PersistoDatabase%s (%s)', [Name, GetCreateFieldList]), Format('delete from PersistoDatabase%s', [Name]),
      Format('insert into PersistoDatabase%s (%s) %s', [Name, GetFieldList, SQL])];
  end;

const
  FOREIGN_KEY_ID = '''FK_'' || T.name || ''_'' || FK."table" || ''_'' || FK."from"';

begin
  Result := ['create table if not exists PersistoDatabaseSequenceWorkArround (sequence integer primary key autoincrement)']
    + CreateTable('DefaultConstraint', ['Id varchar(250)', 'Name varchar(250)', 'Value varchar(250)'], DEFAULT_CONSTRAINT_SQL)
    + CreateTable('ForeignKey', ['Id varchar(250)', 'Name varchar(250)', 'IdTable varchar(250)', 'IdReferenceTable varchar(250)'], FOREING_KEY_SQL)
    + CreateTable('ForeignKeyField', ['Id varchar(250)', 'Name varchar(250)', 'IdForeignKey varchar(250)'], FOREING_KEY_COLUMS_SQL)
    + CreateTable('Sequence', ['Id varchar(250)', 'Name varchar(250)'], SEQUENCES_SQL)
    + CreateTable('Table', ['Id varchar(250)', 'Name varchar(250)'], TABLE_SQL)
    + CreateTable('TableField', ['Id varchar(250)', 'IdDefaultConstraint varchar(250)', 'IdTable varchar(250)', 'FieldType int', 'Name varchar(250)', 'Required int', 'Scale int',
      'Size int', 'SpecialType int'], COLUMNS_SQL);
end;

function TDatabaseManipulatorSQLite.GetSpecialFieldType(const Field: TField): String;
const
  SPECIAL_TYPE_MAPPING: array [TDatabaseSpecialType] of String = ('', 'date', 'datetime', 'time', 'text', 'varchar(38)', 'boolean');

begin
  Result := SPECIAL_TYPE_MAPPING[Field.SpecialType];
end;

end.

