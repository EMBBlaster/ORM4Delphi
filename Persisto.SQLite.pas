unit Persisto.SQLite;

interface

uses Persisto, Persisto.Mapping;

type
  TDatabaseManipulatorSQLite = class(TDatabaseManipulator, IDatabaseManipulator)
  private
    function CreateSequence(const Sequence: TSequence): String;
    function DropSequence(const Sequence: TDatabaseSequence): String;
    function GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetFieldType(const Field: TField): String;
    function GetSchemaTablesScripts: TArray<String>;
    function GetSpecialFieldType(const Field: TField): String;
  end;

implementation

uses System.SysUtils;

{ TDatabaseManipulatorSQLite }

function TDatabaseManipulatorSQLite.CreateSequence(const Sequence: TSequence): String;
begin
  Result := Format('insert into sqlite_sequence (name, seq) values (''%s'', 0)', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.DropSequence(const Sequence: TDatabaseSequence): String;
begin
  Result := Format('delete from sqlite_sequence where name = ''%s''', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
const
  AUTO_GENERATED_VALUE_MAPPING: array [TAutoGeneratedType] of String = ('', 'date()', 'time()', 'datetime(''now'', ''localtime'')', 'uuid()', 'uuid()', '', '');

begin
  case DefaultConstraint.AutoGeneratedType of
    agtFixedValue:
      Result := DefaultConstraint.FixedValue;
    agtSequence:
      Result := Format('next_value_for(''%s'')', [DefaultConstraint.Sequence.Name]);
  else
    Result := AUTO_GENERATED_VALUE_MAPPING[DefaultConstraint.AutoGeneratedType];
  end;
end;

function TDatabaseManipulatorSQLite.GetFieldType(const Field: TField): String;
begin
  case Field.FieldType.TypeKind of
    tkInteger:
      Result := 'int';
    tkEnumeration:
      Result := 'smallint';
    tkFloat:
      Result := 'numeric';
    tkChar, tkWChar:
      Result := 'char';
    tkInt64:
      Result := 'bigint';
    tkString, tkLString, tkWString, tkUString:
      Result := 'varchar';
  else
    Result := EmptyStr;
  end;
end;

function TDatabaseManipulatorSQLite.GetSchemaTablesScripts: TArray<String>;
const
  FOREIGN_KEY_ID = '''FK_'' || T.name || ''_'' || FK."table" || ''_'' || FK."from"';

begin
  Result := [
    'create table if not exists PersistoDatabaseSequence (id varchar(250), name varchar(250), sequence integer primary key autoincrement)',
    'create table if not exists PersistoDatabaseForeignKey (id varchar(250), name varchar(250), IdTable varchar(250), IdReferenceTable varchar(250))',
    'create table if not exists PersistoDatabaseForeignKeyField (id varchar(250), name varchar(250), IdForeignKey varchar(250))',
    'create table if not exists PersistoDatabaseTable (id varchar(250), name varchar(250))',
    'create table if not exists PersistoDatabaseTableField (id varchar(250), name varchar(250), IdTable varchar(250))',

    'delete from PersistoDatabaseSequence',
    'delete from PersistoDatabaseForeignKey',
    'delete from PersistoDatabaseForeignKeyField',
    'delete from PersistoDatabaseTable',
    'delete from PersistoDatabaseTableField',

    'insert into PersistoDatabaseSequence (name) select name from sqlite_sequence',
    'insert into PersistoDatabaseTable (id, name) select name, name from sqlite_master T where T.type = ''table'' and not T.name like ''sqlite_%''',
    'insert into PersistoDatabaseTableField (id, name, IdTable) select T.name || ''#'' || C.name, C.name, T.name from PersistoDatabaseTable T, pragma_table_info(T.name) C',

    Format('insert into PersistoDatabaseForeignKey (id, name, idReferenceTable, IdTable) select %0:s Id, %0:s name, FK."table" IdReferenceTable, T.name IdTable from PersistoDatabaseTable T, pragma_foreign_key_list(T.name) FK', [FOREIGN_KEY_ID])
  ];
end;

function TDatabaseManipulatorSQLite.GetSpecialFieldType(const Field: TField): String;
const
  SPECIAL_TYPE_MAPPING: array [TDatabaseSpecialType] of String = ('', 'date', 'datetime', 'time', 'text', 'varchar(38)', 'boolean');

begin
  Result := SPECIAL_TYPE_MAPPING[Field.SpecialType];
end;

end.
