unit Persisto.SQLite;

interface

uses Persisto, Persisto.Mapping;

type
  TDatabaseManipulatorSQLite = class(TDatabaseManipulator, IDatabaseManipulator)
  private
    function CreateSequence(const Sequence: TSequence): String;
    function DropSequence(const Sequence: TDatabaseSequence): String;
    function GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetFieldType(const Field: TField): String;
    function GetSchemaTablesScripts: TArray<String>;
    function GetSpecialFieldType(const Field: TField): String;
    function IsSQLite: Boolean;
  end;

implementation

uses System.SysUtils;

{ TDatabaseManipulatorSQLite }

function TDatabaseManipulatorSQLite.CreateSequence(const Sequence: TSequence): String;
begin
  Result := Format('insert into sqlite_sequence (name, seq) values (''%s'', 0)', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.DropSequence(const Sequence: TDatabaseSequence): String;
begin
  Result := Format('delete from sqlite_sequence where name = ''%s''', [Sequence.Name]);
end;

function TDatabaseManipulatorSQLite.GetDefaultValue(const DefaultConstraint: TDefaultConstraint): String;
const
  AUTO_GENERATED_VALUE_MAPPING: array [TAutoGeneratedType] of String = ('', 'date()', 'time()', 'datetime(''now'', ''localtime'')', 'uuid()', 'newguid()', '', '');

begin
  case DefaultConstraint.AutoGeneratedType of
    agtFixedValue:
      Result := DefaultConstraint.FixedValue;
    agtSequence:
      Result := Format('next_value_for(''%s'')', [DefaultConstraint.Sequence.Name]);
  else
    Result := AUTO_GENERATED_VALUE_MAPPING[DefaultConstraint.AutoGeneratedType];
  end;
end;

function TDatabaseManipulatorSQLite.GetFieldType(const Field: TField): String;
begin
  case Field.FieldType.TypeKind of
    tkInteger:
      Result := 'integer';
    tkEnumeration:
      Result := 'smallint';
    tkFloat:
      Result := 'numeric';
    tkChar, tkWChar:
      Result := 'char';
    tkInt64:
      Result := 'bigint';
    tkString, tkLString, tkWString, tkUString:
      Result := 'varchar';
  else
    Result := EmptyStr;
  end;
end;

function TDatabaseManipulatorSQLite.GetSchemaTablesScripts: TArray<String>;
const
  DEFAULT_CONSTRAINT_SQL =
    'select null Id, null Name, null Value';

  FOREING_KEY_SQL =
    'select FK.id || ''.'' || FK."table" Id,' +
           '''FK_'' || T.name || ''_'' || FK."from" Name,' +
           'T.name IdTable,' +
           'FK."table" IdReferenceTable ' +
      'from PersistoDatabaseTable T,' +
           'pragma_foreign_key_list(T.name) FK';

  FOREING_KEY_COLUMS_SQL =
    'select null Id, null Name, null IdForeignKey';

  SEQUENCES_SQL =
    'select Name Id,' +
           'Name ' +
      'from sqlite_sequence';

  TABLE_SQL =
    'select name Id,' +
           'name Name ' +
      'from sqlite_master ' +
     'where type = ''table'' ' +
       'and not name like ''sqlite_%''';

  COLUMNS_SQL =
    'select T.name || ''#'' || C.name Id,' +
           'null IdDefaultConstraint,' +
           'T.name IdTable,' +
           'case lower(substr(type, 1, iif(instr(type, ''('') > 0, 7, length(type)))) ' +
              'when ''varchar'' then 5 ' +
              'when ''integer'' then 1 ' +
              'when ''char'' then 2 ' +
              'when ''smallint'' then 3 ' +
              'when ''numeric'' then 4 ' +
              'when ''bigint'' then 16 ' +
              'else 0 ' +
           'end FieldType,' +
           'C.name Name,' +
           '"notnull" Required,' +
           'cast(substr(type, instr(type, '','') + 1, length(type) - instr(type, '','') - 1) as integer) Scale,' +
           'cast(substr(type, instr(type, ''('') + 1, coalesce(nullif(instr(type, '',''), 0), length(type)) - instr(type, ''('') - 1) as integer) Size,' +
           'case lower(type)' +
              // Date
              'when ''date'' then 1 ' +
              // DateTime
              'when ''datetime'' then 2 ' +
              // Time
              'when ''time'' then 3 ' +
              // Text
              'when ''text'' then 4 ' +
              // Unique Identifier
              'when ''uniqueidentifier'' then 5 ' +
              // Boolean
              'when ''boolean'' then 6 ' +
              'else 0 ' +
           'end SpecialType ' +
      'from PersistoDatabaseTable T,' +
           'pragma_table_info(T.name) C';

  function CreateTable(const Name: String; const Fields: TArray<String>; const SQL: String): TArray<String>;

    function GetFieldList: String;
    begin
      Result := EmptyStr;

      for var Field in Fields do
        Result := Result + Format('%s,', [Field.Split([' '])[0]]);

      Result := Result.Substring(0, Pred(Result.Length));
    end;

    function GetCreateFieldList: String;
    begin
      Result := EmptyStr;

      for var Field in Fields do
        Result := Result + Format('%s,', [Field]);

      Result := Result.Substring(0, Pred(Result.Length));
    end;

  begin
    Result := [Format('create table if not exists PersistoDatabase%s (%s)', [Name, GetCreateFieldList]), Format('delete from PersistoDatabase%s', [Name]),
      Format('insert into PersistoDatabase%s (%s) %s', [Name, GetFieldList, SQL])];
  end;

begin
  Result := ['create table if not exists PersistoDatabaseSequenceWorkArround (sequence integer primary key autoincrement)']
    + CreateTable('Sequence', ['Id varchar(250)', 'Name varchar(250)'], SEQUENCES_SQL)
    + CreateTable('Table', ['Id varchar(250)', 'Name varchar(250)'], TABLE_SQL)
    + CreateTable('DefaultConstraint', ['Id varchar(250)', 'Name varchar(250)', 'Value varchar(250)'], DEFAULT_CONSTRAINT_SQL)
    + CreateTable('ForeignKey', ['Id varchar(250)', 'Name varchar(250)', 'IdTable varchar(250)', 'IdReferenceTable varchar(250)'], FOREING_KEY_SQL)
    + CreateTable('ForeignKeyField', ['Id varchar(250)', 'Name varchar(250)', 'IdForeignKey varchar(250)'], FOREING_KEY_COLUMS_SQL)
    + CreateTable('TableField', ['Id varchar(250)', 'IdDefaultConstraint varchar(250)', 'IdTable varchar(250)', 'FieldType integer', 'Name varchar(250)', 'Required integer',
      'Scale integer', 'Size integer', 'SpecialType integer'], COLUMNS_SQL);
end;

function TDatabaseManipulatorSQLite.GetSpecialFieldType(const Field: TField): String;
const
  SPECIAL_TYPE_MAPPING: array [TDatabaseSpecialType] of String = ('', 'date', 'datetime', 'time', 'text', 'uniqueidentifier', 'boolean');

begin
  Result := SPECIAL_TYPE_MAPPING[Field.SpecialType];
end;

function TDatabaseManipulatorSQLite.IsSQLite: Boolean;
begin
  Result := True;
end;

end.

