unit Persisto;

interface

uses System.TypInfo, System.Rtti, System.SysUtils, System.Generics.Collections, System.Generics.Defaults, Persisto.Mapping;

type
  TBuilderOptions = set of (boBeautifyQuery, boJoinMapping, boDestroyForeignObjects);

  IMetadataManipulator = interface;
  IQueryBuilderAccess = interface;
  TChange = class;
  TDatabaseCheckConstraint = class;
  TDatabaseDefaultConstraint = class;
  TDatabaseField = class;
  TDatabaseForeignKey = class;
  TDatabaseIndex = class;
  TDatabaseSchema = class;
  TDatabaseSequence = class;
  TDatabaseTable = class;
  TField = class;
  TForeignKey = class;
  TIndex = class;
  TManager = class;
  TManyValueAssociation = class;
  TMapper = class;
  TQueryBuilder = class;
  TQueryBuilderAllFields = class;
  TQueryBuilderComparison = class;
  TQueryBuilderFieldAlias = class;
  TQueryBuilderFrom = class;
  TQueryBuilderJoin = class;
  TQueryBuilderOpen = class;
  TQueryBuilderSelect = class;
  TQueryBuilderWhere = class;
  TQueryBuilderWhere<T: class> = class;
  TTable = class;

  ECantFilterManyValueAssociation = class(Exception)
  public
    constructor Create(Field: TField);
  end;

  EFieldNotFoundInTable = class(Exception)
  public
    constructor Create(FieldName: String);
  end;

  EObjectReferenceWasNotFound = class(Exception)
  public
    constructor Create;
  end;

  ECommandWithoutFromClause = class(Exception)
  public
    constructor Create;
  end;

  EChildTableMustHasToHaveAPrimaryKey = class(Exception)
  public
    constructor Create(ChildTable: TTable);
  end;

  EClassWithoutPrimaryKeyDefined = class(Exception)
  public
    constructor Create(Table: TTable);
  end;

  EClassWithPrimaryKeyNullable = class(Exception)
  public
    constructor Create(Table: TTable);
  end;

  EFieldIndexNotFound = class(Exception)
  public
    constructor Create(const Table: TTable; const FieldName: String);
  end;

  EForeignKeyToSingleTableInheritanceTable = class(Exception)
  public
    constructor Create(ParentTable: TRttiInstanceType);
  end;

  EInvalidEnumeratorName = class(Exception)
  public
    constructor Create(Enumeration: TRttiEnumerationType; EnumeratorValue: String);
  end;

  EManyValueAssociationLinkError = class(Exception)
  public
    constructor Create(ParentTable, ChildTable: TTable);
  end;

  ETableNotFound = class(Exception)
  public
    constructor Create(TheClass: TClass);
  end;

  ESequenceAlreadyExists = class(Exception)
  public
    constructor Create(const SequenceName: String);
  end;

  ETableWithoutPublishedFields = class(Exception)
  public
    constructor Create(const Table: TTable);
  end;

  TTableObject = class
  private
    FTable: TTable;
  public
    constructor Create(const Table: TTable);

    property Table: TTable read FTable;
  end;

  TTable = class
  private
    FBaseTable: TTable;
    FClassTypeInfo: TRttiInstanceType;
    FDatabaseName: String;
    FDefaultRecords: TList<TObject>;
    FFields: TArray<TField>;
    FForeignKeys: TArray<TForeignKey>;
    FIndexes: TArray<TIndex>;
    FManyValueAssociations: TArray<TManyValueAssociation>;
    FMapper: TMapper;
    FName: String;
    FPrimaryKey: TField;

    function GetDefaultRecords: TList<TObject>;
    function GetField(const FieldName: String): TField;
  public
    constructor Create(TypeInfo: TRttiInstanceType);

    destructor Destroy; override;

    function FindField(const FieldName: String; var Field: TField): Boolean;
    function GetCacheKey(const Instance: TObject): String; overload;
    function GetCacheKey(const PrimaryKeyValue: Variant): String; overload;

    property BaseTable: TTable read FBaseTable;
    property ClassTypeInfo: TRttiInstanceType read FClassTypeInfo;
    property DatabaseName: String read FDatabaseName write FDatabaseName;
    property DefaultRecords: TList<TObject> read GetDefaultRecords;
    property Field[const FieldName: String]: TField read GetField; default;
    property Fields: TArray<TField> read FFields write FFields;
    property ForeignKeys: TArray<TForeignKey> read FForeignKeys;
    property Indexes: TArray<TIndex> read FIndexes;
    property ManyValueAssociations: TArray<TManyValueAssociation> read FManyValueAssociations;
    property Mapper: TMapper read FMapper;
    property Name: String read FName write FName;
    property PrimaryKey: TField read FPrimaryKey;
  end;

  TSequence = class
  private
    FName: String;
  public
    constructor Create(const Name: String);

    property Name: String read FName write FName;
  end;

  TDefaultConstraint = class
  private
    FAutoGeneratedType: TAutoGeneratedType;
    FSequence: TSequence;
    FFixedValue: String;
  public
    property AutoGeneratedType: TAutoGeneratedType read FAutoGeneratedType write FAutoGeneratedType;
    property FixedValue: String read FFixedValue write FFixedValue;
    property Sequence: TSequence read FSequence write FSequence;
  end;

  TField = class(TTableObject)
  private
    FCollation: String;
    FDatabaseName: String;
    FDefaultConstraint: TDefaultConstraint;
    FFieldType: TRttiType;
    FForeignKey: TForeignKey;
    FInPrimaryKey: Boolean;
    FIsForeignKey: Boolean;
    FIsJoinLink: Boolean;
    FIsLazy: Boolean;
    FIsManyValueAssociation: Boolean;
    FIsNullable: Boolean;
    FIsReadOnly: Boolean;
    FManyValueAssociation: TManyValueAssociation;
    FName: String;
    FPropertyInfo: TRttiInstanceProperty;
    FRequired: Boolean;
    FScale: Word;
    FSize: Word;
    FSpecialType: TDatabaseSpecialType;

    function GetAutoGenerated: Boolean;
  public
    destructor Destroy; override;

    function ConvertVariant(const Value: Variant): TValue;
    function GetAsString(const Instance: TObject): String; overload;
    function GetAsString(const Value: TValue): String; overload;
    function GetPropertyValue(const Instance: TObject): TValue;
    function GetValue(const Instance: TObject): TValue; virtual;
    function HasValue(const Instance: TObject; var Value: TValue): Boolean;

    procedure SetValue(const Instance: TObject; const Value: TValue); overload; virtual;
    procedure SetValue(const Instance: TObject; const Value: Variant); overload;

    property AutoGenerated: Boolean read GetAutoGenerated;
    property Collation: String read FCollation write FCollation;
    property DatabaseName: String read FDatabaseName write FDatabaseName;
    property DefaultConstraint: TDefaultConstraint read FDefaultConstraint write FDefaultConstraint;
    property FieldType: TRttiType read FFieldType write FFieldType;
    property ForeignKey: TForeignKey read FForeignKey write FForeignKey;
    property InPrimaryKey: Boolean read FInPrimaryKey;
    property IsForeignKey: Boolean read FIsForeignKey write FIsForeignKey;
    property IsJoinLink: Boolean read FIsJoinLink;
    property IsLazy: Boolean read FIsLazy;
    property IsManyValueAssociation: Boolean read FIsManyValueAssociation;
    property IsReadOnly: Boolean read FIsReadOnly;
    property ManyValueAssociation: TManyValueAssociation read FManyValueAssociation;
    property Name: String read FName write FName;
    property PropertyInfo: TRttiInstanceProperty read FPropertyInfo;
    property Required: Boolean read FRequired write FRequired;
    property Scale: Word read FScale write FScale;
    property Size: Word read FSize write FSize;
    property SpecialType: TDatabaseSpecialType read FSpecialType write FSpecialType;
  end;

  TFieldAlias = record
  private
    FField: TField;
    FTableAlias: String;
  public
    constructor Create(TableAlias: String; Field: TField);

    property Field: TField read FField write FField;
    property TableAlias: String read FTableAlias write FTableAlias;
  end;

  TForeignKey = class(TTableObject)
  private
    FDatabaseName: String;
    FField: TField;
    FIsInheritedLink: Boolean;
    FManyValueAssociation: TManyValueAssociation;
    FParentTable: TTable;
  public
    property DatabaseName: String read FDatabaseName;
    property Field: TField read FField;
    property IsInheritedLink: Boolean read FIsInheritedLink;
    property ManyValueAssociation: TManyValueAssociation read FManyValueAssociation;
    property ParentTable: TTable read FParentTable;
  end;

  TManyValueAssociation = class
  private
    FChildTable: TTable;
    FField: TField;
    FForeignKey: TForeignKey;
  public
    constructor Create(const Field: TField; const ChildTable: TTable; const ForeignKey: TForeignKey);

    property ChildTable: TTable read FChildTable;
    property Field: TField read FField write FField;
    property ForeignKey: TForeignKey read FForeignKey;
  end;

  TIndex = class(TTableObject)
  private
    FDatabaseName: String;
    FFields: TArray<TField>;
    FPrimaryKey: Boolean;
    FUnique: Boolean;
  public
    property DatabaseName: String read FDatabaseName write FDatabaseName;
    property Fields: TArray<TField> read FFields write FFields;
    property PrimaryKey: Boolean read FPrimaryKey write FPrimaryKey;
    property Unique: Boolean read FUnique write FUnique;
  end;

  TMapper = class
  private
    FContext: TRttiContext;
    FDefaultRecords: TDictionary<String, TObject>;
    FDelayLoadTable: TList<TTable>;
    FSequences: TDictionary<String, TSequence>;
    FTables: TDictionary<TRttiInstanceType, TTable>;

    function CheckAttribute<T: TCustomAttribute>(const TypeInfo: TRttiType): Boolean;
    function CreateSequence(const Name: String): TSequence;
    function CreateIndex(const Table: TTable; const Name: String): TIndex;
    function GetFieldDatabaseName(const Field: TField): String;
    function GetNameAttribute<T: TCustomNameAttribute>(const TypeInfo: TRttiNamedObject; var Name: String): Boolean;
    function GetManyValuAssociationLinkName(const Field: TField): String;
    function GetPrimaryKeyPropertyName(const TypeInfo: TRttiInstanceType): String;
    function GetSequences: TArray<TSequence>;
    function GetTableDatabaseName(const Table: TTable): String;
    function GetTables: TArray<TTable>;
    function IsSingleTableInheritance(const RttiType: TRttiInstanceType): Boolean;
    function LoadTable(const TypeInfo: TRttiInstanceType): TTable;

    procedure AddTableForeignKey(const Table: TTable; const Field: TField; const ForeignTable: TTable; const IsInheritedLink: Boolean); overload;
    procedure AddTableForeignKey(const Table: TTable; const Field: TField; const ClassInfoType: TRttiInstanceType); overload;
    procedure LoadDefaultConstraint(const Field: TField);
    procedure LoadDelayedTables;
    procedure LoadFieldInfo(const Table: TTable; const PropertyInfo: TRttiInstanceProperty; const Field: TField);
    procedure LoadFieldTypeInfo(const Field: TField);
    procedure LoadTableFields(const TypeInfo: TRttiInstanceType; const Table: TTable);
    procedure LoadTableForeignKeys(const Table: TTable);
    procedure LoadTableIndexes(const TypeInfo: TRttiInstanceType; const Table: TTable);
    procedure LoadTableInfo(const TypeInfo: TRttiInstanceType; const Table: TTable);
    procedure LoadTableManyValueAssociations(const Table: TTable);

    function FindSequence(const Name: String): TSequence;
    function FindTable(const ClassInfo: PTypeInfo): TTable; overload;
    function FindTable(const ClassInfo: TClass): TTable; overload;
    function LoadClass(const ClassInfo: TClass): TTable;
    function TryFindTable(const ClassInfo: PTypeInfo; var Table: TTable): Boolean;
  public
    constructor Create;

    destructor Destroy; override;

    function GetTable(const ClassInfo: TClass): TTable; overload;
    function GetTable(const TypeInfo: PTypeInfo): TTable; overload;

    procedure AddDefaultRecord(const Value: TObject);
    procedure LoadAll; overload;
    procedure LoadAll(const Schema: TArray<TClass>); overload;

    property DefaultRecords: TDictionary<String, TObject> read FDefaultRecords;
    property Sequences: TArray<TSequence> read GetSequences;
    property Tables: TArray<TTable> read GetTables;
  end;

  IChangeManager = interface
    function GetChanges(const Instance: TObject): TChange;

    procedure AddInstance(Table: TTable; const Instance: TObject);

    property Changes[const Instance: TObject]: TChange read GetChanges;
  end;

  TChange = class
  private
    FChange: TDictionary<TField, String>;

    function GetChange(const Field: TField): String;
    function GetChangeCount: Integer;

    procedure SetChange(const Field: TField; const Value: String);
  public
    constructor Create;

    destructor Destroy; override;

    property Change[const Field: TField]: String read GetChange write SetChange; default;
    property ChangeCount: Integer read GetChangeCount;
  end;

  TChangeManager = class(TInterfacedObject, IChangeManager)
  private
    FChanges: TDictionary<TObject, TChange>;

    function GetChanges(const Instance: TObject): TChange;

    procedure AddInstance(Table: TTable; const Instance: TObject);

    property Changes[const Instance: TObject]: TChange read GetChanges;
  public
    constructor Create;

    destructor Destroy; override;
  end;

  ICache = interface
    ['{E910CEFC-7423-4307-B805-0B313BF46735}']
    function Add(const Key: String; const Value: TObject): TObject; overload;
    function Get(const Key: String; var Value: TObject): Boolean;
    function GetChangeManager: IChangeManager;

    property ChangeManager: IChangeManager read GetChangeManager;
  end;

  TCache = class(TInterfacedObject, ICache)
  private
    FChangeManger: IChangeManager;
    FReadWriteControl: IReadWriteSync;
    FValues: TDictionary<String, TObject>;

    function Add(const Key: String; const Value: TObject): TObject; overload;
    function Get(const Key: String; var Value: TObject): Boolean;
    function GetChangeManager: IChangeManager;

    class function GenerateKey(const KeyName: String; const KeyValue: TValue): String; overload;
  public
    constructor Create; overload;
    constructor Create(const ChangeManager: IChangeManager); overload;

    destructor Destroy; override;

    class function GenerateKey(AClass: TClass; const KeyValue: TValue): String; overload;
    class function GenerateKey(RttiType: TRttiType; const KeyValue: TValue): String; overload;
  end;

  IDatabaseCursor = interface
    ['{19CBD0F4-8766-4F1D-8E88-F7E03E6A5E28}']
    function GetFieldValue(const FieldIndex: Integer): Variant;
    function Next: Boolean;
  end;

  IDatabaseTransaction = interface
    ['{218FA473-10BD-406B-B01B-79AF603570FE}']
    procedure Commit;
    procedure Rollback;
  end;

  IDatabaseConnection = interface
    ['{7FF2A2F4-0440-447D-9E64-C61A92E94800}']
    function ExecuteInsert(const SQL: String; const OutputFields: TArray<String>): IDatabaseCursor;
    function OpenCursor(const SQL: String): IDatabaseCursor;
    function StartTransaction: IDatabaseTransaction;

    procedure ExecuteDirect(const SQL: String);
  end;

  IDatabaseDialect = interface
    ['{C4BE54B1-7C38-41FA-9F2B-7AEAACA07775}']
    function CreateManipulator(const Manager: TManager): IMetadataManipulator;
  end;

  TDatabaseDialect = class(TInterfacedObject)
  protected

  end;

  TLazyFactory = class(TInterfacedObject)
  private
    FKeyValue: TValue;
    FLazyField: TField;
    FManager: TManager;

    function GetKey: TValue;
  public
    constructor Create(const Manager: TManager; const LazyField: TField; const KeyValue: TValue);
  end;

  TLazySingleClassFactory = class(TLazyFactory, ILazyLoader)
  private
    function LoadValue: TValue;
  end;

  TLazyManyValueClassFactory = class(TLazyFactory, ILazyLoader)
  private
    function LoadValue: TValue;
  end;

  TClassLoader = class
  private
    FAccess: IQueryBuilderAccess;
    FCursor: IDatabaseCursor;
    FLoadedObjects: TDictionary<String, TObject>;
    FMainLoadedObject: TDictionary<TObject, Boolean>;

    function CreateObject(const Table: TTable; const FieldIndexStart: Integer; var AObject: TObject): Boolean;
    function GetFieldValueFromCursor(const Index: Integer): Variant;
    function LoadClass(var CurrentObject: TObject): Boolean;

    procedure LoadObject(const CurrentObject: TObject; const Join: TQueryBuilderJoin; var FieldIndexStart: Integer; const NewObject: Boolean);
  public
    constructor Create(const Access: IQueryBuilderAccess);

    destructor Destroy; override;

    function Load<T: class>: T;
    function LoadAll<T: class>: TArray<T>;
  end;

  IQueryBuilderCommand = interface
    function GetSQL: String;
  end;

  IQueryBuilderAccess = interface
    ['{33A7B162-42DF-4BC6-BDA4-AB35D00050F0}']
    function GetBuilder: TQueryBuilder;
    function GetCache: ICache;
    function GetConnection: IDatabaseConnection;
    function GetField(const QueryField: TQueryBuilderFieldAlias): String; overload;
    function GetField(const QueryField: TQueryBuilderFieldAlias; var Field: TField): String; overload;
    function GetFields: TArray<TFieldAlias>;
    function GetIdention(Count: Integer; const MinimalIdention: Boolean = True): String;
    function GetJoin: TQueryBuilderJoin;
    function GetLineBreak: String;
    function GetManager: TManager;
    function GetTable: TTable;
    function OpenCursor: IDatabaseCursor;

    property Builder: TQueryBuilder read GetBuilder;
    property Cache: ICache read GetCache;
    property Connection: IDatabaseConnection read GetConnection;
    property Fields: TArray<TFieldAlias> read GetFields;
    property Join: TQueryBuilderJoin read GetJoin;
    property LineBreak: String read GetLineBreak;
    property Table: TTable read GetTable;
  end;

  TQueryBuilder = class(TNoRefCountObject, IQueryBuilderAccess)
  private
    FCache: ICache;
    FConnection: IDatabaseConnection;
    FDestroyObjects: TDictionary<TObject, Boolean>;
    FFieldList: TQueryBuilderAllFields;
    FFrom: TQueryBuilderFrom;
    FManager: TManager;
    FOpen: TQueryBuilderOpen;
    FOptions: TBuilderOptions;
    FProcessedObjects: TDictionary<TObject, TObject>;
    FSelect: IQueryBuilderCommand;
    FTable: TTable;
    FUpdateObject: TList<TObject>;
    FWhere: IQueryBuilderCommand;

    function BuildPrimaryKeyFilter(const Table: TTable; const AObject: TObject): String;
    function CheckValueIsEmpty(const Value: TValue): Boolean;
    function ExecuteInTrasaction(const Func: TFunc<TObject>): TObject;
    function FindJoinInheritedLink(const Join: TQueryBuilderJoin): TQueryBuilderJoin;
    function FindJoinLink(const Join: TQueryBuilderJoin; const FieldName: String): TQueryBuilderJoin;
    function GetBuilder: TQueryBuilder;
    function GetCache: ICache;
    function GetConnection: IDatabaseConnection;
    function GetField(const QueryField: TQueryBuilderFieldAlias): String; overload;
    function GetField(const QueryField: TQueryBuilderFieldAlias; var Field: TField): String; overload;
    function GetFields: TArray<TFieldAlias>;
    function GetIdention(Count: Integer; const MinimalIdention: Boolean = True): String;
    function GetJoin: TQueryBuilderJoin;
    function GetLineBreak: String;
    function GetManager: TManager;
    function GetTable: TTable;
    function InsertObject(const AObject: TValue): TObject;
    function OpenCursor: IDatabaseCursor;
    function SaveObject(const AObject: TValue): TObject;
    function UpdateObject(const AObject: TValue): TObject;

    procedure AddObjectToDestruction(const CurrentObject, ForeignObject: TObject);
    procedure SaveForeignKeys(const Table: TTable; const ForeignObject: TObject);
    procedure SaveManyValueAssociations(const Table: TTable; const CurrentObject, ForeignObject: TObject);
  public
    constructor Create(const Connection: IDatabaseConnection; const Cache: ICache);

    destructor Destroy; override;

    function GetSQL: String;
    function Insert<T: class>(const AObject: T): T;
    function Save<T: class>(const AObject: T): T;
    function Select: TQueryBuilderSelect;
    function Update<T: class>(const AObject: T): T;

    procedure Delete(const AObject: TObject);

    property Connection: IDatabaseConnection read FConnection;
    property Options: TBuilderOptions read FOptions write FOptions;
  end;

  TQueryBuilderFrom = class
  private
    FAccess: IQueryBuilderAccess;
    FJoin: TQueryBuilderJoin;
    FRecursivityLevel: Word;
    FTableIndexJoin: Integer;

    function BuildJoinSQL: String;
    function CreateJoin(const CurrentJoin: TQueryBuilderJoin; const Table: TTable; const Field, LeftField, RightField: TField; const IsInheritedLink, MakeLink: Boolean): TQueryBuilderJoin;
    function CreateJoinForeignKey(const CurrentJoin: TQueryBuilderJoin; const ForeignKey: TForeignKey; const MakeLink: Boolean): TQueryBuilderJoin;
    function CreateJoinManyValueAssociation(const CurrentJoin: TQueryBuilderJoin; const ManyValueAssociation: TManyValueAssociation; const MakeLink: Boolean): TQueryBuilderJoin;
    function CreateJoinTable(const Table: TTable): TQueryBuilderJoin;
    function MakeJoinSQL(const Join: TQueryBuilderJoin; const JoinInfo: String): String;

    procedure BuildJoin;
    procedure MakeJoin(const Join: TQueryBuilderJoin; RecursionControl: TDictionary<TTable, Word>; const ManyValueAssociationToIgnore: TManyValueAssociation);
  public
    constructor Create(const Access: IQueryBuilderAccess; const RecursivityLevel: Word);

    destructor Destroy; override;

    function From<T: class>: TQueryBuilderWhere<T>; overload;
    function From(Table: TTable): TQueryBuilderWhere<TObject>; overload;
    function GetSQL: String;

    property Join: TQueryBuilderJoin read FJoin;
  end;

  TQueryBuilderJoin = class
  private
    FAlias: String;
    FField: TField;
    FFilterLinks: TArray<TQueryBuilderJoin>;
    FIsInheritedLink: Boolean;
    FLeftField: TField;
    FLinks: TArray<TQueryBuilderJoin>;
    FRightField: TField;
    FTable: TTable;

    function GetAllLinks: TArray<TQueryBuilderJoin>;
  public
    constructor Create(const Table: TTable); overload;
    constructor Create(const Table: TTable; const Field, LeftField, RightField: TField; const IsInheritedLink: Boolean); overload;

    destructor Destroy; override;

    property Alias: String read FAlias write FAlias;
    property AllLinks: TArray<TQueryBuilderJoin> read GetAllLinks;
    property Field: TField read FField write FField;
    property FilterLinks: TArray<TQueryBuilderJoin> read FFilterLinks write FFilterLinks;
    property IsInheritedLink: Boolean read FIsInheritedLink write FIsInheritedLink;
    property LeftField: TField read FLeftField write FLeftField;
    property Links: TArray<TQueryBuilderJoin> read FLinks write FLinks;
    property RightField: TField read FRightField write FRightField;
    property Table: TTable read FTable write FTable;
  end;

  TQueryBuilderOpen = class

  end;

  TQueryBuilderOpen<T: class> = class(TQueryBuilderOpen)
  private
    FLoader: TClassLoader;
  public
    constructor Create(const Access: IQueryBuilderAccess);

    destructor Destroy; override;

    function All: TArray<T>;
    function One: T;
  end;

  TQueryBuilderAllFields = class
  private
    FAccess: IQueryBuilderAccess;

    function GetAllFields(const Join: TQueryBuilderJoin): TArray<TFieldAlias>;
    function GetFields: TArray<TFieldAlias>;
  public
    constructor Create(const Access: IQueryBuilderAccess);
  end;

  TQueryBuilderSelect = class(TInterfacedObject, IQueryBuilderCommand)
  private
    FAccess: IQueryBuilderAccess;
    FFirstRecords: Cardinal;
    FRecursivityLevel: Word;

    function GetFieldsWithAlias: String;
  public
    constructor Create(const Access: IQueryBuilderAccess);

    destructor Destroy; override;

    function All: TQueryBuilderFrom;
    function GetSQL: String;
    function RecursivityLevel(const Level: Word): TQueryBuilderSelect;
    function First(const Total: Cardinal): TQueryBuilderSelect;

    property FirstRecords: Cardinal read FFirstRecords;
    property RecursivityLevelValue: Word read FRecursivityLevel;
  end;

  TQueryBuilderFieldAlias = class
  private
    FFieldNames: TArray<String>;
    FFieldName: String;
  public
    constructor Create(const FieldName: String);

    property FieldName: String read FFieldName;
    property FieldNames: TArray<String> read FFieldNames;
  end;

  TQueryBuilderOrderByField = class(TQueryBuilderFieldAlias)
  private
    FAscending: Boolean;
  public
    constructor Create(const FieldName: String; const Ascending: Boolean);

    property Ascending: Boolean read FAscending;
  end;

  TQueryBuilderComparisonOperator = (qbcoNone, qbcoEqual, qbcoNotEqual, qbcoGreaterThan, qbcoGreaterThanOrEqual, qbcoLessThan, qbcoLessThanOrEqual, qbcoNull, qbcoNotNull,
    qbcoBetween, qbcoLike);

  TQueryBuilderLogicalOperator = (qloNone, qloAnd, qloOr);

  TQueryBuilderComparison = class
  private
    FComparison: TQueryBuilderComparisonOperator;
    FField: TQueryBuilderFieldAlias;
    FLeft: TQueryBuilderComparison;
    FLogical: TQueryBuilderLogicalOperator;
    FRight: TQueryBuilderComparison;
    FValue: TValue;

    function GetLeft: TQueryBuilderComparison;
    function GetRight: TQueryBuilderComparison;
  public
    destructor Destroy; override;

    property Comparison: TQueryBuilderComparisonOperator read FComparison write FComparison;
    property Field: TQueryBuilderFieldAlias read FField write FField;
    property Left: TQueryBuilderComparison read GetLeft write FLeft;
    property Logical: TQueryBuilderLogicalOperator read FLogical write FLogical;
    property Right: TQueryBuilderComparison read GetRight write FRight;
    property Value: TValue read FValue write FValue;
  end;

  TQueryBuilderComparisonHelper = record
  private
    class procedure MakeComparison(const Comparison: TQueryBuilderComparisonOperator; const Left, Right: TQueryBuilderComparisonHelper; var Result: TQueryBuilderComparisonHelper); overload; static;
    class procedure MakeComparison(const Comparison: TQueryBuilderComparisonOperator; const Left: TQueryBuilderComparisonHelper; const Right: TValue; var Result: TQueryBuilderComparisonHelper); overload; static;
  public
    Comparison: TQueryBuilderComparison;

    function Between<T>(const ValueStart, ValueEnd: T): TQueryBuilderComparisonHelper;
    function IsLoaded: Boolean;
    function Like(const Value: String): TQueryBuilderComparisonHelper;

    class function Create: TQueryBuilderComparisonHelper; static;

    class operator BitwiseAnd(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator BitwiseOr(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator Equal(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator Equal(const Left: TQueryBuilderComparisonHelper; const Value: TNullEnumerator): TQueryBuilderComparisonHelper;
    class operator Equal(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
    class operator Equal(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
    class operator GreaterThan(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator GreaterThan(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
    class operator GreaterThan(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
    class operator GreaterThanOrEqual(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator GreaterThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
    class operator GreaterThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
    class operator LessThan(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator LessThan(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
    class operator LessThan(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
    class operator LessThanOrEqual(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator LessThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
    class operator LessThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
    class operator NotEqual(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
    class operator NotEqual(const Left: TQueryBuilderComparisonHelper; const Value: TNullEnumerator): TQueryBuilderComparisonHelper;
    class operator NotEqual(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
    class operator NotEqual(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
  end;

  TQueryBuilderOrderBy = class
  private
    FAccess: IQueryBuilderAccess;
    FFields: TArray<TQueryBuilderOrderByField>;

    constructor Create(const Access: IQueryBuilderAccess);
  public
    destructor Destroy; override;

    function Field(const FieldName: String; const Ascending: Boolean = True): TQueryBuilderOrderBy;
    function GetSQL: String;

    property Fields: TArray<TQueryBuilderOrderByField> read FFields;
  end;

  TQueryBuilderOrderBy<T: class> = class(TQueryBuilderOrderBy)
  public
    function Field(const FieldName: String; const Ascending: Boolean = True): TQueryBuilderOrderBy<T>;
    function Open: TQueryBuilderOpen<T>;
  end;

  TQueryBuilderWhere = class(TInterfacedObject, IQueryBuilderCommand)
  private
    FAccess: IQueryBuilderAccess;
    FFilter: String;
    FOrderBy: TQueryBuilderOrderBy;

    function GetFieldValue(const Comparison: TQueryBuilderComparison; const Field: TField): String;
    function GetValueToCompare(const Comparison: TQueryBuilderComparison; const Field: TField): String;
    function MakeComparison(const Comparison: TQueryBuilderComparison): String;
    function MakeFilter(const Value: TQueryBuilderComparison): String;
    function MakeLogical(const Logical: TQueryBuilderComparison): String;

    procedure BuildFilter(const Value: TQueryBuilderComparisonHelper);
  public
    constructor Create(const Access: IQueryBuilderAccess);

    destructor Destroy; override;

    function GetSQL: String;
    function Where(const Condition: TQueryBuilderComparisonHelper): TQueryBuilderWhere;
  end;

  TQueryBuilderWhere<T: class> = class(TQueryBuilderWhere)
  public
    function Open: TQueryBuilderOpen<T>;
    function OrderBy: TQueryBuilderOrderBy<T>;
    function Where(const Condition: TQueryBuilderComparisonHelper): TQueryBuilderWhere<T>;
  end;

  IMetadataManipulator = interface
    ['{7ED4F3DE-1C13-4CF3-AE3C-B51386EA271F}']
    function GetAllRecords(const Table: TTable): TArray<TObject>;
    function GetAutoGeneratedValue(const DefaultConstraint: TDefaultConstraint): String;
    function GetDefaultConstraintName(const Field: TField): String;

    procedure CreateDefaultConstraint(const Field: TField);
    procedure CreateField(const Field: TField);
    procedure CreateForeignKey(const ForeignKey: TForeignKey);
    procedure CreateIndex(const Index: TIndex);
    procedure CreateSequence(const Sequence: TSequence);
    procedure CreateTable(const Table: TTable);
    procedure CreateTempField(const Field: TField);
    procedure DropDefaultConstraint(const Field: TDatabaseField);
    procedure DropField(const Field: TDatabaseField);
    procedure DropForeignKey(const ForeignKey: TDatabaseForeignKey);
    procedure DropIndex(const Index: TDatabaseIndex);
    procedure DropSequence(const Sequence: TDatabaseSequence);
    procedure DropTable(const Table: TDatabaseTable);
    procedure InsertRecord(const Value: TObject);
    procedure LoadSchema(const Schema: TDatabaseSchema);
    procedure RenameField(const Current, Destiny: TField);
    procedure UpdateField(const SourceField, DestinyField: TField);
    procedure UpdateRecord(const Value: TObject);
  end;

  TDatabaseSchema = class
  private
    FSequences: TList<TDatabaseSequence>;
    FTables: TList<TDatabaseTable>;

    function GetSequence(const Name: String): TDatabaseSequence;
    function GetTable(const Name: String): TDatabaseTable;
  public
    constructor Create;

    destructor Destroy; override;

    property Sequence[const Name: String]: TDatabaseSequence read GetSequence;
    property Sequences: TList<TDatabaseSequence> read FSequences;
    property Table[const Name: String]: TDatabaseTable read GetTable;
    property Tables: TList<TDatabaseTable> read FTables;
  end;

  TDatabaseNamedObject = class
  private
    FName: String;
  public
    constructor Create(const Name: String);

    class function FindObject<T: TDatabaseNamedObject>(const List: TList<T>; const Name: String): T;

    property Name: String read FName write FName;
  end;

  TDatabaseTableObject = class(TDatabaseNamedObject)
  private
    FTable: TDatabaseTable;
  public
    constructor Create(const Table: TDatabaseTable; const Name: String);

    property Table: TDatabaseTable read FTable;
  end;

  TDatabaseTable = class(TDatabaseNamedObject)
  private
    FFields: TList<TDatabaseField>;
    FForeignKeys: TList<TDatabaseForeignKey>;
    FIndexes: TList<TDatabaseIndex>;
    FSchema: TDatabaseSchema;

    function GetField(const Name: String): TDatabaseField;
    function GetForeignKey(const Name: String): TDatabaseForeignKey;
    function GetIndex(const Name: String): TDatabaseIndex;
  public
    constructor Create(const Schema: TDatabaseSchema; const Name: String);

    destructor Destroy; override;

    property Field[const Name: String]: TDatabaseField read GetField;
    property Fields: TList<TDatabaseField> read FFields;
    property ForeignKey[const Name: String]: TDatabaseForeignKey read GetForeignKey;
    property ForeignKeys: TList<TDatabaseForeignKey> read FForeignKeys;
    property Index[const Name: String]: TDatabaseIndex read GetIndex;
    property Indexes: TList<TDatabaseIndex> read FIndexes;
    property Schema: TDatabaseSchema read FSchema write FSchema;
  end;

  TDatabaseField = class(TDatabaseTableObject)
  private
    FCheck: TDatabaseCheckConstraint;
    FCollation: String;
    FDefaultConstraint: TDatabaseDefaultConstraint;
    FFieldType: TTypeKind;
    FRequired: Boolean;
    FScale: Word;
    FSize: Word;
    FSpecialType: TDatabaseSpecialType;
  public
    constructor Create(const Table: TDatabaseTable; const Name: String);

    destructor Destroy; override;

    property Check: TDatabaseCheckConstraint read FCheck write FCheck;
    property Collation: String read FCollation write FCollation;
    property DefaultConstraint: TDatabaseDefaultConstraint read FDefaultConstraint write FDefaultConstraint;
    property FieldType: TTypeKind read FFieldType write FFieldType;
    property Required: Boolean read FRequired write FRequired;
    property Scale: Word read FScale write FScale;
    property Size: Word read FSize write FSize;
    property SpecialType: TDatabaseSpecialType read FSpecialType write FSpecialType;
  end;

  TDatabaseIndex = class(TDatabaseTableObject)
  private
    FFields: TArray<TDatabaseField>;
    FPrimaryKey: Boolean;
    FUnique: Boolean;
  public
    constructor Create(const Table: TDatabaseTable; const Name: String);

    property Fields: TArray<TDatabaseField> read FFields write FFields;
    property PrimaryKey: Boolean read FPrimaryKey write FPrimaryKey;
    property Unique: Boolean read FUnique write FUnique;
  end;

  TDatabaseForeignKey = class(TDatabaseTableObject)
  private
    FFields: TArray<TDatabaseField>;
    FFieldsReference: TArray<TDatabaseField>;
    FReferenceTable: TDatabaseTable;
  public
    constructor Create(const ParentTable: TDatabaseTable; const Name: String; const ReferenceTable: TDatabaseTable);

    property Fields: TArray<TDatabaseField> read FFields write FFields;
    property FieldsReference: TArray<TDatabaseField> read FFieldsReference write FFieldsReference;
    property ReferenceTable: TDatabaseTable read FReferenceTable write FReferenceTable;
  end;

  TDatabaseDefaultConstraint = class(TDatabaseNamedObject)
  private
    FValue: String;
  public
    constructor Create(const Field: TDatabaseField; const Name, Value: String);

    property Value: String read FValue write FValue;
  end;

  TDatabaseCheckConstraint = class(TDatabaseNamedObject)
  private
    FCheck: String;
  public
    constructor Create(const Field: TDatabaseField; const Name, Check: String);

    property Check: String read FCheck write FCheck;
  end;

  TDatabaseSequence = class(TDatabaseNamedObject)
  end;

  TDatabaseMetadataUpdate = class
  private
    FManager: TManager;
    FMetadataManipulator: IMetadataManipulator;

    function CheckSameFields(const Fields: TArray<TField>; const DatabaseFields: TArray<TDatabaseField>): Boolean;
    function FieldInTheList(const DatabaseField: TDatabaseField; const DatabaseFields: TArray<TDatabaseField>): Boolean;

    procedure CheckChangingTheList<T>(const List: TList<T>; const Func: TFunc<T, Boolean>);
    procedure CreateField(const Field: TField);
    procedure DropField(const DatabaseField: TDatabaseField);
    procedure DropForeignKey(const DatabaseForeignKey: TDatabaseForeignKey);
    procedure DropIndex(const DatabaseIndex: TDatabaseIndex);
    procedure DropTable(const DatabaseTable: TDatabaseTable);
    procedure RecreateField(const Field: TField; const DatabaseField: TDatabaseField);
  public
    constructor Create(const Manager: TManager);

    procedure UpdateDatabase;
  end;

  TMetadataManipulator = class(TInterfacedObject)
  private
    FManager: TManager;

    function GetFieldList(const Fields: TArray<TField>): String;
    function GetPrimaryKey(const Table: TTable; const Separator: String): String;
    function GetPrimaryKeyIndex(const Table: TTable): TIndex;
  protected
    function GetAllRecords(const Table: TTable): TArray<TObject>;
    function GetAutoGeneratedValue(const DefaultConstraint: TDefaultConstraint): String; virtual; abstract;
    function GetDefaultConstraintName(const Field: TField): String;
    function GetFieldCollation(const Field: TField): String;
    function GetFieldDefaultConstraint(const Field: TField): String;
    function GetFieldTypeDefinition(Field: TField): String;
    function GetFieldType(const Field: TField): String; virtual; abstract;
    function GetSpecialFieldType(const Field: TField): String; virtual; abstract;
    function OpenCursor(const SQL: String): IDatabaseCursor;

    procedure CreateDefaultConstraint(const Field: TField);
    procedure CreateField(const Field: TField);
    procedure CreateForeignKey(const ForeignKey: TForeignKey);
    procedure CreateIndex(const Index: TIndex);
    procedure CreateSequence(const Sequence: TSequence);
    procedure CreateTable(const Table: TTable);
    procedure CreateTempField(const Field: TField);
    procedure DropDefaultConstraint(const Field: TDatabaseField);
    procedure DropField(const Field: TDatabaseField);
    procedure DropIndex(const Index: TDatabaseIndex);
    procedure DropForeignKey(const ForeignKey: TDatabaseForeignKey);
    procedure DropSequence(const Sequence: TDatabaseSequence);
    procedure DropTable(const Table: TDatabaseTable);
    procedure ExecuteDirect(const SQL: String);
    procedure InsertRecord(const Value: TObject);
    procedure RenameField(const SourceField, DestinyField: TField);
    procedure UpdateField(const SourceField, DestinyField: TField);
    procedure UpdateRecord(const Value: TObject);
  public
    constructor Create(const Manager: TManager);

    function GetFieldDefinition(const Field: TField): String;
  end;

  TManager = class
  private
    FConnection: IDatabaseConnection;
    FDialect: IDatabaseDialect;
    FMapper: TMapper;
  public
    constructor Create(const Connection: IDatabaseConnection; const Dialect: IDatabaseDialect);

    destructor Destroy; override;

    function OpenCursor(const SQL: String): IDatabaseCursor;
    function Select: TQueryBuilderSelect;

    procedure Delete(const &Object: TObject);
    procedure Insert(const &Object: TObject);
    procedure Save(const &Object: TObject);
    procedure Update(const &Object: TObject);
    procedure UpdateDatabaseSchema;

    property Mapper: TMapper read FMapper;
  end;

function Field(const Name: String): TQueryBuilderComparisonHelper;

implementation

uses System.Variants, Persisto.Rtti.Helper;

function CreateLoader(const Manager: TManager; const LazyField: TField; const KeyValue: TValue): ILazyLoader;
begin
  if KeyValue.IsEmpty then
    Result := nil
  else if LazyField.IsManyValueAssociation then
    Result := TLazyManyValueClassFactory.Create(Manager, LazyField, KeyValue)
  else
    Result := TLazySingleClassFactory.Create(Manager, LazyField, KeyValue);
end;

function Field(const Name: String): TQueryBuilderComparisonHelper;
begin
  Result.Comparison := TQueryBuilderComparison.Create;
  Result.Comparison.Field := TQueryBuilderFieldAlias.Create(Name);
end;

{ TCache }

function TCache.Add(const Key: String; const Value: TObject): TObject;
begin
  Result := Value;

  FReadWriteControl.BeginWrite;

  try
    FValues.Add(Key, Value);
  finally
    FReadWriteControl.EndWrite;
  end;
end;

constructor TCache.Create;
begin
  inherited;

  FReadWriteControl := TMultiReadExclusiveWriteSynchronizer.Create;
  FValues := TObjectDictionary<String, TObject>.Create([doOwnsValues]);
end;

constructor TCache.Create(const ChangeManager: IChangeManager);
begin
  Create;

  FChangeManger := ChangeManager;
end;

destructor TCache.Destroy;
begin
  FValues.Free;

  inherited;
end;

class function TCache.GenerateKey(RttiType: TRttiType; const KeyValue: TValue): String;
begin
  Result := GenerateKey(RttiType.QualifiedName, KeyValue);
end;

class function TCache.GenerateKey(const KeyName: String; const KeyValue: TValue): String;
begin
  Result := Format('%s.%s', [KeyName, KeyValue.GetAsString]);
end;

class function TCache.GenerateKey(AClass: TClass; const KeyValue: TValue): String;
begin
  Result := GenerateKey(AClass.QualifiedClassName, KeyValue);
end;

function TCache.Get(const Key: String; var Value: TObject): Boolean;
begin
  FReadWriteControl.BeginRead;

  try
    Result := FValues.TryGetValue(Key, Value);
  finally
    FReadWriteControl.EndRead;
  end;
end;

function TCache.GetChangeManager: IChangeManager;
begin
  if not Assigned(FChangeManger) then
    FChangeManger := TChangeManager.Create;

  Result := FChangeManger;
end;

function SortFieldFunction(const Left, Right: TField): Integer;

  function FieldPriority(const Field: TField): Integer;
  begin
    if Field.InPrimaryKey then
      Result := 1
    else if Field.IsLazy then
      Result := 2
    else if Field.IsForeignKey then
      Result := 3
    else if Field.IsManyValueAssociation then
      Result := 4
    else
      Result := 2;
  end;

begin
  Result := FieldPriority(Left) - FieldPriority(Right);

  if Result = 0 then
    Result := CompareStr(Left.DatabaseName, Right.DatabaseName);
end;

function CreateFieldComparer: IComparer<TField>;
begin
  Result := TDelegatedComparer<TField>.Create(SortFieldFunction);
end;

{ TMapper }

procedure TMapper.AddDefaultRecord(const Value: TObject);
begin
  FindTable(Value.ClassType).DefaultRecords.Add(Value);
end;

procedure TMapper.AddTableForeignKey(const Table: TTable; const Field: TField; const ClassInfoType: TRttiInstanceType);
begin
  var ParentTable := LoadTable(ClassInfoType);

  if Assigned(ParentTable) then
    AddTableForeignKey(Table, Field, ParentTable, False)
  else
    raise EForeignKeyToSingleTableInheritanceTable.Create(ClassInfoType);
end;

procedure TMapper.AddTableForeignKey(const Table: TTable; const Field: TField; const ForeignTable: TTable; const IsInheritedLink: Boolean);

  function GetForeignKeyName: String;
  begin
    if not GetNameAttribute<ForeignKeyNameAttribute>(Field.PropertyInfo, Result) then
      Result := Format('FK_%s_%s_%s', [Table.DatabaseName, ForeignTable.DatabaseName, Field.DatabaseName]);
  end;

begin
  if Assigned(ForeignTable.PrimaryKey) then
  begin
    var
    ForeignKey := TForeignKey.Create(Table);
    ForeignKey.FDatabaseName := GetForeignKeyName;
    ForeignKey.FField := Field;
    ForeignKey.FIsInheritedLink := IsInheritedLink;
    ForeignKey.FParentTable := ForeignTable;

    Field.FForeignKey := ForeignKey;
    Table.FForeignKeys := Table.FForeignKeys + [ForeignKey];

    LoadFieldTypeInfo(Field);
  end
  else
    raise EClassWithoutPrimaryKeyDefined.Create(ForeignTable);
end;

function TMapper.CheckAttribute<T>(const TypeInfo: TRttiType): Boolean;
begin
  Result := False;

  for var TypeToCompare in TypeInfo.GetAttributes do
    if TypeToCompare is T then
      Exit(True);
end;

constructor TMapper.Create;
begin
  inherited;

  FContext := TRttiContext.Create;
  FDefaultRecords := TDictionary<String, TObject>.Create;
  FDelayLoadTable := TList<TTable>.Create;
  FSequences := TObjectDictionary<String, TSequence>.Create([doOwnsValues]);
  FTables := TObjectDictionary<TRttiInstanceType, TTable>.Create([doOwnsValues]);
end;

function TMapper.CreateIndex(const Table: TTable; const Name: String): TIndex;
begin
  Result := TIndex.Create(Table);
  Result.DatabaseName := Name;

  Table.FIndexes := Table.Indexes + [Result];
end;

function TMapper.CreateSequence(const Name: String): TSequence;
begin
  if FSequences.ContainsKey(Name) then
    raise ESequenceAlreadyExists.Create(Name)
  else
  begin
    Result := TSequence.Create(Name);

    FSequences.Add(Name, Result);
  end;
end;

destructor TMapper.Destroy;
begin
  FContext.Free;

  FDefaultRecords.Free;

  FDelayLoadTable.Free;

  FSequences.Free;

  FTables.Free;

  inherited;
end;

function TMapper.FindTable(const ClassInfo: PTypeInfo): TTable;
begin
  if not TryFindTable(ClassInfo, Result) then
    raise ETableNotFound.Create(ClassInfo.TypeData.ClassType);
end;

function TMapper.FindSequence(const Name: String): TSequence;
begin
  Result := nil;

  FSequences.TryGetValue(Name, Result);
end;

function TMapper.FindTable(const ClassInfo: TClass): TTable;
begin
  Result := FindTable(ClassInfo.ClassInfo);
end;

function TMapper.GetFieldDatabaseName(const Field: TField): String;
begin
  if not GetNameAttribute<FieldNameAttribute>(Field.PropertyInfo, Result) then
  begin
    Result := Field.Name;

    if Field.IsForeignKey then
      Result := 'Id' + Result;
  end;
end;

function TMapper.GetManyValuAssociationLinkName(const Field: TField): String;
begin
  if not GetNameAttribute<ManyValueAssociationLinkNameAttribute>(Field.PropertyInfo, Result) then
    Result := Field.Table.Name;
end;

function TMapper.GetNameAttribute<T>(const TypeInfo: TRttiNamedObject; var Name: String): Boolean;
begin
  var Attribute := TypeInfo.GetAttribute<T>;
  Result := Assigned(Attribute);

  if Result then
    Name := Attribute.Name;
end;

function TMapper.GetPrimaryKeyPropertyName(const TypeInfo: TRttiInstanceType): String;
begin
  var Attribute := TypeInfo.GetAttribute<PrimaryKeyAttribute>;

  if Assigned(Attribute) then
    Result := Attribute.Name
  else
    Result := 'Id';
end;

function TMapper.GetSequences: TArray<TSequence>;
begin
  Result := FSequences.Values.ToArray;
end;

function TMapper.GetTable(const TypeInfo: PTypeInfo): TTable;
begin

end;

function TMapper.GetTable(const ClassInfo: TClass): TTable;
begin

end;

function TMapper.GetTableDatabaseName(const Table: TTable): String;
begin
  if not GetNameAttribute<TableNameAttribute>(Table.ClassTypeInfo, Result) then
    Result := Table.Name;
end;

function TMapper.GetTables: TArray<TTable>;
begin
  Result := FTables.Values.ToArray;
end;

function TMapper.IsSingleTableInheritance(const RttiType: TRttiInstanceType): Boolean;
begin
  Result := RttiType.GetAttribute<SingleTableInheritanceAttribute> <> nil;
end;

procedure TMapper.LoadAll;
begin
  LoadAll(nil);
end;

procedure TMapper.LoadAll(const Schema: TArray<TClass>);
begin
  var SchemaList := EmptyStr;

  FSequences.Clear;

  FTables.Clear;

  for var AClass in Schema do
    SchemaList := Format('%s;%s;', [SchemaList, AClass.UnitName]);

  for var TypeInfo in FContext.GetTypes do
    if CheckAttribute<EntityAttribute>(TypeInfo) and (SchemaList.IsEmpty or (SchemaList.IndexOf(Format(';%s;', [TypeInfo.AsInstance.DeclaringUnitName])) > -1)) then
      LoadTable(TypeInfo.AsInstance);

  LoadDelayedTables;
end;

function TMapper.LoadClass(const ClassInfo: TClass): TTable;
begin
  Result := LoadTable(FContext.GetType(ClassInfo).AsInstance);

  LoadDelayedTables;
end;

procedure TMapper.LoadDefaultConstraint(const Field: TField);
begin
  var Attribute := Field.PropertyInfo.GetAttribute<TAutoGeneratedAttribute>;

  if Assigned(Attribute) then
  begin
    Field.FDefaultConstraint := TDefaultConstraint.Create;
    Field.FDefaultConstraint.AutoGeneratedType := Attribute.&Type;

    if Attribute is SequenceAttribute then
      Field.FDefaultConstraint.Sequence := CreateSequence(SequenceAttribute(Attribute).Name);

    if Attribute is FixedValueAttribute then
      Field.FDefaultConstraint.FixedValue := FixedValueAttribute(Attribute).Value;
  end;
end;

procedure TMapper.LoadDelayedTables;
begin
  while FDelayLoadTable.Count > 0 do
    LoadTableManyValueAssociations(FDelayLoadTable.ExtractAt(0));
end;

procedure TMapper.LoadFieldInfo(const Table: TTable; const PropertyInfo: TRttiInstanceProperty; const Field: TField);
begin
  Field.FFieldType := PropertyInfo.PropertyType;
  Field.FIsReadOnly := not PropertyInfo.IsWritable;
  Field.FName := PropertyInfo.Name;
  Field.FPropertyInfo := PropertyInfo;
  Field.FTable := Table;
  Table.FFields := Table.FFields + [Field];

  Field.FIsLazy := TLazyManipulator.IsLazyLoading(Field.PropertyInfo);
  Field.FIsNullable := TNullableManipulator.IsNullable(Field.PropertyInfo);

  if Field.FIsNullable then
    Field.FFieldType := TNullableManipulator.GetNullableType(Field.PropertyInfo)
  else if Field.IsLazy then
    Field.FFieldType := TLazyManipulator.GetLazyLoadingType(Field.PropertyInfo);

  Field.FIsForeignKey := Field.FieldType.IsInstance;
  Field.FIsManyValueAssociation := Field.FieldType.IsArray;
  Field.FRequired := PropertyInfo.HasAttribute<RequiredAttribute> or not Field.FIsNullable and not(Field.FieldType.TypeKind in [tkClass]);

  Field.FDatabaseName := GetFieldDatabaseName(Field);
  Field.FIsJoinLink := Field.IsForeignKey or Field.IsManyValueAssociation;

  if not Field.IsForeignKey then
    LoadFieldTypeInfo(Field);

  LoadDefaultConstraint(Field);
end;

procedure TMapper.LoadFieldTypeInfo(const Field: TField);
begin
  if Field.IsForeignKey then
  begin
    Field.FFieldType := Field.ForeignKey.ParentTable.PrimaryKey.FieldType;
    Field.FScale := Field.ForeignKey.ParentTable.PrimaryKey.Scale;
    Field.FSize := Field.ForeignKey.ParentTable.PrimaryKey.Size;
    Field.FSpecialType := Field.ForeignKey.ParentTable.PrimaryKey.SpecialType;
  end
  else
  begin
    var FieldInfo := Field.PropertyInfo.GetAttribute<FieldInfoAttribute>;

    if Assigned(FieldInfo) then
    begin
      Field.FScale := FieldInfo.Scale;
      Field.FSize := FieldInfo.Size;
      Field.FSpecialType := FieldInfo.SpecialType;
    end
    else if Field.FieldType.Handle = TypeInfo(TDate) then
      Field.FSpecialType := stDate
    else if Field.FieldType.Handle = TypeInfo(TDateTime) then
      Field.FSpecialType := stDateTime
    else if Field.FieldType.Handle = TypeInfo(TTime) then
      Field.FSpecialType := stTime
    else if Field.FieldType.Handle = TypeInfo(Boolean) then
      Field.FSpecialType := stBoolean;
  end;
end;

function TMapper.LoadTable(const TypeInfo: TRttiInstanceType): TTable;
begin
  if not TryFindTable(TypeInfo.Handle, Result) and not IsSingleTableInheritance(TypeInfo) then
  begin
    Result := TTable.Create(TypeInfo);
    Result.FMapper := Self;
    Result.FName := TypeInfo.Name.Substring(1);

    Result.FDatabaseName := GetTableDatabaseName(Result);

    FTables.Add(TypeInfo, Result);

    FDelayLoadTable.Add(Result);

    LoadTableInfo(TypeInfo, Result);
  end;
end;

procedure TMapper.LoadTableFields(const TypeInfo: TRttiInstanceType; const Table: TTable);
begin
  var PrimaryKeyFieldName := GetPrimaryKeyPropertyName(TypeInfo);

  for var Prop in TypeInfo.GetDeclaredProperties do
    if Prop.Visibility = mvPublished then
      LoadFieldInfo(Table, Prop as TRttiInstanceProperty, TField.Create(Table));

  if Table.Fields = nil then
    raise ETableWithoutPublishedFields.Create(Table);

  for var Field in Table.Fields do
    if Field.Name = PrimaryKeyFieldName then
    begin
      Field.FInPrimaryKey := True;

      if not Assigned(Table.FPrimaryKey) then
      begin
        var PrimaryKeyIndex := CreateIndex(Table, Format('PK_%s', [Table.DatabaseName]));
        PrimaryKeyIndex.Fields := [Field];
        PrimaryKeyIndex.PrimaryKey := True;
        PrimaryKeyIndex.Unique := True;
      end;

      Table.FPrimaryKey := Field;

      if Field.FIsNullable then
        raise EClassWithPrimaryKeyNullable.Create(Table);
    end;
end;

procedure TMapper.LoadTableForeignKeys(const Table: TTable);
begin
  for var Field in Table.Fields do
    if Field.IsForeignKey then
      AddTableForeignKey(Table, Field, Field.FieldType.AsInstance);
end;

procedure TMapper.LoadTableIndexes(const TypeInfo: TRttiInstanceType; const Table: TTable);
begin
  for var Attribute in TypeInfo.GetAttributes do
    if Attribute is IndexAttribute then
    begin
      var IndexInfo := IndexAttribute(Attribute);

      var Index := CreateIndex(Table, IndexInfo.Name);
      Index.Unique := Attribute is UniqueKeyAttribute;

      for var FieldName in IndexInfo.Fields.Split([';']) do
      begin
        var Field: TField;

        if not Table.FindField(FieldName, Field) then
          raise EFieldIndexNotFound.Create(Table, FieldName);

        Index.Fields := Index.Fields + [Field];
      end;
    end;
end;

procedure TMapper.LoadTableInfo(const TypeInfo: TRttiInstanceType; const Table: TTable);
begin
  var BaseClassInfo := TypeInfo.BaseType;
  var IsSingleTableInheritance := IsSingleTableInheritance(BaseClassInfo);

  if not IsSingleTableInheritance and (BaseClassInfo.MetaclassType <> TObject) then
    Table.FBaseTable := LoadTable(BaseClassInfo);

  LoadTableFields(TypeInfo, Table);

  if IsSingleTableInheritance then
    while Assigned(BaseClassInfo) do
    begin
      LoadTableFields(BaseClassInfo, Table);

      BaseClassInfo := BaseClassInfo.BaseType;
    end;

  if Assigned(Table.BaseTable) then
  begin
    var Field := TField.Create(Table);

    LoadFieldInfo(Table, Table.BaseTable.PrimaryKey.PropertyInfo, Field);

    Table.FPrimaryKey := Table.BaseTable.PrimaryKey;

    AddTableForeignKey(Table, Field, Table.BaseTable, True);
  end;

  TArray.Sort<TField>(Table.FFields, CreateFieldComparer);

  LoadTableForeignKeys(Table);

  LoadTableIndexes(TypeInfo, Table);
end;

procedure TMapper.LoadTableManyValueAssociations(const Table: TTable);
begin
  for var Field in Table.Fields do
    if Field.IsManyValueAssociation then
    begin
      var ChildTable := LoadTable(Field.FieldType.AsArray.ElementType.AsInstance);
      var LinkName := GetManyValuAssociationLinkName(Field);

      for var ForeignKey in ChildTable.ForeignKeys do
        if (ForeignKey.ParentTable = Table) and (ForeignKey.Field.Name = LinkName) then
          if Assigned(ChildTable.PrimaryKey) then
            Field.FManyValueAssociation := TManyValueAssociation.Create(Field, ChildTable, ForeignKey)
          else
            raise EChildTableMustHasToHaveAPrimaryKey.Create(ChildTable);

      if Assigned(Field.ManyValueAssociation) then
        Table.FManyValueAssociations := Table.FManyValueAssociations + [Field.ManyValueAssociation]
      else
        raise EManyValueAssociationLinkError.Create(Table, ChildTable);
    end;
end;

function TMapper.TryFindTable(const ClassInfo: PTypeInfo; var Table: TTable): Boolean;
begin
  Result := FTables.TryGetValue(FContext.GetType(ClassInfo).AsInstance, Table);
end;

{ TTable }

constructor TTable.Create(TypeInfo: TRttiInstanceType);
begin
  inherited Create;

  FClassTypeInfo := TypeInfo;
end;

destructor TTable.Destroy;
begin
  for var Field in Fields do
    Field.Free;

  for var ForeignKey in ForeignKeys do
    ForeignKey.Free;

  for var ManyValueAssociation in ManyValueAssociations do
    ManyValueAssociation.Free;

  for var Index in Indexes do
    Index.Free;

  FDefaultRecords.Free;

  inherited;
end;

function TTable.FindField(const FieldName: String; var Field: TField): Boolean;
begin
  Field := nil;
  Result := False;

  for var TableField in Fields do
    if TableField.Name = FieldName then
    begin
      Field := TableField;

      Exit(True);
    end;
end;

function TTable.GetCacheKey(const PrimaryKeyValue: Variant): String;
begin
  var KeyValue: TValue;

  if Assigned(PrimaryKey) then
    KeyValue := PrimaryKey.ConvertVariant(PrimaryKeyValue)
  else
    KeyValue := EmptyStr;

  Result := TCache.GenerateKey(ClassTypeInfo, KeyValue);
end;

function TTable.GetDefaultRecords: TList<TObject>;
begin
  if not Assigned(FDefaultRecords) then
    FDefaultRecords := TList<TObject>.Create;

  Result := FDefaultRecords;
end;

function TTable.GetField(const FieldName: String): TField;
begin
  FindField(FieldName, Result);
end;

function TTable.GetCacheKey(const Instance: TObject): String;
begin
  var KeyValue: TValue;

  if Assigned(PrimaryKey) then
    KeyValue := PrimaryKey.GetValue(Instance)
  else
    KeyValue := EmptyStr;

  Result := TCache.GenerateKey(Instance.ClassType, KeyValue);
end;

{ TFieldAlias }

constructor TFieldAlias.Create(TableAlias: String; Field: TField);
begin
  FField := Field;
  FTableAlias := TableAlias;
end;

{ TManyValueAssociation }

constructor TManyValueAssociation.Create(const Field: TField; const ChildTable: TTable; const ForeignKey: TForeignKey);
begin
  inherited Create;

  FChildTable := ChildTable;
  FField := Field;
  FForeignKey := ForeignKey;
  FForeignKey.FManyValueAssociation := Self;
end;

{ TField }

function TField.ConvertVariant(const Value: Variant): TValue;
begin
  if VarIsNull(Value) then
    Result := TValue.Empty
  else if FieldType is TRttiEnumerationType then
    Result := TValue.FromOrdinal(FieldType.Handle, Value)
  else if FieldType.Handle = System.TypeInfo(TGUID) then
    Result := TValue.From(StringToGuid(Value))
  else
    Result := TValue.FromVariant(Value);
end;

destructor TField.Destroy;
begin
  FDefaultConstraint.Free;

  inherited;
end;

function TField.GetAsString(const Value: TValue): String;
begin
  if Value.IsEmpty then
    Result := 'null'
  else
    case SpecialType of
      stDate:
        Result := QuotedStr(DateToStr(Value.AsExtended, TValue.FormatSettings));
      stDateTime:
        begin
          DateTimeToString(Result, 'dddddd', Value.AsExtended, TValue.FormatSettings);

          Result := QuotedStr(Result);
        end;
      stTime:
        Result := QuotedStr(TimeToStr(Value.AsExtended, TValue.FormatSettings))
    else
      case Value.Kind of
        tkChar, tkLString, tkRecord, tkString, tkUString, tkWChar, tkWString:
          Result := QuotedStr(Value.GetAsString);

        tkClass:
          Result := ForeignKey.ParentTable.PrimaryKey.GetAsString(Value.AsObject);

        tkFloat:
          Result := FloatToStr(Value.AsExtended, TValue.FormatSettings);

        tkEnumeration, tkInteger, tkInt64:
          Result := Value.GetAsString;

      else
        raise Exception.Create('Type not mapped!');
      end;
    end;
end;

function TField.GetAutoGenerated: Boolean;
begin
  Result := Assigned(FDefaultConstraint);
end;

function TField.GetAsString(const Instance: TObject): String;
begin
  Result := GetAsString(GetValue(Instance));
end;

function TField.GetPropertyValue(const Instance: TObject): TValue;
begin
  Result := PropertyInfo.GetValue(Instance);
end;

function TField.GetValue(const Instance: TObject): TValue;
begin
  HasValue(Instance, Result);
end;

function TField.HasValue(const Instance: TObject; var Value: TValue): Boolean;
begin
  if IsLazy then
  begin
    var Manipulator := TLazyManipulator.GetManipulator(Instance, PropertyInfo);

    if Manipulator.HasValue then
      if Manipulator.Loaded then
        Value := Manipulator.Value
      else
        Value := Manipulator.Key
    else
      Value := TValue.Empty;
  end
  else if FIsNullable then
    Value := TNullableManipulator.GetManipulator(Instance, PropertyInfo).Value
  else
    Value := GetPropertyValue(Instance);

  Result := not Value.IsEmpty;
end;

procedure TField.SetValue(const Instance: TObject; const Value: TValue);
begin
  if FIsNullable then
    TNullableManipulator.GetManipulator(Instance, PropertyInfo).Value := Value
  else if IsLazy then
    TLazyManipulator.GetManipulator(Instance, PropertyInfo).Value := Value
  else
    PropertyInfo.SetValue(Instance, Value);
end;

procedure TField.SetValue(const Instance: TObject; const Value: Variant);
begin
  SetValue(Instance, ConvertVariant(Value));
end;

{ EManyValueAssociationLinkError }

constructor EManyValueAssociationLinkError.Create(ParentTable, ChildTable: TTable);
begin
  inherited CreateFmt('The link between %s and %s can''t be maded. Check if it exists, as the same name of the parent table or has the attribute defining the name of the link!',
    [ParentTable.ClassTypeInfo.Name, ChildTable.ClassTypeInfo.Name]);
end;

{ EClassWithPrimaryKeyNullable }

constructor EClassWithPrimaryKeyNullable.Create(Table: TTable);
begin
  inherited CreateFmt('The primary key of the class %s is nullable, it''s not accepted!', [Table.ClassTypeInfo.Name]);
end;

{ EInvalidEnumeratorName }

constructor EInvalidEnumeratorName.Create(Enumeration: TRttiEnumerationType; EnumeratorValue: String);
begin
  inherited CreateFmt('Enumerator name ''%s'' is invalid to the enumeration ''%s''', [EnumeratorValue, Enumeration.Name]);
end;

{ ETableNotFound }

constructor ETableNotFound.Create(TheClass: TClass);
begin
  inherited CreateFmt('The class %s not found!', [TheClass.ClassName])
end;

{ EClassWithoutPrimaryKeyDefined }

constructor EClassWithoutPrimaryKeyDefined.Create(Table: TTable);
begin
  inherited CreateFmt('You must define a primary key for class %s!', [Table.ClassTypeInfo.Name])
end;

{ EChildTableMustHasToHaveAPrimaryKey }

constructor EChildTableMustHasToHaveAPrimaryKey.Create(ChildTable: TTable);
begin
  inherited CreateFmt('The child table %s hasn''t a primary key, check the implementation!', [ChildTable.ClassTypeInfo.Name]);
end;

{ EForeignKeyToSingleTableInheritanceTable }

constructor EForeignKeyToSingleTableInheritanceTable.Create(ParentTable: TRttiInstanceType);
begin
  inherited CreateFmt('The parent table %s can''t be single inheritence table, check the implementation!', [ParentTable.Name]);
end;

{ EFieldIndexNotFound }

constructor EFieldIndexNotFound.Create(const Table: TTable; const FieldName: String);
begin
  inherited CreateFmt('Field "%s" not found in the table "%s"!', [Table.Name, FieldName]);
end;

{ TTableObject }

constructor TTableObject.Create(const Table: TTable);
begin
  inherited Create;

  FTable := Table;
end;

{ TSequence }

constructor TSequence.Create(const Name: String);
begin
  inherited Create;

  FName := Name;
end;

{ ESequenceAlreadyExists }

constructor ESequenceAlreadyExists.Create(const SequenceName: String);
begin
  inherited CreateFmt('The sequence [%s] already exists!', [SequenceName]);
end;

{ ETableWithoutPublishedFields }

constructor ETableWithoutPublishedFields.Create(const Table: TTable);
begin
  inherited CreateFmt('The class %s hasn''t published field, check yout implementation!', [Table.Name]);
end;

{ TChangeManager }

procedure TChangeManager.AddInstance(Table: TTable; const Instance: TObject);
begin
  var Changes := Changes[Instance];

  repeat
    for var Field in Table.Fields do
      if not Field.IsManyValueAssociation then
        Changes[Field] := Field.GetAsString(Instance);

    Table := Table.BaseTable;
  until not Assigned(Table);
end;

constructor TChangeManager.Create;
begin
  FChanges := TObjectDictionary<TObject, TChange>.Create([doOwnsValues]);
end;

destructor TChangeManager.Destroy;
begin
  FChanges.Free;

  inherited;
end;

function TChangeManager.GetChanges(const Instance: TObject): TChange;
begin
  MonitorEnter(FChanges);
  try
    if not FChanges.TryGetValue(Instance, Result) then
    begin
      Result := TChange.Create;

      FChanges.Add(Instance, Result);
    end;
  finally
    MonitorExit(FChanges);
  end;
end;

{ TChange }

constructor TChange.Create;
begin
  FChange := TDictionary<TField, String>.Create;
end;

destructor TChange.Destroy;
begin
  FChange.Free;

  inherited;
end;

function TChange.GetChange(const Field: TField): String;
begin
  Result := FChange[Field];
end;

function TChange.GetChangeCount: Integer;
begin
  Result := FChange.Count;
end;

procedure TChange.SetChange(const Field: TField; const Value: String);
begin
  MonitorEnter(FChange);

  try
    FChange.AddOrSetValue(Field, Value);
  finally
    MonitorExit(FChange);
  end;
end;

{ TLazySingleClassFactory }

function TLazySingleClassFactory.LoadValue: TValue;
begin
  var Table := FLazyField.ForeignKey.ParentTable;

  Result := FManager.Select.All.From(Table).Where(Field(Table.PrimaryKey.Name) = FKeyValue).Open.One;
end;

{ TLazyManyValueClassFactory }

function TLazyManyValueClassFactory.LoadValue: TValue;
begin
  var ManyValue := FLazyField.ManyValueAssociation;
  var Value := FManager.Select.All.From(ManyValue.ChildTable).Where(Field(ManyValue.ForeignKey.Field.Name) = FKeyValue).Open.All;

  TValue.Make(@Value, FLazyField.FieldType.Handle, Result);
end;

{ TLazyFactory }

constructor TLazyFactory.Create(const Manager: TManager; const LazyField: TField; const KeyValue: TValue);
begin
  inherited Create;

  FManager := Manager;
  FKeyValue := KeyValue;
  FLazyField := LazyField;
end;

function TLazyFactory.GetKey: TValue;
begin
  Result := FKeyValue;
end;

{ TClassLoader }

constructor TClassLoader.Create(const Access: IQueryBuilderAccess);
begin
  inherited Create;

  FAccess := Access;
  FLoadedObjects := TDictionary<String, TObject>.Create;
  FMainLoadedObject := TDictionary<TObject, Boolean>.Create;
end;

function TClassLoader.CreateObject(const Table: TTable; const FieldIndexStart: Integer; var AObject: TObject): Boolean;
begin
  var PrimaryKeyValue := GetFieldValueFromCursor(FieldIndexStart);

  var CacheKey := Table.GetCacheKey(PrimaryKeyValue);

  Result := (not Assigned(Table.PrimaryKey) or not VarIsNull(PrimaryKeyValue)) and not FLoadedObjects.TryGetValue(CacheKey, AObject);

  if Result then
  begin
    if not FAccess.Cache.Get(CacheKey, AObject) then
    begin
      AObject := Table.ClassTypeInfo.MetaclassType.Create;

      FAccess.Cache.Add(CacheKey, AObject);
    end;

    FLoadedObjects.Add(CacheKey, AObject);
  end;
end;

destructor TClassLoader.Destroy;
begin
  FMainLoadedObject.Free;

  FLoadedObjects.Free;

  inherited;
end;

function TClassLoader.GetFieldValueFromCursor(const Index: Integer): Variant;
begin
  Result := FCursor.GetFieldValue(Index);
end;

function TClassLoader.Load<T>: T;
begin
  var All := LoadAll<T>;
  Result := nil;

  if Assigned(All) then
    Result := All[0];
end;

function TClassLoader.LoadAll<T>: TArray<T>;
begin
  FCursor := FAccess.OpenCursor;
  Result := nil;
  var TheObject: TObject := nil;

  FMainLoadedObject.Clear;

  FLoadedObjects.Clear;

  while FCursor.Next do
    if LoadClass(TheObject) then
      Result := Result + [TheObject as T];
end;

function TClassLoader.LoadClass(var CurrentObject: TObject): Boolean;
begin
  var FieldIndex := 0;

  CreateObject(FAccess.Table, FieldIndex, CurrentObject);

  Result := not FMainLoadedObject.ContainsKey(CurrentObject);

  if Result then
    FMainLoadedObject.Add(CurrentObject, False);

  LoadObject(CurrentObject, FAccess.Join, FieldIndex, Result);
end;

procedure TClassLoader.LoadObject(const CurrentObject: TObject; const Join: TQueryBuilderJoin; var FieldIndexStart: Integer; const NewObject: Boolean);
var
  Field: TField;

  FieldValue: TValue;

  procedure AddItemToParentArray(const ParentObject: TObject; ParentField: TField; const Item: TObject);
  begin
    var ArrayValue := ParentField.GetValue(ParentObject);

    if ArrayValue.IsEmpty or NewObject then
      TValue.Make(nil, ParentField.FieldType.Handle, ArrayValue);

    var ArrayLength := ArrayValue.ArrayLength;

    ArrayValue.ArrayLength := Succ(ArrayLength);

    ArrayValue.ArrayElement[ArrayLength] := Item;

    ParentField.SetValue(ParentObject, ArrayValue);
  end;

begin
  for Field in Join.Table.Fields do
    if not Field.IsJoinLink or Field.IsLazy then
    begin
      if Assigned(CurrentObject) then
      begin
        if not Field.IsLazy or Field.IsForeignKey then
          FieldValue := Field.ConvertVariant(GetFieldValueFromCursor(FieldIndexStart))
        else
          FieldValue := Field.Table.PrimaryKey.GetValue(CurrentObject);

        if Field.IsLazy then
        begin
          var Manipulator := TLazyManipulator.GetManipulator(CurrentObject, Field.PropertyInfo);
          Manipulator.Loader := CreateLoader(FAccess.GetManager, Field, FieldValue)
        end
        else
          Field.SetValue(CurrentObject, FieldValue);
      end;

      if not Field.IsManyValueAssociation then
        Inc(FieldIndexStart);
    end;

  for var Link in Join.Links do
  begin
    var ForeignKeyObject: TObject := nil;
    var NewChildObject: Boolean;

    if Link.IsInheritedLink then
    begin
      ForeignKeyObject := CurrentObject;
      NewChildObject := NewObject;
    end
    else
      NewChildObject := CreateObject(Link.Table, FieldIndexStart, ForeignKeyObject);

    if NewObject and Link.Field.IsForeignKey then
    begin
      Link.Field.SetValue(CurrentObject, ForeignKeyObject);

      if Assigned(ForeignKeyObject) and Assigned(Link.Field.ForeignKey.ManyValueAssociation) then
        AddItemToParentArray(ForeignKeyObject, Link.Field.ForeignKey.ManyValueAssociation.Field, CurrentObject);
    end
    else if NewChildObject and Link.Field.IsManyValueAssociation then
    begin
      Link.RightField.SetValue(ForeignKeyObject, CurrentObject);

      AddItemToParentArray(CurrentObject, Link.Field, ForeignKeyObject);
    end;

    LoadObject(ForeignKeyObject, Link, FieldIndexStart, NewChildObject);
  end;

  if NewObject then
    FAccess.Cache.ChangeManager.AddInstance(Join.Table, CurrentObject);
end;

{ TQueryBuilder }

procedure TQueryBuilder.AddObjectToDestruction(const CurrentObject, ForeignObject: TObject);
begin
  if (boDestroyForeignObjects in Options) and (CurrentObject <> ForeignObject) then
    FDestroyObjects.AddOrSetValue(ForeignObject, False);
end;

function TQueryBuilder.BuildPrimaryKeyFilter(const Table: TTable; const AObject: TObject): String;
begin
  FSelect := nil;
  FTable := Table;
  Result := EmptyStr;

  if Assigned(Table.PrimaryKey) then
  begin
    var Condition := Field(Table.PrimaryKey.DatabaseName) = Table.PrimaryKey.GetValue(AObject);
    var Where := TQueryBuilderWhere.Create(Self);

    Result := Where.Where(Condition).GetSQL;
  end;
end;

function TQueryBuilder.CheckValueIsEmpty(const Value: TValue): Boolean;
begin
  case Value.Kind of
    tkInteger,
    tkInt64: Result := Value.AsInt64 = 0;

    tkEnumeration: Result := Value.AsOrdinal = 0;

    tkFloat: Result := Value.AsExtended = 0;

    tkString,
    tkLString,
    tkWString,
    tkUString: Result := Value.AsString = EmptyStr;
    else Result := Value.IsEmpty;
  end;
end;

constructor TQueryBuilder.Create(const Connection: IDatabaseConnection; const Cache: ICache);
begin
  inherited Create;

  FCache := Cache;
  FConnection := Connection;
  FDestroyObjects := TObjectDictionary<TObject, Boolean>.Create([doOwnsKeys]);
  FProcessedObjects := TDictionary<TObject, TObject>.Create;
  FUpdateObject := TList<TObject>.Create;
end;

procedure TQueryBuilder.Delete(const AObject: TObject);
begin
  ExecuteInTrasaction(
    function: TObject
    begin
      Result := nil;
      var Table := FManager.Mapper.GetTable(AObject.ClassInfo);

      FConnection.ExecuteDirect(Format('delete from %s%s', [Table.DatabaseName, BuildPrimaryKeyFilter(Table, AObject)]));
    end);
end;

destructor TQueryBuilder.Destroy;
begin
  FDestroyObjects.Free;

  FProcessedObjects.Free;

  FUpdateObject.Free;

  inherited;
end;

function TQueryBuilder.ExecuteInTrasaction(const Func: TFunc<TObject>): TObject;
begin
  var Transaction := Connection.StartTransaction;

  try
    Result := Func;

    while FUpdateObject.Count > 0 do
      SaveObject(FUpdateObject.ExtractAt(0));

    Transaction.Commit;

    FDestroyObjects.Clear;

    FProcessedObjects.Clear;
  except
    Transaction.Rollback;

    raise;
  end;
end;

function TQueryBuilder.FindJoinInheritedLink(const Join: TQueryBuilderJoin): TQueryBuilderJoin;
begin
  Result := nil;

  for var Link in Join.Links do
    if Link.IsInheritedLink then
      Exit(Link);
end;

function TQueryBuilder.FindJoinLink(const Join: TQueryBuilderJoin; const FieldName: String): TQueryBuilderJoin;
begin
  Result := nil;

  if Assigned(Join) then
  begin
    var Field: TField;

    for var Link in Join.AllLinks do
      if Link.Field.Name = FieldName then
        Exit(Link);

    if Join.Table.FindField(FieldName, Field) then
      if Field.IsManyValueAssociation then
        raise ECantFilterManyValueAssociation.Create(Field)
      else
        Exit(FFrom.CreateJoinForeignKey(Join, Field.ForeignKey, False));

    Result := FindJoinLink(FindJoinInheritedLink(Join), FieldName);
  end;
end;

function TQueryBuilder.InsertObject(const AObject: TValue): TObject;
begin
  var FieldValue: TValue;
  var FieldStringValue: String;
  var OutputFieldList: TArray<TField> := nil;
  var OutputFieldNameList: TArray<String> := nil;
  Result := AObject.AsObject;
  var SQL := '(%s)values(%s)';
  var Table := FManager.Mapper.GetTable(AObject.TypeInfo);

  var Changes := FCache.ChangeManager.Changes[Result];

  FProcessedObjects.TryAdd(Result, nil);

  SaveForeignKeys(Table, Result);

  for var Field in Table.Fields do
  begin
    var HasValue := Field.HasValue(Result, FieldValue);

    if Field.AutoGenerated and CheckValueIsEmpty(FieldValue) then
    begin
      OutputFieldList := OutputFieldList + [Field];
      OutputFieldNameList := OutputFieldNameList + [Field.DatabaseName];
    end
    else if not HasValue then
      Changes[Field] := 'null'
    else if not Field.IsManyValueAssociation and not Field.IsReadOnly then
    begin
      if Field.IsForeignKey and FieldValue.IsObject then
      begin
        var ForeignKeyObject := FProcessedObjects[FieldValue.AsObject];

        if not Assigned(ForeignKeyObject) then
        begin
          Changes[Field] := 'null';

          FUpdateObject.Add(Result);

          Continue;
        end
        else
        begin
          FieldValue := ForeignKeyObject;

          Field.SetValue(Result, FieldValue);
        end;
      end;

      if not Field.IsForeignKey or not FieldValue.IsObject or Field.ForeignKey.ParentTable.PrimaryKey.HasValue(FieldValue.AsObject, FieldValue) then
      begin
        FieldStringValue := Field.GetAsString(FieldValue);

        Changes[Field] := FieldStringValue;
        SQL := Format(SQL, [Field.DatabaseName + '%2:s%0:s', FieldStringValue + '%2:s%1:s', ',']);
      end;
    end;
  end;

  var Cursor := FConnection.ExecuteInsert(Format('insert into %s%s', [Table.DatabaseName, Format(SQL, ['', '', '', ''])]), OutputFieldNameList);

  if Cursor.Next then
    for var A := Low(OutputFieldList) to High(OutputFieldList) do
    begin
      OutputFieldList[A].SetValue(Result, Cursor.GetFieldValue(A));

      Changes[OutputFieldList[A]] := OutputFieldList[A].GetAsString(Result);
    end;

  if Table.ClassTypeInfo.MetaclassType = Result.ClassType then
    FCache.Add(Table.GetCacheKey(Result), Result);

  FProcessedObjects[Result] := Result;

  SaveManyValueAssociations(Table, Result, Result);
end;

function TQueryBuilder.OpenCursor: IDatabaseCursor;
begin
  Result := FConnection.OpenCursor(GetSQL);
end;

function TQueryBuilder.Insert<T>(const AObject: T): T;
begin
  Result := ExecuteInTrasaction(
    function: TObject
    begin
      Result := InsertObject(AObject);
    end) as T;
end;

function TQueryBuilder.GetBuilder: TQueryBuilder;
begin
  Result := Self;
end;

function TQueryBuilder.GetCache: ICache;
begin
  Result := FCache;
end;

function TQueryBuilder.GetConnection: IDatabaseConnection;
begin
  Result := FConnection;
end;

function TQueryBuilder.GetField(const QueryField: TQueryBuilderFieldAlias): String;
var
  Field: TField;

begin
  Result := GetField(QueryField, Field);
end;

function TQueryBuilder.GetField(const QueryField: TQueryBuilderFieldAlias; var Field: TField): String;
begin
  var CurrentJoin := GetJoin;
  Field := nil;
  var FieldName := QueryField.FieldNames[High(QueryField.FieldNames)];
  var FieldNames := QueryField.FieldNames;
  Result := EmptyStr;

  SetLength(FieldNames, High(QueryField.FieldNames));

  if Assigned(CurrentJoin) then
  begin
    for var LinkName in FieldNames do
    begin
      CurrentJoin := FindJoinLink(CurrentJoin, LinkName);

      if not Assigned(CurrentJoin) then
        raise EFieldNotFoundInTable.Create(LinkName);
    end;

    while Assigned(CurrentJoin) and not CurrentJoin.Table.FindField(FieldName, Field) do
      CurrentJoin := FindJoinInheritedLink(CurrentJoin);

    if Assigned(Field) then
      Exit(Format('%s.%s', [CurrentJoin.Alias, Field.DatabaseName]));
  end
  else if FTable.FindField(FieldName, Field) then
    Exit(Field.DatabaseName);

  raise EFieldNotFoundInTable.Create(FieldName);
end;

function TQueryBuilder.GetFields: TArray<TFieldAlias>;
begin
  Result := FFieldList.GetFields;
end;

function TQueryBuilder.GetIdention(Count: Integer; const MinimalIdention: Boolean): String;
begin
  if not (boBeautifyQuery in Options) then
    if MinimalIdention then
      Count := 1
    else
      Count := 0;

  Result := StringOfChar(' ', Count)
end;

function TQueryBuilder.GetJoin: TQueryBuilderJoin;
begin
  if Assigned(FFrom) then
    Result := FFrom.FJoin
  else
    Result := nil;
end;

function TQueryBuilder.GetLineBreak: String;
begin
  if boBeautifyQuery in Options then
    Result := #13#10
  else
    Result := EmptyStr;
end;

function TQueryBuilder.GetManager: TManager;
begin
  Result := nil;
end;

function TQueryBuilder.GetSQL: String;
begin
  if Assigned(FSelect) then
    if Assigned(FFrom) then
      Result := GetIdention(3, False) + 'select ' + FSelect.GetSQL + GetIdention(5) + 'from ' + FFrom.GetSQL
    else
      raise ECommandWithoutFromClause.Create
  else
    Result := EmptyStr;
end;

function TQueryBuilder.GetTable: TTable;
begin
  Result := FTable;
end;

function TQueryBuilder.Save<T>(const AObject: T): T;
begin
  Result := ExecuteInTrasaction(
    function: TObject
    begin
      Result := SaveObject(AObject);
    end) as T;
end;

procedure TQueryBuilder.SaveForeignKeys(const Table: TTable; const ForeignObject: TObject);
begin
  var FieldValue: TValue;

  for var ForeignKey in Table.ForeignKeys do
    if ForeignKey.IsInheritedLink then
      SaveObject(TValue.From(ForeignObject).Cast(ForeignObject.ClassParent.ClassInfo, False))
    else if ForeignKey.Field.HasValue(ForeignObject, FieldValue) and FieldValue.IsObject and not FProcessedObjects.ContainsKey(FieldValue.AsObject) then
      SaveObject(FieldValue);
end;

procedure TQueryBuilder.SaveManyValueAssociations(const Table: TTable; const CurrentObject, ForeignObject: TObject);
begin
  var CurrentArray, ForeignArrayValue: TValue;

  for var ManyValue in Table.ManyValueAssociations do
    if ManyValue.Field.HasValue(ForeignObject, ForeignArrayValue) and ForeignArrayValue.IsArray then
    begin
      CurrentArray := ForeignArrayValue;

      for var A := 0 to Pred(ForeignArrayValue.ArrayLength) do
      begin
        var ForeignArrayItem := ForeignArrayValue.ArrayElement[A];

        ManyValue.ForeignKey.Field.SetValue(ForeignArrayItem.AsObject, ForeignObject);

        var SavedObject := SaveObject(ForeignArrayItem);

        ManyValue.ForeignKey.Field.SetValue(SavedObject, CurrentObject);

        CurrentArray.SetArrayElement(A, SavedObject);
      end;

      ManyValue.Field.SetValue(CurrentObject, CurrentArray);
    end;
end;

function TQueryBuilder.SaveObject(const AObject: TValue): TObject;

  function CheckPrimaryKeyIsEmpty: Boolean;
  begin
    var Table := FManager.Mapper.FindTable(AObject.TypeInfo);

    Result := Assigned(Table.PrimaryKey) and CheckValueIsEmpty(Table.PrimaryKey.GetValue(AObject.AsObject));
  end;

begin
  if CheckPrimaryKeyIsEmpty then
    Result := InsertObject(AObject)
  else
    Result := UpdateObject(AObject);
end;

function TQueryBuilder.Select: TQueryBuilderSelect;
begin
  Result := TQueryBuilderSelect.Create(Self);

  FSelect := Result;
end;

function TQueryBuilder.Update<T>(const AObject: T): T;
begin
  Result := ExecuteInTrasaction(
    function: TObject
    begin
      Result := UpdateObject(AObject);
    end) as T;
end;

function TQueryBuilder.UpdateObject(const AObject: TValue): TObject;
begin
  var ForeignFieldStringValue: String;
  var ForeignFieldValue: TValue;
  var ForeignObject := AObject.AsObject;
  var SQL := EmptyStr;
  var Table := FManager.Mapper.FindTable(AObject.TypeInfo);

  var CacheKey := Table.GetCacheKey(ForeignObject);

  if FCache.Get(CacheKey, Result) then
  begin
    var Changes := FCache.ChangeManager.Changes[Result];

    FProcessedObjects.AddOrSetValue(ForeignObject, Result);

    SaveForeignKeys(Table, ForeignObject);

    for var Field in Table.Fields do
      if not Field.InPrimaryKey and not Field.IsManyValueAssociation and not Field.IsReadOnly then
      begin
        if Field.HasValue(ForeignObject, ForeignFieldValue) and Field.IsForeignKey then
          if ForeignFieldValue.IsObject then
            ForeignFieldValue := FProcessedObjects[ForeignFieldValue.AsObject]
          else
            Continue;

        ForeignFieldStringValue := Field.GetAsString(ForeignFieldValue);

        if ForeignFieldStringValue <> Changes[Field] then
        begin
          Changes[Field] := ForeignFieldStringValue;

          if not SQL.IsEmpty then
            SQL := SQL + ',';

          SQL := SQL + Format('%s=%s', [Field.DatabaseName, ForeignFieldStringValue]);

          Field.SetValue(Result, ForeignFieldValue);
        end;
      end;

    if not SQL.IsEmpty then
      FConnection.ExecuteDirect(Format('update %s set %s%s', [Table.DatabaseName, SQL, BuildPrimaryKeyFilter(Table, ForeignObject)]));

    SaveManyValueAssociations(Table, Result, ForeignObject);

    AddObjectToDestruction(Result, ForeignObject);
  end
  else
    raise EObjectReferenceWasNotFound.Create;
end;

{ TQueryBuilderFrom }

procedure TQueryBuilderFrom.BuildJoin;
begin
  FTableIndexJoin := 1;
  var RecursionControl := TDictionary<TTable, Word>.Create;

  MakeJoin(FJoin, RecursionControl, nil);

  RecursionControl.Free;
end;

function TQueryBuilderFrom.BuildJoinSQL: String;
begin
  Result := Format('%s %s', [FJoin.Table.DatabaseName, FJoin.Alias]) + MakeJoinSQL(FJoin, FJoin.Table.Name);
end;

constructor TQueryBuilderFrom.Create(const Access: IQueryBuilderAccess; const RecursivityLevel: Word);
begin
  inherited Create;

  FAccess := Access;
  FAccess.Builder.FFrom := Self;
  FRecursivityLevel := RecursivityLevel;
end;

function TQueryBuilderFrom.CreateJoin(const CurrentJoin: TQueryBuilderJoin; const Table: TTable; const Field, LeftField, RightField: TField;
  const IsInheritedLink, MakeLink: Boolean): TQueryBuilderJoin;
begin
  Result := TQueryBuilderJoin.Create(Table, Field, LeftField, RightField, IsInheritedLink);

  Inc(FTableIndexJoin);

  Result.Alias := 'T' + FTableIndexJoin.ToString;

  if Assigned(CurrentJoin) then
    if MakeLink then
      CurrentJoin.Links := CurrentJoin.Links + [Result]
    else
      CurrentJoin.FilterLinks := CurrentJoin.FilterLinks + [Result];
end;

function TQueryBuilderFrom.CreateJoinForeignKey(const CurrentJoin: TQueryBuilderJoin; const ForeignKey: TForeignKey; const MakeLink: Boolean): TQueryBuilderJoin;
begin
  Result := CreateJoin(CurrentJoin, ForeignKey.ParentTable, ForeignKey.Field, ForeignKey.Field, ForeignKey.ParentTable.PrimaryKey, ForeignKey.IsInheritedLink, MakeLink);
end;

function TQueryBuilderFrom.CreateJoinManyValueAssociation(const CurrentJoin: TQueryBuilderJoin; const ManyValueAssociation: TManyValueAssociation;
  const MakeLink: Boolean): TQueryBuilderJoin;
begin
  Result := CreateJoin(CurrentJoin, ManyValueAssociation.ChildTable, ManyValueAssociation.Field, Join.Table.PrimaryKey, ManyValueAssociation.ForeignKey.Field, False, MakeLink);
end;

function TQueryBuilderFrom.CreateJoinTable(const Table: TTable): TQueryBuilderJoin;
begin
  Result := CreateJoin(nil, Table, nil, nil, nil, False, False);
end;

destructor TQueryBuilderFrom.Destroy;
begin
  FJoin.Free;

  inherited;
end;

function TQueryBuilderFrom.From(Table: TTable): TQueryBuilderWhere<TObject>;
begin
  FAccess.Builder.FTable := Table;
  FJoin := CreateJoinTable(Table);
  Result := TQueryBuilderWhere<TObject>.Create(FAccess);

  FAccess.Builder.FWhere := Result;

  BuildJoin;
end;

function TQueryBuilderFrom.From<T>: TQueryBuilderWhere<T>;
begin
  Result := TQueryBuilderWhere<T>(From(FAccess.GetManager.Mapper.FindTable(T)));
end;

function TQueryBuilderFrom.GetSQL: String;
begin
  Result := BuildJoinSQL;

  if Assigned(FAccess.Builder.FWhere) then
    Result := Result + FAccess.Builder.FWhere.GetSQL;
end;

procedure TQueryBuilderFrom.MakeJoin(const Join: TQueryBuilderJoin; RecursionControl: TDictionary<TTable, Word>; const ManyValueAssociationToIgnore: TManyValueAssociation);
begin
  for var ForeignKey in Join.Table.ForeignKeys do
    if not ForeignKey.Field.IsLazy and (not Assigned(ManyValueAssociationToIgnore) or (ForeignKey <> ManyValueAssociationToIgnore.ForeignKey)) then
    begin
      if not RecursionControl.ContainsKey(ForeignKey.ParentTable) then
        RecursionControl.Add(ForeignKey.ParentTable, 0);

      if RecursionControl[ForeignKey.ParentTable] < FRecursivityLevel then
      begin
        RecursionControl[ForeignKey.ParentTable] := RecursionControl[ForeignKey.ParentTable] + 1;

        MakeJoin(CreateJoinForeignKey(Join, ForeignKey, True), RecursionControl, ManyValueAssociationToIgnore);

        RecursionControl[ForeignKey.ParentTable] := RecursionControl[ForeignKey.ParentTable] - 1;
      end;
    end;

  for var ManyValueAssociation in Join.Table.ManyValueAssociations do
    if not ManyValueAssociation.Field.IsLazy and (not Assigned(ManyValueAssociationToIgnore) or (ManyValueAssociation <> ManyValueAssociationToIgnore)) then
      MakeJoin(CreateJoinManyValueAssociation(Join, ManyValueAssociation, True), RecursionControl, ManyValueAssociation);
end;

function TQueryBuilderFrom.MakeJoinSQL(const Join: TQueryBuilderJoin; const JoinInfo: String): String;

  function MakeJoinInfo(const Link: TQueryBuilderJoin): String;
  begin
    if boJoinMapping in FAccess.Builder.Options then
      Result := Format(FAccess.GetIdention(7, False) + '/* %s -> %s (%s) */' + FAccess.LineBreak, [JoinInfo, Link.Table.Name, Link.LeftField.Name])
    else
      Result := FAccess.GetIdention(0);
  end;

begin
  Result := FAccess.LineBreak;

  for var Link in Join.AllLinks do
    Result := Result + Format('%sleft join %s %s%son %s.%s=%s.%s', [MakeJoinInfo(Link), Link.Table.DatabaseName, Link.Alias, FAccess.LineBreak + FAccess.GetIdention(7),
      Join.Alias, Link.LeftField.DatabaseName, Link.Alias, Link.RightField.DatabaseName]) + MakeJoinSQL(Link, JoinInfo + ' -> ' + Link.Table.Name);
end;

{ TQueryBuilderSelect }

function TQueryBuilderSelect.All: TQueryBuilderFrom;
begin
  FAccess.Builder.FFieldList := TQueryBuilderAllFields.Create(FAccess);
  Result := TQueryBuilderFrom.Create(FAccess, FRecursivityLevel);
end;

constructor TQueryBuilderSelect.Create(const Access: IQueryBuilderAccess);
begin
  inherited Create;

  FAccess := Access;
  FRecursivityLevel := 1;
end;

destructor TQueryBuilderSelect.Destroy;
begin
  FAccess.Builder.FTable := nil;

  FreeAndNil(FAccess.Builder.FFrom);

  FreeAndNil(FAccess.Builder.FFieldList);

  FreeAndNil(FAccess.Builder.FOpen);

  inherited;
end;

function TQueryBuilderSelect.First(const Total: Cardinal): TQueryBuilderSelect;
begin
  FFirstRecords := Total;
  Result := Self;
end;

function TQueryBuilderSelect.GetFieldsWithAlias: String;
begin
  var FieldAlias: TFieldAlias;
  var FieldList := FAccess.GetFields;
  Result := EmptyStr;

  for var A := Low(FieldList) to High(FieldList) do
  begin
    FieldAlias := FieldList[A];

    if not Result.IsEmpty then
      Result := Result + ',' + FAccess.LineBreak + FAccess.GetIdention(10, False);

    Result := Result + Format('%s.%s F%d', [FieldAlias.TableAlias, FieldAlias.Field.DatabaseName, Succ(A)]);
  end;

  Result := Result + FAccess.LineBreak;
end;

function TQueryBuilderSelect.GetSQL: String;
begin
  Result := EmptyStr;

  if FirstRecords > 0 then
    Result := Result + Format('top %d ', [FirstRecords]);

  Result := Result + GetFieldsWithAlias;
end;

function TQueryBuilderSelect.RecursivityLevel(const Level: Word): TQueryBuilderSelect;
begin
  FRecursivityLevel := Level;
  Result := Self;
end;

{ TQueryBuilderWhere }

procedure TQueryBuilderWhere.BuildFilter(const Value: TQueryBuilderComparisonHelper);
begin
  try
    FFilter := FAccess.GetIdention(4) + 'where ' + MakeFilter(Value.Comparison) + FAccess.LineBreak;
  finally
    Value.Comparison.Free;
  end;
end;

function TQueryBuilderWhere.GetFieldValue(const Comparison: TQueryBuilderComparison; const Field: TField): String;
begin
  case Comparison.Comparison of
    qbcoBetween: Result := Format(' between %s and %s', [Field.GetAsString(Comparison.Right.Value.GetArrayElement(0).AsType<TValue>), Field.GetAsString(Comparison.Right.Value.GetArrayElement(1).AsType<TValue>)]);
    qbcoLike: Result := Format(' like ''%s''', [Comparison.Right.Value.AsString]);
    qbcoNull: Result := ' is null';
    qbcoNotNull: Result := ' is not null';
    else Result := Field.GetAsString(Comparison.Right.Value);
  end;
end;

function TQueryBuilderWhere.GetSQL: String;
begin
  Result := FFilter;

  if Assigned(FOrderBy) then
    Result := Result + FOrderBy.GetSQL;
end;

function TQueryBuilderWhere.GetValueToCompare(const Comparison: TQueryBuilderComparison; const Field: TField): String;
begin
  if Assigned(Comparison.Right) and Assigned(Comparison.Right.Field) then
    Result := FAccess.GetField(Comparison.Right.Field)
  else
    Result := GetFieldValue(Comparison, Field);
end;

function TQueryBuilderWhere.MakeComparison(const Comparison: TQueryBuilderComparison): String;
const
  COMPARISON_OPERATOR: array[TQueryBuilderComparisonOperator] of String = ('', '=', '<>', '>', '>=', '<', '<=', '', '', '', '');

begin
  var Field: TField;
  var FieldName := FAccess.GetField(Comparison.Left.Field, Field);

  Result := Format('%s%s%s', [FieldName, COMPARISON_OPERATOR[Comparison.Comparison], GetValueToCompare(Comparison, Field)]);
end;

function TQueryBuilderWhere.MakeFilter(const Value: TQueryBuilderComparison): String;
begin
  if Value.Comparison <> qbcoNone then
    Result := MakeComparison(Value)
  else if Value.Logical <> qloNone then
    Result := MakeLogical(Value);
end;

function TQueryBuilderWhere.MakeLogical(const Logical: TQueryBuilderComparison): String;
const
  LOGICAL_OPERATOR: array[TQueryBuilderLogicalOperator] of String = ('', 'and', 'or');

begin
  Result := Format('(%s%s%s %s)', [MakeFilter(Logical.Left), FAccess.LineBreak + FAccess.GetIdention(6), LOGICAL_OPERATOR[Logical.Logical], MakeFilter(Logical.Right)]);
end;

constructor TQueryBuilderWhere.Create(const Access: IQueryBuilderAccess);
begin
  inherited Create;

  FAccess := Access;
  FAccess.Builder.FWhere := Self;
end;

destructor TQueryBuilderWhere.Destroy;
begin
  FOrderBy.Free;

  inherited;
end;

function TQueryBuilderWhere.Where(const Condition: TQueryBuilderComparisonHelper): TQueryBuilderWhere;
begin
  Result := Self;

  BuildFilter(Condition);
end;

{ TQueryBuilderOpen<T> }

function TQueryBuilderOpen<T>.All: TArray<T>;
begin
  Result := FLoader.LoadAll<T>;
end;

constructor TQueryBuilderOpen<T>.Create(const Access: IQueryBuilderAccess);
begin
  inherited Create;

  FLoader := TClassLoader.Create(Access);
end;

destructor TQueryBuilderOpen<T>.Destroy;
begin
  FLoader.Free;

  inherited;
end;

function TQueryBuilderOpen<T>.One: T;
begin
  Result := FLoader.Load<T>;
end;

{ TQueryBuilderAllFields }

constructor TQueryBuilderAllFields.Create(const Access: IQueryBuilderAccess);
begin
  inherited Create;

  FAccess := Access;
end;

function TQueryBuilderAllFields.GetAllFields(const Join: TQueryBuilderJoin): TArray<TFieldAlias>;
begin
  Result := nil;

  for var Field in Join.Table.Fields do
    if not Field.IsManyValueAssociation and (not Field.IsForeignKey or Field.IsLazy) then
      Result := Result + [TFieldAlias.Create(Join.Alias, Field)];

  for var Link in Join.Links do
    Result := Result + GetAllFields(Link);
end;

function TQueryBuilderAllFields.GetFields: TArray<TFieldAlias>;
begin
  Result := GetAllFields(FAccess.Join);
end;

{ TQueryBuilderJoin }

constructor TQueryBuilderJoin.Create(const Table: TTable; const Field, LeftField, RightField: TField; const IsInheritedLink: Boolean);
begin
  Create(Table);

  FField := Field;
  FIsInheritedLink := IsInheritedLink;
  FLeftField := LeftField;
  FRightField := RightField;
end;

constructor TQueryBuilderJoin.Create(const Table: TTable);
begin
  inherited Create;

  FTable := Table;
end;

destructor TQueryBuilderJoin.Destroy;
begin
  for var Link in AllLinks do
    Link.Free;

  inherited;
end;

function TQueryBuilderJoin.GetAllLinks: TArray<TQueryBuilderJoin>;
begin
  Result := Links + FilterLinks;
end;

{ TQueryBuilderFieldAlias }

constructor TQueryBuilderFieldAlias.Create(const FieldName: String);
begin
  inherited Create;

  FFieldName := FieldName;
  FFieldNames := FieldName.Split(['.']);
end;

{ TQueryBuilderComparison }

destructor TQueryBuilderComparison.Destroy;
begin
  FLeft.Free;

  FRight.Free;

  FField.Free;

  inherited;
end;

function TQueryBuilderComparison.GetLeft: TQueryBuilderComparison;
begin
  if not Assigned(FLeft) then
    FLeft := TQueryBuilderComparison.Create;

  Result := FLeft;
end;

function TQueryBuilderComparison.GetRight: TQueryBuilderComparison;
begin
  if not Assigned(FRight) then
    FRight := TQueryBuilderComparison.Create;

  Result := FRight;
end;

{ EFieldNotFoundInTable }

constructor EFieldNotFoundInTable.Create(FieldName: String);
begin
  inherited CreateFmt('Field "%s" not found in current table!', [FieldName]);
end;

{ TQueryBuilderComparisonHelper }

function TQueryBuilderComparisonHelper.Between<T>(const ValueStart, ValueEnd: T): TQueryBuilderComparisonHelper;
begin
  Result := Create;
  Result.Comparison.Left := Self.Comparison;
  Result.Comparison.Comparison := qbcoBetween;
  Result.Comparison.Right.Value := TValue.From<TArray<T>>([ValueStart, ValueEnd]);
end;

class operator TQueryBuilderComparisonHelper.BitwiseAnd(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  Result := Create;
  Result.Comparison.Left := Left.Comparison;
  Result.Comparison.Logical := qloAnd;
  Result.Comparison.Right := Right.Comparison;
end;

class operator TQueryBuilderComparisonHelper.BitwiseOr(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  Result := Create;
  Result.Comparison.Left := Left.Comparison;
  Result.Comparison.Logical := qloOr;
  Result.Comparison.Right := Right.Comparison;
end;

class function TQueryBuilderComparisonHelper.Create: TQueryBuilderComparisonHelper;
begin
  FillChar(Result, SizeOf(Result), 0);

  Result.Comparison := TQueryBuilderComparison.Create;
end;

class operator TQueryBuilderComparisonHelper.Equal(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoEqual, Left, TValue.FromVariant(Value), Result);
end;

class operator TQueryBuilderComparisonHelper.Equal(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoEqual, Left, Value, Result);
end;

class operator TQueryBuilderComparisonHelper.Equal(const Left: TQueryBuilderComparisonHelper; const Value: TNullEnumerator): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoNull, Left, TValue.From(Value), Result);
end;

class operator TQueryBuilderComparisonHelper.Equal(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoEqual, Left, Right, Result);
end;

class operator TQueryBuilderComparisonHelper.GreaterThan(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoGreaterThan, Left, Right, Result);
end;

class operator TQueryBuilderComparisonHelper.GreaterThan(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoGreaterThan, Left, Value, Result);
end;

class operator TQueryBuilderComparisonHelper.GreaterThan(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoGreaterThan, Left, TValue.FromVariant(Value), Result);
end;

class operator TQueryBuilderComparisonHelper.GreaterThanOrEqual(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoGreaterThanOrEqual, Left, Right, Result);
end;

class operator TQueryBuilderComparisonHelper.GreaterThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoGreaterThanOrEqual, Left, Value, Result);
end;

class operator TQueryBuilderComparisonHelper.GreaterThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoGreaterThanOrEqual, Left, TValue.FromVariant(Value), Result);
end;

function TQueryBuilderComparisonHelper.IsLoaded: Boolean;
begin
  Result := (Comparison.Logical <> qloNone) or (Comparison.Comparison <> qbcoNone);
end;

class operator TQueryBuilderComparisonHelper.LessThan(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoLessThan, Left, Value, Result);
end;

class operator TQueryBuilderComparisonHelper.LessThan(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoLessThan, Left, Right, Result);
end;

class operator TQueryBuilderComparisonHelper.LessThan(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoLessThan, Left, TValue.FromVariant(Value), Result);
end;

function TQueryBuilderComparisonHelper.Like(const Value: String): TQueryBuilderComparisonHelper;
begin
  Result := Create;
  Result.Comparison.Left := Self.Comparison;
  Result.Comparison.Comparison := qbcoLike;
  Result.Comparison.Right.Value := Value;
end;

class procedure TQueryBuilderComparisonHelper.MakeComparison(const Comparison: TQueryBuilderComparisonOperator; const Left: TQueryBuilderComparisonHelper; const Right: TValue;
  var Result: TQueryBuilderComparisonHelper);
begin
  Result := Create;
  Result.Comparison.Left := Left.Comparison;
  Result.Comparison.Comparison := Comparison;
  Result.Comparison.Right.Value := Right;
end;

class procedure TQueryBuilderComparisonHelper.MakeComparison(const Comparison: TQueryBuilderComparisonOperator; const Left, Right: TQueryBuilderComparisonHelper;
  var Result: TQueryBuilderComparisonHelper);
begin
  Result := Create;
  Result.Comparison.Left := Left.Comparison;
  Result.Comparison.Comparison := Comparison;
  Result.Comparison.Right := Right.Comparison;
end;

class operator TQueryBuilderComparisonHelper.LessThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoLessThanOrEqual, Left, TValue.FromVariant(Value), Result);
end;

class operator TQueryBuilderComparisonHelper.LessThanOrEqual(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoLessThanOrEqual, Left, Value, Result);
end;

class operator TQueryBuilderComparisonHelper.LessThanOrEqual(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoLessThanOrEqual, Left, Right, Result);
end;

class operator TQueryBuilderComparisonHelper.NotEqual(const Left, Right: TQueryBuilderComparisonHelper): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoNotEqual, Left, Right, Result);
end;

class operator TQueryBuilderComparisonHelper.NotEqual(const Left: TQueryBuilderComparisonHelper; const Value: Variant): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoNotEqual, Left, TValue.FromVariant(Value), Result);
end;

class operator TQueryBuilderComparisonHelper.NotEqual(const Left: TQueryBuilderComparisonHelper; const Value: TValue): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoNotEqual, Left, Value, Result);
end;

class operator TQueryBuilderComparisonHelper.NotEqual(const Left: TQueryBuilderComparisonHelper; const Value: TNullEnumerator): TQueryBuilderComparisonHelper;
begin
  MakeComparison(qbcoNotNull, Left, TValue.From(Value), Result);
end;

{ TQueryBuilderOrderBy }

constructor TQueryBuilderOrderBy.Create(const Access: IQueryBuilderAccess);
begin
  inherited Create;

  FAccess := Access;
end;

destructor TQueryBuilderOrderBy.Destroy;
begin
  for var Field in FFields do
    Field.Free;

  inherited;
end;

function TQueryBuilderOrderBy.Field(const FieldName: String; const Ascending: Boolean): TQueryBuilderOrderBy;
begin
  FFields := FFields + [TQueryBuilderOrderByField.Create(FieldName, Ascending)];
  Result := Self;
end;

function TQueryBuilderOrderBy.GetSQL: String;
begin
  Result := EmptyStr;

  for var Field in Fields do
  begin
    if not Result.IsEmpty then
      Result := Result + ',';

    Result := Result + FAccess.GetField(Field);

    if not Field.Ascending then
      Result := Result + ' desc';
  end;

  if not Result.IsEmpty then
    Result := FAccess.GetIdention(1) + 'order by ' + Result + FAccess.LineBreak;
end;

{ TQueryBuilderOrderByField }

constructor TQueryBuilderOrderByField.Create(const FieldName: String; const Ascending: Boolean);
begin
  inherited Create(FieldName);

  FAscending := Ascending;
end;

{ EObjectReferenceWasNotFound }

constructor EObjectReferenceWasNotFound.Create;
begin
  inherited Create('The object reference was not found, reload the data and try again!');
end;

{ ECantFilterManyValueAssociation }

constructor ECantFilterManyValueAssociation.Create(Field: TField);
begin
  inherited CreateFmt('Can''t create a filter of many value association field %s from class %s!', [Field.Name, Field.Table.Name]);
end;

{ ECommandWithoutFromClause }

constructor ECommandWithoutFromClause.Create;
begin
  inherited Create('Command whitout from clause, check the implementation!');
end;

{ TQueryBuilderWhere<T> }

function TQueryBuilderWhere<T>.Open: TQueryBuilderOpen<T>;
begin
  Result := TQueryBuilderOpen<T>.Create(FAccess);

  FAccess.Builder.FOpen := Result;
end;

function TQueryBuilderWhere<T>.OrderBy: TQueryBuilderOrderBy<T>;
begin
  Result := TQueryBuilderOrderBy<T>.Create(FAccess);

  FOrderBy := Result;
end;

function TQueryBuilderWhere<T>.Where(const Condition: TQueryBuilderComparisonHelper): TQueryBuilderWhere<T>;
begin
  inherited Where(Condition);

  Result := Self;
end;

{ TQueryBuilderOrderBy<T> }

function TQueryBuilderOrderBy<T>.Field(const FieldName: String; const Ascending: Boolean): TQueryBuilderOrderBy<T>;
begin
  inherited Field(FieldName, Ascending);

  Result := Self;
end;

function TQueryBuilderOrderBy<T>.Open: TQueryBuilderOpen<T>;
begin
  Result := TQueryBuilderOpen<T>.Create(FAccess);

  FAccess.Builder.FOpen := Result;
end;

{ TDatabaseNamedObject }

constructor TDatabaseNamedObject.Create(const Name: String);
begin
  inherited Create;

  FName := Name;
end;

class function TDatabaseNamedObject.FindObject<T>(const List: TList<T>; const Name: String): T;
begin
  Result := nil;

  for var AObject in List do
    if AnsiCompareText(AObject.Name, Name) = 0 then
      Exit(AObject);
end;

{ TDatabaseTableObject }

constructor TDatabaseTableObject.Create(const Table: TDatabaseTable; const Name: String);
begin
  inherited Create(Name);

  FTable := Table;
end;

{ TDatabaseForeignKey }

constructor TDatabaseForeignKey.Create(const ParentTable: TDatabaseTable; const Name: String; const ReferenceTable: TDatabaseTable);
begin
  inherited Create(ParentTable, Name);

  FReferenceTable := ReferenceTable;

  FTable.FForeignKeys.Add(Self);
end;

{ TDatabaseField }

constructor TDatabaseField.Create(const Table: TDatabaseTable; const Name: String);
begin
  inherited;

  FTable.FFields.Add(Self);
end;

destructor TDatabaseField.Destroy;
begin
  FDefaultConstraint.Free;

  FCheck.Free;

  inherited;
end;

{ TDatabaseIndex }

constructor TDatabaseIndex.Create(const Table: TDatabaseTable; const Name: String);
begin
  inherited;

  FTable.FIndexes.Add(Self);
end;

{ TDatabaseTable }

constructor TDatabaseTable.Create(const Schema: TDatabaseSchema; const Name: String);
begin
  inherited Create(Name);

  FFields := TObjectList<TDatabaseField>.Create;
  FForeignKeys := TObjectList<TDatabaseForeignKey>.Create;
  FIndexes := TObjectList<TDatabaseIndex>.Create;
  FSchema := Schema;

  Schema.Tables.Add(Self);
end;

destructor TDatabaseTable.Destroy;
begin
  FFields.Free;

  FForeignKeys.Free;

  FIndexes.Free;

  inherited;
end;

function TDatabaseTable.GetField(const Name: String): TDatabaseField;
begin
  Result := TDatabaseNamedObject.FindObject<TDatabaseField>(Fields, Name);
end;

function TDatabaseTable.GetForeignKey(const Name: String): TDatabaseForeignKey;
begin
  Result := TDatabaseNamedObject.FindObject<TDatabaseForeignKey>(ForeignKeys, Name);
end;

function TDatabaseTable.GetIndex(const Name: String): TDatabaseIndex;
begin
  Result := TDatabaseNamedObject.FindObject<TDatabaseIndex>(Indexes, Name);
end;

{ TDatabaseMetadataUpdate }

procedure TDatabaseMetadataUpdate.CheckChangingTheList<T>(const List: TList<T>; const Func: TFunc<T, Boolean>);
begin
  var A := 0;

  while A < List.Count do
    if not Func(List[A]) then
      Inc(A);
end;

function TDatabaseMetadataUpdate.CheckSameFields(const Fields: TArray<TField>; const DatabaseFields: TArray<TDatabaseField>): Boolean;
begin
  Result := Length(Fields) = Length(DatabaseFields);

  if Result then
    for var A := Low(Fields) to High(Fields) do
      if Fields[A].DatabaseName <> DatabaseFields[A].Name then
        Exit(False);
end;

constructor TDatabaseMetadataUpdate.Create(const Manager: TManager);
begin
  inherited Create;

  FManager := Manager;
  FMetadataManipulator := Manager.FDialect.CreateManipulator(Manager);

  Randomize;
end;

procedure TDatabaseMetadataUpdate.CreateField(const Field: TField);
begin
  FMetadataManipulator.CreateField(Field);
end;

procedure TDatabaseMetadataUpdate.DropField(const DatabaseField: TDatabaseField);
begin
  for var Table in DatabaseField.Table.Schema.Tables do
    CheckChangingTheList<TDatabaseForeignKey>(Table.ForeignKeys,
      function (DatabaseForeignKey: TDatabaseForeignKey): Boolean
      begin
        Result := FieldInTheList(DatabaseField, DatabaseForeignKey.FieldsReference) or FieldInTheList(DatabaseField, DatabaseForeignKey.Fields);

        if Result then
          DropForeignKey(DatabaseForeignKey);
      end);

  CheckChangingTheList<TDatabaseIndex>(DatabaseField.Table.Indexes,
    function (Index: TDatabaseIndex): Boolean
    begin
      Result := FieldInTheList(DatabaseField, Index.Fields);

      if Result then
        DropIndex(Index);
    end);

  if Assigned(DatabaseField.DefaultConstraint) then
    FMetadataManipulator.DropDefaultConstraint(DatabaseField);

  FMetadataManipulator.DropField(DatabaseField);

  DatabaseField.Table.Fields.Remove(DatabaseField);
end;

procedure TDatabaseMetadataUpdate.DropForeignKey(const DatabaseForeignKey: TDatabaseForeignKey);
begin
  FMetadataManipulator.DropForeignKey(DatabaseForeignKey);

  DatabaseForeignKey.Table.ForeignKeys.Remove(DatabaseForeignKey);
end;

procedure TDatabaseMetadataUpdate.DropIndex(const DatabaseIndex: TDatabaseIndex);
begin
  if DatabaseIndex.PrimaryKey then
    for var Table in DatabaseIndex.Table.Schema.Tables do
      CheckChangingTheList<TDatabaseForeignKey>(Table.ForeignKeys,
        function (DatabaseForeignKey: TDatabaseForeignKey): Boolean
        begin
          Result := DatabaseIndex.Table = DatabaseForeignKey.ReferenceTable;

          if Result then
            DropForeignKey(DatabaseForeignKey);
        end);

  FMetadataManipulator.DropIndex(DatabaseIndex);

  DatabaseIndex.Table.Indexes.Remove(DatabaseIndex);
end;

procedure TDatabaseMetadataUpdate.DropTable(const DatabaseTable: TDatabaseTable);
begin
  for var Table in DatabaseTable.Schema.Tables do
    CheckChangingTheList<TDatabaseForeignKey>(Table.ForeignKeys,
      function (DatabaseForeignKey: TDatabaseForeignKey): Boolean
      begin
        Result := (DatabaseTable = DatabaseForeignKey.ReferenceTable) or (DatabaseTable = DatabaseForeignKey.Table);

        if Result then
          DropForeignKey(DatabaseForeignKey);
      end);

  FMetadataManipulator.DropTable(DatabaseTable);
end;

function TDatabaseMetadataUpdate.FieldInTheList(const DatabaseField: TDatabaseField; const DatabaseFields: TArray<TDatabaseField>): Boolean;
begin
  Result := False;

  for var Field in DatabaseFields do
    if Field = DatabaseField then
      Exit(True);
end;

procedure TDatabaseMetadataUpdate.RecreateField(const Field: TField; const DatabaseField: TDatabaseField);
begin
  try
    var TempField := TField.Create(Field.Table);
    TempField.DatabaseName := 'TempField' + Trunc(Random * 1000000).ToString;
    TempField.FieldType := Field.FieldType;
    TempField.ForeignKey := Field.ForeignKey;
    TempField.IsForeignKey := Field.IsForeignKey;
    TempField.Name := TempField.DatabaseName;
    TempField.Required := Field.Required;
    TempField.Scale := Field.Scale;
    TempField.Size := Field.Size;
    TempField.SpecialType := Field.SpecialType;

    FMetadataManipulator.CreateTempField(TempField);

    FMetadataManipulator.UpdateField(Field, TempField);

    DropField(DatabaseField);

    FMetadataManipulator.RenameField(TempField, Field);

    TempField.Free;
  except
    on E: Exception do
      raise Exception.CreateFmt('Erro trying to convert the field %s.%s: %s', [Field.Table.DatabaseName, Field.DatabaseName, E.Message]);
  end;
end;

procedure TDatabaseMetadataUpdate.UpdateDatabase;
var
  DatabaseField: TDatabaseField;

  DatabaseForeignKey: TDatabaseForeignKey;

  DatabaseIndex: TDatabaseIndex;

  DatabaseSequence: TDatabaseSequence;

  DatabaseTable: TDatabaseTable;

  ForeignKey: TForeignKey;

  Field: TField;

  Index: TIndex;

  Sequence: TSequence;

  Table: TTable;

  Tables: TDictionary<String, TTable>;

  Schema: TDatabaseSchema;

  function ExistsForeigKey(const DatabaseForeignKey: TDatabaseForeignKey): Boolean;
  begin
    Result := False;

    for var ForeignKey in Tables[DatabaseForeignKey.Table.Name].ForeignKeys do
      if ForeignKey.DatabaseName = DatabaseForeignKey.Name then
        Exit(True);
  end;

  function ExistsIndex(const DatabaseIndex: TDatabaseIndex): Boolean;
  begin
    Result := False;

    for var Index in Tables[DatabaseIndex.Table.Name].Indexes do
      if Index.DatabaseName = DatabaseIndex.Name then
        Exit(True);
  end;

  function ExistsField(const DatabaseField: TDatabaseField): Boolean;
  begin
    Result := False;

    for var Field in Tables[DatabaseField.Table.Name].Fields do
      if Field.DatabaseName = DatabaseField.Name then
        Exit(True);
  end;

  function IsSpecialType: Boolean;
  begin
    Result := Field.SpecialType <> stNotDefined;
  end;

  function FieldSizeChanged: Boolean;
  begin
    Result := (Field.Size <> DatabaseField.Size) and (Field.FieldType.TypeKind in [tkUString, tkFloat]) and not IsSpecialType;
  end;

  function FieldScaleChanged: Boolean;
  begin
    Result := (Field.Scale <> DatabaseField.Scale) and (Field.FieldType.TypeKind = tkFloat) and not IsSpecialType;
  end;

  function FieldSpecialTypeChanged: Boolean;
  begin
    Result := Field.SpecialType <> DatabaseField.SpecialType;
  end;

  function FieldTypeChanged: Boolean;
  begin
    var FieldKind := Field.FieldType.TypeKind;

    Result := FieldKind <> DatabaseField.FieldType;
  end;

  function FieldRequiredChanged: Boolean;
  begin
    Result := Field.Required <> DatabaseField.Required;
  end;

  function FieldDefaultValueChanged: Boolean;
  begin
    Result := Assigned(DatabaseField.DefaultConstraint) xor Assigned(Field.DefaultConstraint) or Assigned(DatabaseField.DefaultConstraint)
      and ((DatabaseField.DefaultConstraint.Name <> FMetadataManipulator.GetDefaultConstraintName(Field))
        or (FMetadataManipulator.GetAutoGeneratedValue(Field.DefaultConstraint).ToLower <> DatabaseField.DefaultConstraint.Value.ToLower));
  end;

  function FieldChanged: Boolean;
  begin
    Result := FieldTypeChanged or FieldSizeChanged or FieldScaleChanged or FieldSpecialTypeChanged or FieldRequiredChanged
  end;

  procedure RecreateIndex(const Index: TIndex; const DatabaseIndex: TDatabaseIndex);
  begin
    if Assigned(DatabaseIndex) then
      DropIndex(DatabaseIndex);

    FMetadataManipulator.CreateIndex(Index);
  end;

  function GetPrimaryKeyDatabaseIndex: TDatabaseIndex;
  begin
    Result := nil;

    for var DatabaseIndex in DatabaseTable.Indexes do
      if DatabaseIndex.PrimaryKey then
        Exit(DatabaseIndex);
  end;

  procedure LoadDatabaseSchema;
  begin
    Schema := TDatabaseSchema.Create;

    FMetadataManipulator.LoadSchema(Schema);
  end;

  procedure CreateTable(const Table: TTable);
  begin
    FMetadataManipulator.CreateTable(Table);

    DatabaseTable := TDatabaseTable.Create(Schema, Table.DatabaseName);
  end;

begin
  Tables := TDictionary<String, TTable>.Create;

  LoadDatabaseSchema;

  for Sequence in FManager.Mapper.Sequences do
    if not Assigned(Schema.Sequence[Sequence.Name]) then
      FMetadataManipulator.CreateSequence(Sequence);

  for Table in FManager.Mapper.Tables do
  begin
    DatabaseTable := Schema.Table[Table.DatabaseName];

    Tables.Add(Table.DatabaseName, Table);

    if not Assigned(DatabaseTable) then
      CreateTable(Table)
    else
      for Field in Table.Fields do
        if not Field.IsManyValueAssociation then
        begin
          DatabaseField := DatabaseTable.Field[Field.DatabaseName];

          if not Assigned(DatabaseField) then
            CreateField(Field)
          else if FieldChanged then
            RecreateField(Field, DatabaseField)
          else
          begin
            if FieldDefaultValueChanged then
            begin
              if Assigned(DatabaseField.DefaultConstraint) then
                FMetadataManipulator.DropDefaultConstraint(DatabaseField);

              if Assigned(Field.DefaultConstraint) then
                FMetadataManipulator.CreateDefaultConstraint(Field);
            end;

            if Field.DatabaseName <> DatabaseField.Name then
            begin
              DatabaseField.Name := Field.DatabaseName;

              FMetadataManipulator.RenameField(Field, Field);
            end;
          end;
        end;
  end;

  for Table in FManager.Mapper.Tables do
    if Table.DefaultRecords.Count > 0 then
    begin
      var RecordFound: Boolean;
      var Records := FMetadataManipulator.GetAllRecords(Table);

      for var DefaultRecord in Table.DefaultRecords do
      begin
        RecordFound := False;

        for var DatabaseRecord in Records do
          RecordFound := RecordFound or (Table.PrimaryKey.GetAsString(DefaultRecord) = Table.PrimaryKey.GetAsString(DatabaseRecord));

        if RecordFound then
          FMetadataManipulator.UpdateRecord(DefaultRecord)
        else
          FMetadataManipulator.InsertRecord(DefaultRecord);
      end;
    end;

  for Table in FManager.Mapper.Tables do
  begin
    DatabaseTable := Schema.Table[Table.DatabaseName];

    if Assigned(DatabaseTable) then
      for Index in Table.Indexes do
      begin
        if Index.PrimaryKey then
          DatabaseIndex := GetPrimaryKeyDatabaseIndex
        else
          DatabaseIndex := DatabaseTable.Index[Index.DatabaseName];

        if not Assigned(DatabaseIndex) or not CheckSameFields(Index.Fields, DatabaseIndex.Fields) or (DatabaseIndex.Name <> Index.DatabaseName)
          or (DatabaseIndex.Unique xor Index.Unique) then
          RecreateIndex(Index, DatabaseIndex);
      end;
  end;

  for Table in FManager.Mapper.Tables do
  begin
    DatabaseTable := Schema.Table[Table.DatabaseName];

    if Assigned(DatabaseTable) then
      for ForeignKey in Table.ForeignKeys do
      begin
        DatabaseForeignKey := DatabaseTable.ForeignKey[ForeignKey.DatabaseName];

        if not Assigned(DatabaseForeignKey) then
          FMetadataManipulator.CreateForeignKey(ForeignKey)
        else if not CheckSameFields([ForeignKey.Field], DatabaseForeignKey.Fields) then
        begin
          DropForeignKey(DatabaseForeignKey);

          FMetadataManipulator.CreateForeignKey(ForeignKey)
        end;
      end;
  end;

  for DatabaseTable in Schema.Tables do
    if Tables.ContainsKey(DatabaseTable.Name) then
    begin
      for DatabaseForeignKey in DatabaseTable.ForeignKeys do
        if not ExistsForeigKey(DatabaseForeignKey) then
          DropForeignKey(DatabaseForeignKey);

      for DatabaseIndex in DatabaseTable.Indexes do
        if not ExistsIndex(DatabaseIndex) then
          DropIndex(DatabaseIndex);

      for DatabaseField in DatabaseTable.Fields do
        if not ExistsField(DatabaseField) then
          DropField(DatabaseField);
    end
    else
      DropTable(DatabaseTable);

  for DatabaseSequence in Schema.Sequences do
    if not Assigned(FManager.Mapper.FindSequence(DatabaseSequence.Name)) then
      FMetadataManipulator.DropSequence(DatabaseSequence);

  Schema.Free;

  Tables.Free;
end;

{ TDatabaseSchema }

constructor TDatabaseSchema.Create;
begin
  inherited;

  FSequences := TObjectList<TDatabaseSequence>.Create;
  FTables := TObjectList<TDatabaseTable>.Create;
end;

destructor TDatabaseSchema.Destroy;
begin
  FSequences.Free;

  FTables.Free;

  inherited;
end;

function TDatabaseSchema.GetSequence(const Name: String): TDatabaseSequence;
begin
  Result := TDatabaseNamedObject.FindObject<TDatabaseSequence>(Sequences, Name);
end;

function TDatabaseSchema.GetTable(const Name: String): TDatabaseTable;
begin
  Result := TDatabaseNamedObject.FindObject<TDatabaseTable>(Tables, Name);
end;

{ TDatabaseDefaultConstraint }

constructor TDatabaseDefaultConstraint.Create(const Field: TDatabaseField; const Name, Value: String);
begin
  inherited Create(Name);

  Field.DefaultConstraint := Self;
  FValue := Value;
end;

{ TDatabaseCheckConstraint }

constructor TDatabaseCheckConstraint.Create(const Field: TDatabaseField; const Name, Check: String);
begin
  inherited Create(Name);

  FCheck := Check;
end;

{ TMetadataManipulator }

constructor TMetadataManipulator.Create(const Manager: TManager);
begin
  inherited Create;

  FManager := Manager;
end;

procedure TMetadataManipulator.CreateDefaultConstraint(const Field: TField);
begin
  raise Exception.Create('Not implemented!');
end;

procedure TMetadataManipulator.CreateField(const Field: TField);
begin
  ExecuteDirect(Format('alter table %s add %s', [Field.Table.DatabaseName, GetFieldDefinition(Field)]));
end;

procedure TMetadataManipulator.CreateForeignKey(const ForeignKey: TForeignKey);
begin
  ExecuteDirect(Format('alter table %s add constraint %s foreign key (%s) references %s (%s)', [ForeignKey.Table.DatabaseName,
    ForeignKey.DatabaseName, ForeignKey.Field.DatabaseName, ForeignKey.ParentTable.DatabaseName, ForeignKey.ParentTable.PrimaryKey.DatabaseName]));
end;

procedure TMetadataManipulator.CreateIndex(const Index: TIndex);

  function CheckUniqueIndex: String;
  begin
    if Index.Unique then
      Result := 'unique '
    else
      Result := EmptyStr;
  end;

begin
  if Index.PrimaryKey then
    ExecuteDirect(Format('alter table %s add %s', [Index.Table.DatabaseName, GetPrimaryKey(Index.Table, EmptyStr)]))
  else
    ExecuteDirect(Format('create %sindex %s on %s (%s)', [CheckUniqueIndex, Index.DatabaseName, Index.Table.DatabaseName, GetFieldList(Index.Fields)]));
end;

procedure TMetadataManipulator.CreateSequence(const Sequence: TSequence);
begin
  ExecuteDirect(Format('create sequence %s increment by 1 start with 1', [Sequence.Name]));
end;

procedure TMetadataManipulator.CreateTable(const Table: TTable);
begin
  var Fields := EmptyStr;

  for var Field in Table.Fields do
    if not Field.IsManyValueAssociation then
    begin
      if not Fields.IsEmpty then
        Fields := Fields + ',';

      Fields := Fields + GetFieldDefinition(Field);
    end;

  ExecuteDirect(Format('create table %s (%s)', [Table.DatabaseName, Fields]));
end;

procedure TMetadataManipulator.CreateTempField(const Field: TField);
begin
  CreateField(Field);
end;

procedure TMetadataManipulator.DropDefaultConstraint(const Field: TDatabaseField);
begin
  ExecuteDirect(Format('alter table %s drop constraint %s', [Field.Table.Name, Field.DefaultConstraint.Name]));
end;

procedure TMetadataManipulator.DropField(const Field: TDatabaseField);
begin
  ExecuteDirect(Format('alter table %s drop column %s', [Field.Table.Name, Field.Name]));
end;

procedure TMetadataManipulator.DropForeignKey(const ForeignKey: TDatabaseForeignKey);
begin
  ExecuteDirect(Format('alter table %s drop constraint %s', [ForeignKey.Table.Name, ForeignKey.Name]));
end;

procedure TMetadataManipulator.DropIndex(const Index: TDatabaseIndex);
begin
  ExecuteDirect(Format('drop index %s on %s', [Index.Name, Index.Table.Name]));
end;

procedure TMetadataManipulator.DropSequence(const Sequence: TDatabaseSequence);
begin
  ExecuteDirect(Format('drop sequence %s', [Sequence.Name]));
end;

procedure TMetadataManipulator.DropTable(const Table: TDatabaseTable);
begin
  ExecuteDirect(Format('drop table %s', [Table.Name]));
end;

procedure TMetadataManipulator.ExecuteDirect(const SQL: String);
begin
  FManager.FConnection.ExecuteDirect(SQL);
end;

function TMetadataManipulator.GetAllRecords(const Table: TTable): TArray<TObject>;
begin
  Result := FManager.Select.All.From(Table).Open.All;
end;

function TMetadataManipulator.GetDefaultConstraintName(const Field: TField): String;
begin
  Result := Format('DF_%s_%s', [Field.Table.DatabaseName, Field.DatabaseName]);
end;

function TMetadataManipulator.GetFieldCollation(const Field: TField): String;
begin
  Result := EmptyStr;

  if not Field.Collation.IsEmpty then
    Result := Format(' collate %s', [Field.Collation]);
end;

function TMetadataManipulator.GetFieldDefaultConstraint(const Field: TField): String;
begin
  Result := EmptyStr;

  if Assigned(Field.DefaultConstraint) then
    Result := Format(' constraint %s default(%s)', [GetDefaultConstraintName(Field), GetAutoGeneratedValue(Field.DefaultConstraint)]);
end;

function TMetadataManipulator.GetFieldDefinition(const Field: TField): String;
const
  IS_NULL_VALUE: array[Boolean] of String = ('', 'not ');

begin
  Result := Format('%s %s %snull%s%s', [Field.DatabaseName, GetFieldTypeDefinition(Field), IS_NULL_VALUE[Field.Required], GetFieldCollation(Field),
    GetFieldDefaultConstraint(Field)]);
end;

function TMetadataManipulator.GetFieldList(const Fields: TArray<TField>): String;
begin
  Result := EmptyStr;

  for var Field in Fields do
  begin
    if not Result.IsEmpty then
      Result := Result + ',';

    Result := Result + Field.DatabaseName;
  end;
end;

function TMetadataManipulator.GetFieldTypeDefinition(Field: TField): String;
begin
  if Field.SpecialType = stNotDefined then
  begin
    Result := GetFieldType(Field);

    if Field.FieldType.TypeKind in [tkFloat, tkUString, tkWChar] then
    begin
      var Size := Field.Size.ToString;

      if Field.FieldType.TypeKind = tkFloat then
        Size := Size + ',' + Field.Scale.ToString;

      Result := Format('%s(%s)', [Result, Size]);
    end;
  end
  else
    Result := GetSpecialFieldType(Field);
end;

function TMetadataManipulator.GetPrimaryKey(const Table: TTable; const Separator: String): String;
begin
  if Assigned(Table.PrimaryKey) then
  begin
    var Index := GetPrimaryKeyIndex(Table);

    Result := Format('%sconstraint %s primary key (%s)', [Separator, Index.DatabaseName, GetFieldList(Index.Fields)]);
  end;
end;

function TMetadataManipulator.GetPrimaryKeyIndex(const Table: TTable): TIndex;
begin
  Result := nil;

  for var Index in Table.Indexes do
    if Index.PrimaryKey then
      Exit(Index);
end;

procedure TMetadataManipulator.InsertRecord(const Value: TObject);
begin
  FManager.Insert(Value);
end;

function TMetadataManipulator.OpenCursor(const SQL: String): IDatabaseCursor;
begin
  Result := FManager.FConnection.OpenCursor(SQL);
end;

procedure TMetadataManipulator.RenameField(const SourceField, DestinyField: TField);
begin
  raise Exception.Create('Not implemented!');
end;

procedure TMetadataManipulator.UpdateField(const SourceField, DestinyField: TField);
begin
  ExecuteDirect(Format('update %s set %s = %s', [SourceField.Table.DatabaseName, DestinyField.DatabaseName, SourceField.DatabaseName]));
end;

procedure TMetadataManipulator.UpdateRecord(const Value: TObject);
begin
  FManager.Update(Value);
end;

{ TManager }

constructor TManager.Create(const Connection: IDatabaseConnection; const Dialect: IDatabaseDialect);
begin
  inherited Create;

  FConnection := Connection;
  FDialect := Dialect;
  FMapper := TMapper.Create;

  FMapper.LoadAll;
end;

procedure TManager.Delete(const &Object: TObject);
begin

end;

destructor TManager.Destroy;
begin
  FMapper.Free;

  inherited;
end;

procedure TManager.Insert(const &Object: TObject);
begin

end;

function TManager.OpenCursor(const SQL: String): IDatabaseCursor;
begin
  Result := FConnection.OpenCursor(SQL);
end;

procedure TManager.Save(const &Object: TObject);
begin

end;

function TManager.Select: TQueryBuilderSelect;
begin
  Result := nil;
end;

procedure TManager.Update(const &Object: TObject);
begin

end;

procedure TManager.UpdateDatabaseSchema;
begin
  var Updater := TDatabaseMetadataUpdate.Create(Self);

  try
    Updater.UpdateDatabase;
  finally
    Updater.Free;
  end;
end;

end.

