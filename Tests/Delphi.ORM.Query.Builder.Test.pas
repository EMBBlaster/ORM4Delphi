unit Delphi.ORM.Query.Builder.Test;

interface

uses System.Rtti, DUnitX.TestFramework, Delphi.ORM.Query.Builder, Delphi.ORM.Database.Connection, Delphi.ORM.Attributes, Delphi.ORM.Test.Entity, Delphi.ORM.Cache, Delphi.Mock.Intf,
  Delphi.ORM.Cursor.Mock, Delphi.ORM.Lazy;

type
  TDatabaseTest = class;

  TQueryBuilderBaseTest = class
  private
    FBuilder: TQueryBuilder;
    FBuilderAccess: IQueryBuilderAccess;
    FCache: ICache;
    FCursor: IDatabaseCursor;
    FCursorClass: TCursorMock;
    FDatabase: IDatabaseConnection;
    FDatabaseClass: TDatabaseTest;
    FDatabaseMock: IMock<IDatabaseConnection>;

    function AddObjectToCache<T: class>(const Obj: T): T; overload;
    function AddObjectToCache<T: class>(const Obj: T; const PrimaryKeyValue: TValue): T; overload;
    function GetBuilder: TQueryBuilder;
    function GetDatabaseClass: TDatabaseTest;
    function GetDatabaseMock: IMock<IDatabaseConnection>;
    function GetDatabase: IDatabaseConnection;

    property Builder: TQueryBuilder read GetBuilder;
    property Database: IDatabaseConnection read GetDatabase;
    property DatabaseClass: TDatabaseTest read GetDatabaseClass;
    property DatabaseMock: IMock<IDatabaseConnection> read GetDatabaseMock;
  public
    [Setup]
    procedure Setup;
    [SetupFixture]
    procedure SetupFixture;
    [TearDown]
    procedure TearDown;
  end;

  [TestFixture]
  TQueryBuilderTest = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure IfNoCommandCalledTheSQLMustReturnEmpty;
    [Test]
    procedure IfNoCommandIsCalledCantRaiseAnExceptionOfAccessViolation;
    [Test]
    procedure WhenSelectAllFieldsFromAClassMustPutAllThenInTheResultingSQL;
    [Test]
    procedure IfTheAllFieldNoCalledCantRaiseAnExceptionOfAccessViolation;
    [Test]
    procedure OnlyPublishedPropertiesCanAppearInSQL;
    [Test]
    procedure WhenCallOpenProcedureMustOpenTheDatabaseCursor;
    [Test]
    procedure WhenOpenOneMustFillTheClassWithTheValuesOfCursor;
    [Test]
    procedure WhenAFilterConditionMustBuildTheSQLAsExpected;
    [Test]
    procedure IfNotExistsAFilterInWhereMustReturnTheQueryWithoutWhereCommand;
    [Test]
    procedure WhenCallInsertProcedureMustBuildTheSQLWithAllFieldsAndValuesFromTheClassParameter;
    [Test]
    procedure OnlyPublishedPropertiesMustAppearInInsertSQL;
    [Test]
    procedure OnlyPublishedPropertiesMustAppearInUpdateSQL;
    [Test]
    procedure WhenCallUpdateMustBuildTheSQLWithAllPropertiesInTheObjectParameter;
    [Test]
    procedure WhenTheClassHaveThePrimaryKeyAttributeMustBuildTheWhereWithTheValuesOfFieldInTheKeyList;
    [Test]
    procedure TheKeyFieldCantBeUpdatedInTheUpdateProcedure;
    [Test]
    procedure WhenTheClassDontHaveThePrimaryKeyAttributeCantRaiseAException;
    [Test]
    procedure WhenCallTheDeleteProcedureMustBuildTheSQLWithTheValuesOfKeysOfClass;
    [Test]
    procedure WhenTheClassDontHaveAnyPrimaryKeyTheDeleteMustBuildTheSQLWithoutWhereCondition;
    [Test]
    procedure TheClassBeingSelectedMustHaveTheAliasDefined;
    [Test]
    procedure TheFieldsHaveToBeGeneratedWithTheAliasOfTheRespectiveTables;
    [Test]
    procedure WhenClassHasOtherClassesLinkedToItYouHaveToGenerateTheJoinBetweenThem;
    [Test]
    procedure AllTheDirectForeignKeyMustBeGeneratedInTheResultingSQL;
    [Test]
    procedure TheForeignKeyMustBeLoadedRecursive;
    [Test]
    procedure WhenTheClassHaveForeignKeysThatsLoadsRecursivelyCantRaiseAnError;
    [Test]
    procedure MustGenerateTheSQLFollowingTheHierarchyAsSpected;
    [Test]
    procedure WhenConfiguredTheRecursivityLevelTheJoinsMustFollowTheConfiguration;
    [Test]
    procedure WhenTheClassRecursivelyItselfMoreThenOneTimeMustBuildTheSQLAsEspected;
    [Test]
    procedure WhenTheClassHaveManyValueAssociationMustLoadTheJoinBetweenTheParentAndChildTable;
    [Test]
    procedure TheManyValueAssociationMustAvoidRecursivilyLoadTheParentClassWhenLoadingTheChildClass;
    [Test]
    procedure WhenIsLoadedAJoinMustLoadTheFieldThatIsTheLinkBetweenTheClasses;
    [Test]
    procedure TheManyValueAssociationMustLoadTheLinkingFieldBetweenTheClasses;
    [Test]
    procedure WhenGetAllFieldsOfATableMustPutThePrimaryKeyFieldInTheBeginningOfTheResultingArray;
    [Test]
    procedure WhenAFieldIsMarkedWithAutoGeneratedItCantBeInTheInsertSQL;
    [Test]
    procedure WhenInsertAClassWithTheAutoGeneratedAttributeMustLoadTheFieldNamesInTheArrayOfTheProcedure;
    [Test]
    procedure TheValuesReturnedInTheCursorOfTheInsertMustLoadTheFieldsOfTheClassBeenInserted;
    [Test]
    procedure WhenDontHaveAResultingCursorCantLoadTheProperties;
    [Test]
    procedure WhenInsertingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheInsert;
    [Test]
    procedure WhenUpdatingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheUpdateList;
    [Test]
    procedure ThenForeignKeyLinkOfAnManyValueAssociationCantAppearInTheSQL;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustInsertThenValueOfThePropertyIfNotIsNull;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustUpdateTheValueNullInSQLIfIsNull;
    [Test]
    procedure WhenTheClassAsAFieldWithNullableRecordMustUpdateThenValueOfThePropertyIfNotIsNull;
    [Test]
    procedure WhenTryToSaveAnEntityWithThePrimaryKeyEmptyMustInsertTheEntity;
    [Test]
    procedure WhenTryToSaveAnEntityWithThePrimaryKeyFilledMustUpdateTheEntity;
    [Test]
    procedure WhenUpdateAnEntityWithoutPrimaryKeyMustUpdateAllRecordFromTable;
    [Test]
    procedure WhenUseTheOrderByClauseMustLoadTheSQLHasExpected;
    [Test]
    procedure WhenTheJoinLinkIsFromAnInheritedClassMustMarkTheIsInheritedLinkHasTrue;
    [Test]
    procedure WhenTheBeautifyQueryIsEnabledMustBuildTheQueryHasExpected;
    [Test]
    procedure WhenTheJoinMappingEnabledMustLoadTheJoinInfoOnQueryComments;
    [Test]
    procedure WhenTheBeautifyQueryAndJoinMappingIsEnabledMustBuildTheQueryAsExpected;
    [Test]
    procedure WhenTheJoinMappingEnabledAnTheEntityHasAlignedJoinsMustLoadTheJoinInfoOfAllLinks;
    [Test]
    procedure AllSelectsMustHaveAFromClauseIfNotMustRaiseAnError;
    [Test]
    procedure WhenIsMadeASelectAndAfterADeleteMustCleanUpTheSelectAndBuildTheFilterAsExpected;
    [Test]
    procedure WhenIsMadeASelectAndAfterAnUpdateMustCleanUpTheSelectAndBuildTheFilterAsExpected;
    [Test]
    procedure WhenDisableTheOptionToRemoveTheForeignKeyCantDestroyTheForiegnKeyObject;
  end;

  [TestFixture]
  TQueryBuilderSelectTest = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure WhenIsNotDefinedTheRecursivityLevelMustBeOneTheDefaultValue;
    [Test]
    procedure WhenTheClassHaveForeignKeyMustBuildTheSQLWithTheAliasOfTheJoinMapped;
    [Test]
    procedure WhenFillTheFirstRecordsMustLoadThePropertyWithThePassedValue;
    [Test]
    procedure WhenFillTheFirstRecordsMustBuildTheSQLAsExpectedForSQLServer;
    [Test]
    procedure WhenSelectingATableAsAParameterMustUseThisParameterAndNotTryingToFindTheGenericTable;
  end;

  [TestFixture]
  TQueryBuilderFromTest = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure WhenCallFromFunctionMustLoadTheTablePropertyWithTheDataOfThatTable;
    [Test]
    procedure WhenCallFromFunctionWithAClassWithTwoForeignKeyAndOneOfThisIsSettedOfPrimaryKeyAttributeMustGenerateJoinComparingRightAliasLikePrimaryKeyOfClassForeign;
    [Test]
    procedure WhenFilterringALazyFieldMustBuildTheJoinsToTheFilterWork;
    [Test]
    procedure WhenUseALazyFieldInTheFilterMoreThenOnceMustLoadASingleJoin;
    [Test]
    procedure WhenTheClassHasAnLazyArrayCantCreateTheJoinBetweenTheClasses;
  end;

  [TestFixture]
  TQueryBuilderComparisonTest = class
  public
    [Test]
    procedure WhenCallTheFieldFuncitionMustLoadTheFieldNameInTheLeftOperator;
    [Test]
    procedure WhenCompareTheFieldWithAStringValueMustLoadTheComparisonAsExpected;
    [TestCase('Between', 'qbcoBetween')]
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    [TestCase('Null', 'qbcoNull')]
    [TestCase('Not Null', 'qbcoNotNull')]
    [TestCase('Like', 'qbcoLike')]
    procedure WhenCompareTheFieldWithAnIntegerValueMustLoadTheComparisonAsExpected(Operation: TQueryBuilderComparisonOperator);
    [Test]
    procedure WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithFilledComparisons;
    [Test]
    procedure WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithOperationAndFilled;
    [Test]
    procedure WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithFilledComparisons;
    [Test]
    procedure WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithOperationOrFilled;
    [Test]
    procedure WhenTheAndOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
    [Test]
    procedure WhenTheOrOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
    [Test]
    procedure WhenAndOperatorMustLoadTheOperationWithTheAndValue;
    [Test]
    procedure WhenOrOperatorMustLoadTheOperationWithTheOrValue;
    [Test]
    procedure WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationAnd;
    [Test]
    procedure WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationOr;
    [Test]
    procedure WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheAndOperation;
    [Test]
    procedure WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheOrOperation;
    [Test]
    procedure WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheAndOperation;
    [Test]
    procedure WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheOrOperation;
    [Test]
    procedure WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInAndOperator;
    [Test]
    procedure WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInOrOperator;
    [Test]
    procedure WhenComparisonHelperIsNotLoadedTheFunctionIsLoadedMustReturnFalse;
    [Test]
    procedure WhenCompareAFieldWithAValueTheIsLoadedMustReturnTrue;
    [Test]
    procedure WhenCompareWithALogicalOperatorTheIsLoadedMustReturnTrue;
  end;

  [TestFixture]
  TQueryBuilderAllFieldsTest = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure InASingleClassMustLoadAllFieldsFromThatClass;
    [Test]
    procedure WhenTheClassHaveForeignKeyMustLoadAllFieldsOfAllClassesInvolved;
    [Test]
    procedure FieldsOfAnObjectCantBeLoadedInTheListOfFields;
    [Test]
    procedure TheFieldsMustBeLoadedRecursivelyInAllForeignKeys;
    [Test]
    procedure WhenTheClassIsRecursiveItselfCantRaiseAnErrorInTheExecution;
    [Test]
    procedure TheRecursivelyMustBeRespectedAndLoadAllFieldFromTheClasses;
    [Test]
    procedure WhenThePropertyIsAnArrayCantLoadTheFieldInTheList;
    [Test]
    procedure WhenAFieldIsLazyLoadingThisMustLoadInFieldList;
    [Test]
    procedure WhenFilterALazyFieldCantLoadTheFieldInTheSelect;
    [Test]
    procedure WhenTheClassHasALazyArrayMustReturnTheCountOfFieldAsExpected;
  end;

  [TestFixture]
  TQueryBuilderWhereTest = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure WhenCompareAFieldWithAnValueMustBuildTheFilterAsExpected;
    [Test]
    procedure ASimpleLogicalAndOperationMustBeGeneratedAsExpected;
    [Test]
    procedure ASimpleLogicalOrOperationMustBeGeneratedAsExpected;
    [Test]
    procedure AComposeLogicalOperationMustBeGeneratedAsExpected;
    [Test]
    procedure WhenLeftOperationIsASimpleComparisonAndRightIsALogicalOperationItHasToGenerateSQLAsExpected;
    [Test]
    procedure WhenBothOperationsAreLogicalHaveToGenerateSQLAsExpected;
    [TestCase('Between', 'qbcoBetween')]
    [TestCase('None', 'qbcoNone')]
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    [TestCase('Like', 'qbcoLike')]
    [TestCase('Null', 'qbcoNull')]
    [TestCase('Not Null', 'qbcoNotNull')]
    procedure TheComparisonOperatorsMustBeGeneratedAsExpected(Operation: TQueryBuilderComparisonOperator);
    [Test]
    procedure IfTheWhereDontFoundTheFieldMustRaiseAnError;
    [Test]
    procedure WhenExistsAJoinLoadedMustPutTheAliasOfTheTableBeforeTheFieldName;
    [Test]
    procedure WhenUsingAComposeNameMustPutTheAliasOfTheTableBeforeTheFieldName;
    [TestCase('AnsiChar', 'AnsiChar,''C''')]
    [TestCase('AnsiString', 'AnsiString,''AnsiString''')]
    [TestCase('Char', 'Char,''C''')]
    [TestCase('Class', 'Class,1234')]
    [TestCase('Enumerator', 'Enumerator,1')]
    [TestCase('Empty class', 'EmptyClass,null')]
    [TestCase('Float', 'Float,1234.456')]
    [TestCase('Date', 'Date,''2020-01-31''')]
    [TestCase('DateTime', 'DateTime,''2020-01-31T12:34:56.000''')]
    [TestCase('GUID', 'GUID,''{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}''')]
    [TestCase('Integer', 'Integer,1234')]
    [TestCase('Int64', 'Int64,1234')]
    [TestCase('String', 'String,''String''')]
    [TestCase('Time', 'Time,''12:34:56''')]
    procedure TheComparisonOfTheValuesMustOccurAsExpected(TypeToConvert, ValueToCompare: String);
    [Test]
    procedure TheLasNameInTheComposeNameMustBeTheFieldToBeFoundInAClass;
    [TestCase('Between', 'qbcoBetween')]
    [TestCase('None', 'qbcoNone')]
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    [TestCase('Null', 'qbcoNull')]
    [TestCase('Not Null', 'qbcoNotNull')]
    procedure WhenComparingFieldMustBuildTheFilterAsExpected(Operation: TQueryBuilderComparisonOperator);
    [TestCase('Between', 'qbcoBetween')]
    [TestCase('None', 'qbcoNone')]
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    [TestCase('Null', 'qbcoNull')]
    [TestCase('Not Null', 'qbcoNotNull')]
    procedure WhenComparingEnumeratorTheComparisonMustHappenAsExpected(Operation: TQueryBuilderComparisonOperator);
    [Test]
    procedure WhenTheClassIsRecursiveInItselfHasToPutTheRightAlias;
    [Test]
    procedure WhenAPropertyIsLazyLoadingCantAppearInTheFromClause;
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    procedure WhenTheComparisionWithADateMustCreateTheComparisionAsExpected(Operation: TQueryBuilderComparisonOperator);
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    procedure WhenTheComparisionWithADateTimeMustCreateTheComparisionAsExpected(Operation: TQueryBuilderComparisonOperator);
    [TestCase('Equal', 'qbcoEqual')]
    [TestCase('Not Equal', 'qbcoNotEqual')]
    [TestCase('Greater Than', 'qbcoGreaterThan')]
    [TestCase('Greater Than Or Equal', 'qbcoGreaterThanOrEqual')]
    [TestCase('Less Than', 'qbcoLessThan')]
    [TestCase('Less Than Or Equal', 'qbcoLessThanOrEqual')]
    procedure WhenTheComparisionWithATimeMustCreateTheComparisionAsExpected(Operation: TQueryBuilderComparisonOperator);
    [Test]
    procedure WhenTheClassIsInheritedMustFindTheFieldInTheBaseClass;
    [Test]
    procedure WhenBuildingTheFilterMustCheckTheFieldsJoinsIfExistsAndRaiseAnErrorIfNotFind;
    [Test]
    procedure WhenTheWhereFilterUsesAFieldFromABaseClassCantRaiseAnyError;
    [Test]
    procedure WhenUseAnLazyFieldInTheFilterCantRaiseAnyError;
    [Test]
    procedure WhenFilterringALazyFieldWithAManyValuePropertyMustRaiseError;
  end;

  [TestFixture]
  TQueryBuilderDataManipulationTest = class(TQueryBuilderBaseTest)
  private
    FLazyLoader: IMock<ILazyLoader>;
  public
    [Setup]
    procedure SetupData;
    [TearDown]
    procedure TearDownData;
    [Test]
    procedure WhenCallInsertMustStartATransactionInDatabase;
    [Test]
    procedure WhenTheInsertOccursSuccessfullyMustCommitTheTransaction;
    [Test]
    procedure TheInsertionErrorMustBeRaiseAfterTheRollbackTheTransaction;
    [Test]
    procedure WhenAnInsertErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
    [Test]
    procedure WhenCallUpdateMustStartATransactionInDatabase;
    [Test]
    procedure WhenTheUpdateOccursSuccessfullyMustCommitTheTransaction;
    [Test]
    procedure TheUpdateErrorMustRaiseAfterTheRollbackTheTransaction;
    [Test]
    procedure WhenAnUpdateErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
    [Test]
    procedure WhenCallDeleteMustStartATransactionInDatabase;
    [Test]
    procedure WhenTheDeleteOccursSuccessfullyMustCommitTheTransaction;
    [Test]
    procedure WhenAnDeleteErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
    [Test]
    procedure TheDeleteErrorMustRaiseAfterTheRollbackTheTransaction;
    [Test]
    procedure WhenCallSaveMustStartATransactionInDatabase;
    [Test]
    procedure WhenTheSaveOccursSuccessfullyMustCommitTheTransaction;
    [Test]
    procedure WhenAnSaveErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
    [Test]
    procedure TheSaveErrorMustRaiseAfterTheRollbackTheTransaction;
    [Test]
    procedure WhenInsertAnEntityMustSaveTheForeignKeysFirstAfterThisMustInsertTheEntity;
    [Test]
    procedure WhenUpdateAnEntityMustSaveTheForeignKeysFirstAfterThisMustUpdateTheEntity;
    [Test]
    procedure WhenThenObjectOfAForeignKeyIsNilCantRaiseAnyError;
    [Test]
    procedure WhenInsertAnEntityMustSaveTheManyValueAssociationsAfterInsertedTheEntity;
    [Test]
    procedure WhenUpdateAnEntityMustSaveTheManyValueAssociationsAfterUpdatedTheEntity;
    [Test]
    procedure WhenSaveAManyValueAssocitationEntityMustLoadTheParentObjectInTheChildObjects;
    [Test]
    procedure WhenSaveAManyValueAssocitationEntityMustAvoidSaveTheParentLinkOfTheChildToAvoidStackOverflow;
    [Test]
    procedure WhenInsertingAnEntityInheritedFromAnotherMustInsertTheParentClassFirst;
    [Test]
    procedure WhenSavingAnEntityInheritedFromAnotherTableCantRaiseAnyError;
    [Test]
    procedure WhenInsertingAClassMustInsertAllForeignKeysInTheClassBeforeInsertTheCurrentClass;
    [Test]
    procedure WhenUpdatingAClassMustInsertAllForeignKeysInTheClassBeforeUpdateTheCurrentClass;
    [Test]
    procedure WhenTryToUpdateAClassThatIsNotCachedHaveToRaiseAnError;
    [Test]
    procedure WhenUpdateAClassMustUpdateOnlyTheChangedFields;
    [Test]
    procedure TheValuesFromTheForeignObjectMustBeLoadedInTheCachedObject;
    [Test]
    procedure WhenInsertANewObjectThisObjectMustBeAddedToTheCache;
    [Test]
    procedure ReadOnlyFieldsCantBeUpdatedInUpdateFunction;
    [Test]
    procedure WhenNoFieldIsUpdatedCantRunAnySQL;
    [Test]
    procedure AfterUpdateAnObjectTheForeignObjectMustBeDestroyed;
    [Test]
    procedure WhenUpdateAnInheritedClassCantRaiseAccessViolationInTheDestructionProcess;
    [Test]
    procedure WhenUpdateAClassWithManyValueAssociationMustUpdateTheListOfTheObjectInTheCache;
    [Test]
    procedure WhenInsertingAInheritedClassCantRaiseErrorFromDuplicateCacheValue;
    [Test]
    procedure WhenUpdateAnObjectMustReturnTheObjectFromTheCache;
    [Test]
    procedure WhenUpdatingTheCachedObjectCantDestroyTheObject;
    [Test]
    procedure WhenUpdateAnObjectWithManyValueAssociationTheParentForeignKeyOfTheChildObjectMustBeTheReferenceToTheCacheObject;
    [Test]
    procedure AfterUpdateTheManyValueAssociationMustUpdateTheReferenceOfTheObjectInTheChildList;
    [Test]
    procedure WhenUpdateAnEntityWithAnForeignKeyInTheCacheCantRaiseAnyError;
    [Test]
    procedure WhenThePropertyIsReadOnlyTheFieldCantBeInTheInsertSQL;
    [Test]
    procedure WhenThePropertyIsReadOnlyTheFieldCantBeInTheUpdateSQL;
    [Test]
    procedure WhenSaveALoadedLazyForeignKeyMustExecuteTheUpdate;
    [Test]
    procedure WhenInsertAnObjectWithForeignKeysThatIsAlreadyInTheCacheMustUpdateTheReferenceOfTheObjectBeenInserted;
    [Test]
    procedure TheForeignKeyObjectThatInTheCacheMustBeDestroyedAfterTheInsertion;
    [Test]
    procedure TheForeignKeyObjectThatInTheCacheMustBeDestroyedAfterTheUpdate;
    [Test]
    procedure CantDestroyTheForeignKeyObjectIfItCamesFromTheCacheInTheInsertion;
    [Test]
    procedure CantDestroyTheForeignKeyObjectIfItCamesFromTheCacheInTheUpdate;
    [Test]
    procedure MustDestroyTheAnotherForeignKeysInsideAnotherObjectsInTheInsertion;
    [Test]
    procedure MustDestroyTheAnotherForeignKeysInsideAnotherObjectsInTheUpdate;
    [Test]
    procedure WhenInsertingAnObjectNotProcessedMustRemoveTheColumnFromTheInsert;
    [Test]
    procedure WhenInsertingAnObjectWithCircularReferenceCantRaiseAnyError;
    [Test]
    procedure WhenInsertingAnObjectWithCircularReferenceMustInsertTheClassesInTheOrderExpected;
    [Test]
    procedure WhenUpdatingAnObjectWithCircularReferenceCantRaiseAnyError;
    [Test]
    procedure WhenInsertAClassWithAutoGeneratedAttributeButTheKeyHasValueMustInsertThisValue;
    [Test]
    procedure WhenTheClassHasANullableFieldAndTheValueNotLoadedMustOmitTheFieldFromInsert;
    [Test]
    procedure WhenInsertingAClassMustCopyTheFieldValuesToTheNewObject;
    [Test]
    procedure WhenInsertingAManyValueClassMustUpdateTheArrayLengthOfTheDestinyClass;
    [Test]
    procedure WhenClearAForeignKeyMustUpdateTheColumnToNull;
    [Test]
    procedure WhenChangeTheValueOfAnObjectAlreadyInTheCacheMustUpdateTheFieldChanged;
    [Test]
    procedure TheForeignObjectMustUpdateTheValuesOfTheCachedObjectAfterTheUpdate;
    [Test]
    procedure AfterUpdateTheInternalObjectMustBeUpdatedToo;
    [Test]
    procedure WhenTheLazyHasntLoadedCantBeUpdatedThenValuesOfThisFields;
    [Test]
    procedure WhenUpdateAnUnloadedLazyManyValueAssociationCantRaiseAnyError;
    [Test]
    procedure WhenChangeALazyValueAndTheReferenceObjectHasntTheLazyLoadedMustUpdateTheClassAsExpected;
    [Test]
    procedure WhenTheLazyHasValueButNotLoadedCantRaiseAnyError;
    [Test]
    procedure WhenTheLazyArrayHasValueButNotLoadedCantRaiseAnyError;
    [Test]
    procedure WhenTheLazyArrayInTheCacheIsntLoadedAndTheForeignValueHasTheArrayLoadedCantRaiseAnyErrorWhenUpdate;
    [Test]
    procedure AfterInsertAnObjectInTheDatabaseMustLoadAllFieldsValuesInTheChangeManager;
    [Test]
    procedure WhenInsertAnObjectWithEmptyForeignKeyMustLoadTheChangesWithNullValue;
    [Test]
    procedure WhenInsertingAnObjectWithAnUnloadedLazyFieldCantRaisAnyError;
    [Test]
    procedure WhenInsertingAnObjectWithAnUnloadedLazyMustInsertTheLazyKeyInTheField;
    [Test]
    procedure WhenUpdateAnObjectMustUpdateTheChangeInformationOfTheObject;
    [Test]
    procedure WhenTheLazyCacheValueIsDiferentFromTheForeignKeyObjectButTheLazyIsntLoadedCantUpdateTheValue;
    [Test]
    procedure WhenInsertAnObjectWithCircularReferenceMustUpdateTheForeignKeyAfterAllObjectsAreInserted;
    [Test]
    procedure WhenSafeAClassWithPrimaryKeyIsAnEnumeratorCantRaiseAnyError;
  end;

  [TestFixture]
  TQueryBuilderOrderByTeste = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure EveryTimeTheFieldFunctionFromOrderByIsCalledMustAddTheFieldList;
    [Test]
    procedure WhenCallTheFieldFunctionMustAddTheFieldAliasToTheFieldList;
    [Test]
    procedure WhenTheFieldListIsEmptyMustReturnAnEmptySQLValue;
    [Test]
    procedure WhenTheFieldListIsNotEmptyMustReturnTheOrderByClauseWithTheFieldList;
    [Test]
    procedure WhenTheFieldIsDescendingMustLoadTheSQLAsExpected;
    [Test]
    procedure WhenCallTheFieldProcedureMustResultTheSelfOfTheOrderByClass;
  end;

  [TestFixture]
  TQueryBuilderFieldAliasTest = class(TQueryBuilderBaseTest)
  public
    [Test]
    procedure WhenCreateMustLoadThePropertyFieldNameOfTheClass;
    [Test]
    procedure WhenTheFieldNameIsSeparetedByDotMustLoadTheFieldNamesWithTheNames;
  end;

  TDatabaseTest = class(TInterfacedObject, IDatabaseConnection)
  private
    FCursor: IDatabaseCursor;
    FSQL: String;
    FOutputFields: TArray<String>;

    function ExecuteInsert(const SQL: String; const OutputFields: TArray<String>): IDatabaseCursor;
    function OpenCursor(const SQL: String): IDatabaseCursor;
    function StartTransaction: IDatabaseTransaction;

    procedure ExecuteDirect(const SQL: String);
    procedure SaveSQL(const SQL: String);
  public
    property Cursor: IDatabaseCursor read FCursor write FCursor;
    property SQL: String read FSQL;
    property OutputFields: TArray<String> read FOutputFields;
  end;

implementation

uses System.SysUtils, System.DateUtils, Delphi.ORM.Mapper, Delphi.ORM.Nullable, Delphi.Mock, Delphi.ORM.Rtti.Helper, Delphi.ORM.Lazy.Manipulator;

const
  COMPARISON_OPERATOR: array[TQueryBuilderComparisonOperator] of String = ('', '=', '<>', '>', '>=', '<', '<=', '', '', '', '');

{ TQueryBuilderTest }

procedure TQueryBuilderTest.AllSelectsMustHaveAFromClauseIfNotMustRaiseAnError;
begin
  Builder.Select;

  Assert.WillRaise(
    procedure
    begin
      Builder.GetSQL;
    end, ECommandWithoutFromClause);
end;

procedure TQueryBuilderTest.AllTheDirectForeignKeyMustBeGeneratedInTheResultingSQL;
begin
  Builder.Select.All.From<TClassWithTwoForeignKey>;

  Assert.EndsWith(' from ClassWithTwoForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id left join ClassWithPrimaryKey T3 on T1.IdAnotherClass2=T3.Id',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.IfNoCommandCalledTheSQLMustReturnEmpty;
begin
  Assert.AreEqual(EmptyStr, Builder.GetSQL);
end;

procedure TQueryBuilderTest.IfNoCommandIsCalledCantRaiseAnExceptionOfAccessViolation;
begin
  Assert.WillNotRaise(
    procedure
    begin
      Builder.GetSQL
    end, EAccessViolation);
end;

procedure TQueryBuilderTest.IfNotExistsAFilterInWhereMustReturnTheQueryWithoutWhereCommand;
begin
  Builder.Select.All.From<TMyTestClass>.Open;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderTest.IfTheAllFieldNoCalledCantRaiseAnExceptionOfAccessViolation;
begin
  Builder.Select;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.GetSQL;
    end, EAccessViolation);
end;

procedure TQueryBuilderTest.MustGenerateTheSQLFollowingTheHierarchyAsSpected;
begin
  Builder.Select.All.From<TClassHierarchy1>;

  Assert.EndsWith(
        ' from ClassHierarchy1 T1 ' +
    'left join ClassHierarchy2 T2 ' +
           'on T1.IdClass1=T2.Id ' +
    'left join ClassHierarchy1 T3 ' +
           'on T2.IdClass3=T3.Id ' +
    'left join ClassHierarchy3 T4 ' +
           'on T3.IdClass2=T4.Id ' +
    'left join ClassHierarchy1 T5 ' +
           'on T2.IdClass4=T5.Id ' +
    'left join ClassHierarchy3 T6 ' +
           'on T5.IdClass2=T6.Id ' +
    'left join ClassHierarchy3 T7 ' +
           'on T1.IdClass2=T7.Id', Builder.GetSQL);
end;

procedure TQueryBuilderTest.OnlyPublishedPropertiesMustAppearInInsertSQL;
begin
  var MyClass := TPublicClass.Create;
  MyClass.Id := 10;
  MyClass.Name := 'My name';
  MyClass.Value := 222;

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into PublicClass(Id)values(10)', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.OnlyPublishedPropertiesMustAppearInUpdateSQL;
begin
  var MyClass := TPublicClass.Create;
  MyClass.Id := 0;
  MyClass.Name := 'My name';
  MyClass.Value := 222;

  AddObjectToCache(TPublicClass.Create);

  Builder.Update(MyClass);

  Assert.IsEmpty(DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.TheClassBeingSelectedMustHaveTheAliasDefined;
begin
  Builder.Select.All.From<TMyTestClass>;

  Assert.EndsWith(' from MyTestClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderTest.TheFieldsHaveToBeGeneratedWithTheAliasOfTheRespectiveTables;
begin
  Builder.Select.All.From<TMyTestClass>;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderTest.TheForeignKeyMustBeLoadedRecursive;
begin
  Builder.Select.All.From<TClassWithForeignKeyRecursive>;

  Assert.EndsWith(' from ClassWithForeignKeyRecursive T1 left join ClassWithForeignKey T2 on T1.IdAnotherClass=T2.Id left join ClassWithPrimaryKey T3 on T2.IdAnotherClass=T3.Id',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.TheKeyFieldCantBeUpdatedInTheUpdateProcedure;
begin
  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id := 123;
  MyClass.Id2 := 456;
  MyClass.Value := 222;

  AddObjectToCache(TClassWithPrimaryKeyAttribute.Create, 456);

  Builder.Update(MyClass);

  Assert.StartsWith('update ClassWithPrimaryKeyAttribute set Id=123,Value=222', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.TheManyValueAssociationMustAvoidRecursivilyLoadTheParentClassWhenLoadingTheChildClass;
begin
  Builder.Select.All.From<TMyEntityWithManyValueAssociation>;

  Assert.EndsWith(
        ' from MyEntityWithManyValueAssociation T1 ' +
    'left join MyEntityWithManyValueAssociationChild T2 ' +
           'on T1.Id=T2.IdManyValueAssociation',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.TheManyValueAssociationMustLoadTheLinkingFieldBetweenTheClasses;
begin
  Builder.Select.All.From<TMyEntityWithManyValueAssociation>;

  Assert.IsNotNull(FBuilderAccess.Join.Links[0].Field);
end;

procedure TQueryBuilderTest.ThenForeignKeyLinkOfAnManyValueAssociationCantAppearInTheSQL;
begin
  Builder.Select.All.From<TManyValueAssociationParent>;

  Assert.EndsWith(
        ' from ManyValueAssociationParent T1 ' +
    'left join ManyValueAssociationWithThreeForeignKey T2 ' +
           'on T1.Id=T2.IdManyValueAssociationParent ' +
    'left join ManyValueAssociationParent T3 ' +
           'on T2.IdForeignKeyOne=T3.Id ' +
    'left join ManyValueAssociationParent T4 ' +
           'on T2.IdForeignKeyTwo=T4.Id',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.TheValuesReturnedInTheCursorOfTheInsertMustLoadTheFieldsOfTheClassBeenInserted;
begin
  FCursorClass.Values := [[123, 'My value', 'My sequence', 'My sequence 2']];
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  MyClass := Builder.Insert(MyClass);

  Assert.AreEqual(123, MyClass.Id);
  Assert.AreEqual('My value', MyClass.AnotherField);
end;

procedure TQueryBuilderTest.OnlyPublishedPropertiesCanAppearInSQL;
begin
  Builder.Select.All.From<TMyTestClass>;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderTest.WhenAFieldIsMarkedWithAutoGeneratedItCantBeInTheInsertSQL;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into AutoGeneratedClass(Value)values(''abc'')', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenAFilterConditionMustBuildTheSQLAsExpected;
begin
  Builder.Select.All.From<TMyTestClass>.Where(Field('Field') = 1234).Open.All;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1 where T1.Field=1234', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenCallInsertProcedureMustBuildTheSQLWithAllFieldsAndValuesFromTheClassParameter;
begin
  var MyClass := TMyTestClass.Create;
  MyClass.Field := 123;
  MyClass.Name := 'My name';
  MyClass.Value := 222.333;

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into MyTestClass(Field,Name,Value)values(123,''My name'',222.333)', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenCallOpenProcedureMustOpenTheDatabaseCursor;
begin
  Builder.Select.All.From<TMyTestClass>.Open.All;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenCallTheDeleteProcedureMustBuildTheSQLWithTheValuesOfKeysOfClass;
begin
  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id2 := 456;

  Builder.Delete(MyClass);

  Assert.AreEqual('delete from ClassWithPrimaryKeyAttribute where Id2=456', DatabaseClass.SQL);

  MyClass.Free;
end;

procedure TQueryBuilderTest.WhenCallUpdateMustBuildTheSQLWithAllPropertiesInTheObjectParameter;
begin
  var MyClass := TMyTestClass.Create;
  MyClass.Field := 123;
  MyClass.Name := 'My name';
  MyClass.Value := 222.333;

  AddObjectToCache(TMyTestClass.Create);

  Builder.Update(MyClass);

  Assert.AreEqual('update MyTestClass set Field=123,Name=''My name'',Value=222.333', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenClassHasOtherClassesLinkedToItYouHaveToGenerateTheJoinBetweenThem;
begin
  Builder.Select.All.From<TClassWithForeignKey>;

  Assert.EndsWith(' from ClassWithForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id', Builder.GetSQL);
end;

procedure TQueryBuilderTest.WhenConfiguredTheRecursivityLevelTheJoinsMustFollowTheConfiguration;
begin
  Builder.Select.RecursivityLevel(3).All.From<TClassRecursiveFirst>;

  Assert.EndsWith(
            ' from ClassRecursiveFirst T1 ' +
        'left join ClassRecursiveThird T2 ' +
               'on T1.IdRecursive=T2.Id ' +
        'left join ClassRecursiveSecond T3 ' +
               'on T2.IdRecursive=T3.Id ' +
        'left join ClassRecursiveFirst T4 ' +
               'on T3.IdRecursive=T4.Id ' +
        'left join ClassRecursiveThird T5 ' +
               'on T4.IdRecursive=T5.Id ' +
        'left join ClassRecursiveSecond T6 ' +
               'on T5.IdRecursive=T6.Id ' +
        'left join ClassRecursiveFirst T7 ' +
               'on T6.IdRecursive=T7.Id ' +
        'left join ClassRecursiveThird T8 ' +
               'on T7.IdRecursive=T8.Id ' +
        'left join ClassRecursiveSecond T9 ' +
               'on T8.IdRecursive=T9.Id ' +
        'left join ClassRecursiveFirst T10 ' +
               'on T9.IdRecursive=T10.Id',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.WhenDisableTheOptionToRemoveTheForeignKeyCantDestroyTheForiegnKeyObject;
begin
  var DestroyCalled := False;
  var MyClass := TClassWithFunction.Create;
  MyClass.Id := 123;
  var MyClassCache := TClassWithFunction.Create;
  MyClassCache.Id := 123;

  MyClass.DestroyCallFunction :=
    procedure
    begin
      DestroyCalled := True;
    end;

  AddObjectToCache(MyClassCache);

  Builder.Options := [];

  Builder.Update(MyClass);

  Assert.IsFalse(DestroyCalled);

  MyClass.Free;
end;

procedure TQueryBuilderTest.WhenDontHaveAResultingCursorCantLoadTheProperties;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  MyClass := Builder.Insert(MyClass);

  Assert.AreEqual(0, MyClass.Id);
  Assert.AreEqual(EmptyStr, MyClass.AnotherField);
end;

procedure TQueryBuilderTest.WhenGetAllFieldsOfATableMustPutThePrimaryKeyFieldInTheBeginningOfTheResultingArray;
begin
  Builder.Select.All.From<TMyEntityWithPrimaryKeyInLastField>;

  var Fields := FBuilderAccess.Fields;

  Assert.IsTrue(Fields[0].Field.InPrimaryKey);
end;

procedure TQueryBuilderTest.WhenInsertAClassWithTheAutoGeneratedAttributeMustLoadTheFieldNamesInTheArrayOfTheProcedure;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Value := 'abc';

  Builder.Insert(MyClass);

  Assert.AreEqual('Id', DatabaseClass.OutputFields[0]);
  Assert.AreEqual('AnotherField', DatabaseClass.OutputFields[1]);
end;

procedure TQueryBuilderTest.WhenInsertingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheInsert;
begin
  var MyClass := TMyEntityWithManyValueAssociation.Create;
  MyClass.Id := 12345;

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into MyEntityWithManyValueAssociation(Id)values(12345)', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenIsLoadedAJoinMustLoadTheFieldThatIsTheLinkBetweenTheClasses;
begin
  Builder.Select.All.From<TClassWithForeignKey>;

  Assert.IsNotNull(FBuilderAccess.Join.Links[0].Field);
end;

procedure TQueryBuilderTest.WhenIsMadeASelectAndAfterADeleteMustCleanUpTheSelectAndBuildTheFilterAsExpected;
begin
  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id2 := 456;

  Builder.Select.All.From<TClassWithPrimaryKeyAttribute>.Where(Field('Id') = 123);

  Builder.Delete(MyClass);

  Assert.AreEqual('delete from ClassWithPrimaryKeyAttribute where Id2=456', DatabaseClass.SQL);

  MyClass.Free;
end;

procedure TQueryBuilderTest.WhenIsMadeASelectAndAfterAnUpdateMustCleanUpTheSelectAndBuildTheFilterAsExpected;
begin
  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id := 123;
  MyClass.Id2 := 456;

  AddObjectToCache(TClassWithPrimaryKeyAttribute.Create, 456);

  Builder.Select.All.From<TClassWithPrimaryKeyAttribute>.Where(Field('Id') = 123);

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithPrimaryKeyAttribute set Id=123 where Id2=456', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenOpenOneMustFillTheClassWithTheValuesOfCursor;
begin
  FCursorClass.Values := [[123, 'My name', 123.456]];
  var Result := Builder.Select.All.From<TMyTestClass>.Open.One;

  Assert.AreEqual(123, Result.Field);

  Assert.AreEqual('My name', Result.Name);

  Assert.AreEqual<Double>(123.456, Result.Value);
end;

procedure TQueryBuilderTest.WhenSelectAllFieldsFromAClassMustPutAllThenInTheResultingSQL;
begin
  Builder.Select.All.From<TMyTestClass>;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderTest.WhenTheBeautifyQueryAndJoinMappingIsEnabledMustBuildTheQueryAsExpected;
begin
  Builder.Options := [boBeautifyQuery, boJoinMapping];

  Builder.Select.All.From<TClassWithTwoForeignKey>.Open.All;

  Assert.AreEqual(
    '   select T1.Id F1,'#13#10 +
    '          T2.Id F2,'#13#10 +
    '          T2.Value F3,'#13#10 +
    '          T3.Id F4,'#13#10 +
    '          T3.Value F5'#13#10 +
    '     from ClassWithTwoForeignKey T1'#13#10 +
    '       /* ClassWithTwoForeignKey -> ClassWithPrimaryKey (AnotherClass) */'#13#10 +
    'left join ClassWithPrimaryKey T2'#13#10 +
    '       on T1.IdAnotherClass=T2.Id'#13#10 +
    '       /* ClassWithTwoForeignKey -> ClassWithPrimaryKey (AnotherClass2) */'#13#10 +
    'left join ClassWithPrimaryKey T3'#13#10 +
    '       on T1.IdAnotherClass2=T3.Id'#13#10, DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheBeautifyQueryIsEnabledMustBuildTheQueryHasExpected;
begin
  Builder.Options := [boBeautifyQuery];

  Builder.Select.First(20).All.From<TClassWithTwoForeignKey>.Where((Field('AnotherClass.Value') = 123) and (Field('AnotherClass.Value') = 456) or (Field('AnotherClass.Value') = 789))
    .OrderBy.Field('Id').Open.All;

  Assert.AreEqual(
    '   select top 20 T1.Id F1,'#13#10 +
    '          T2.Id F2,'#13#10 +
    '          T2.Value F3,'#13#10 +
    '          T3.Id F4,'#13#10 +
    '          T3.Value F5'#13#10 +
    '     from ClassWithTwoForeignKey T1'#13#10 +
    'left join ClassWithPrimaryKey T2'#13#10 +
    '       on T1.IdAnotherClass=T2.Id'#13#10 +
    'left join ClassWithPrimaryKey T3'#13#10 +
    '       on T1.IdAnotherClass2=T3.Id'#13#10 +
    '    where ((T2.Value=123'#13#10 +
    '      and T2.Value=456)'#13#10 +
    '      or T2.Value=789)'#13#10 +
    ' order by T1.Id'#13#10, DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustInsertThenValueOfThePropertyIfNotIsNull;
begin
  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Nullable := 1234;

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into ClassWithNullableProperty(Id,Nullable)values(0,1234)', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustUpdateThenValueOfThePropertyIfNotIsNull;
begin
  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Id := 123;
  MyClass.Nullable := 456;

  AddObjectToCache(TClassWithNullableProperty.Create, 123);

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithNullableProperty set Nullable=456 where Id=123', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheClassAsAFieldWithNullableRecordMustUpdateTheValueNullInSQLIfIsNull;
begin
  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Id := 123;
  var MyClassCache := TClassWithNullableProperty.Create;
  MyClassCache.Id := 123;
  MyClassCache.Nullable := 123;

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithNullableProperty set Nullable=null where Id=123', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheClassDontHaveAnyPrimaryKeyTheDeleteMustBuildTheSQLWithoutWhereCondition;
begin
  var MyClass := TMyTestClass.Create;

  Builder.Delete(MyClass);

  Assert.AreEqual('delete from MyTestClass', DatabaseClass.SQL);

  MyClass.Free;
end;

procedure TQueryBuilderTest.WhenTheClassDontHaveThePrimaryKeyAttributeCantRaiseAException;
begin
  var MyClass := TClassOnlyPublic.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end, EAccessViolation);

  MyClass.Free;
end;

procedure TQueryBuilderTest.WhenTheClassHaveForeignKeysThatsLoadsRecursivelyCantRaiseAnError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      Builder.Select.All.From<TClassRecursiveFirst>;

      Builder.GetSQL;
    end);
end;

procedure TQueryBuilderTest.WhenTheClassHaveManyValueAssociationMustLoadTheJoinBetweenTheParentAndChildTable;
begin
  Builder.Select.All.From<TMyEntityWithManyValueAssociation>;

  Assert.EndsWith(
        ' from MyEntityWithManyValueAssociation T1 ' +
    'left join MyEntityWithManyValueAssociationChild T2 ' +
           'on T1.Id=T2.IdManyValueAssociation',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.WhenTheClassHaveThePrimaryKeyAttributeMustBuildTheWhereWithTheValuesOfFieldInTheKeyList;
begin
  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id := 123;
  MyClass.Id2 := 456;
  MyClass.Value := 222;

  AddObjectToCache(TClassWithPrimaryKeyAttribute.Create, 456);

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithPrimaryKeyAttribute set Id=123,Value=222 where Id2=456', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheClassRecursivelyItselfMoreThenOneTimeMustBuildTheSQLAsEspected;
begin
  Builder.Select.RecursivityLevel(2).All.From<TClassRecursiveItSelf>;

  Assert.EndsWith(
        ' from ClassRecursiveItself T1 ' +
    'left join ClassRecursiveItself T2 ' +
           'on T1.IdRecursive1=T2.Id ' +
    'left join ClassRecursiveItself T3 ' +
           'on T2.IdRecursive1=T3.Id ' +
    'left join ClassRecursiveItself T4 ' +
           'on T2.IdRecursive2=T4.Id ' +
    'left join ClassRecursiveItself T5 ' +
           'on T1.IdRecursive2=T5.Id ' +
    'left join ClassRecursiveItself T6 ' +
           'on T5.IdRecursive1=T6.Id ' +
    'left join ClassRecursiveItself T7 ' +
           'on T5.IdRecursive2=T7.Id',
    Builder.GetSQL);
end;

procedure TQueryBuilderTest.WhenTheJoinLinkIsFromAnInheritedClassMustMarkTheIsInheritedLinkHasTrue;
begin
  Builder.Select.All.From<TMyEntityInheritedFromSimpleClass>;

  Assert.IsTrue(FBuilderAccess.Join.Links[0].IsInheritedLink);
end;

procedure TQueryBuilderTest.WhenTheJoinMappingEnabledAnTheEntityHasAlignedJoinsMustLoadTheJoinInfoOfAllLinks;
begin
  Builder.Options := [boJoinMapping];

  Builder.Select.All.From<TClassWithForeignKeyRecursive>.Open.All;

  Assert.AreEqual(
          'select T1.Id F1,T2.Id F2,T3.Id F3,T3.Value F4 ' +
            'from ClassWithForeignKeyRecursive T1' +
              '/* ClassWithForeignKeyRecursive -> ClassWithForeignKey (AnotherClass) */' +
       'left join ClassWithForeignKey T2 ' +
              'on T1.IdAnotherClass=T2.Id' +
              '/* ClassWithForeignKeyRecursive -> ClassWithForeignKey -> ClassWithPrimaryKey (AnotherClass) */' +
       'left join ClassWithPrimaryKey T3 ' +
              'on T2.IdAnotherClass=T3.Id', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTheJoinMappingEnabledMustLoadTheJoinInfoOnQueryComments;
begin
  Builder.Options := [boJoinMapping];

  Builder.Select.All.From<TClassWithTwoForeignKey>.Open.All;

  Assert.AreEqual(
       'select T1.Id F1,T2.Id F2,T2.Value F3,T3.Id F4,T3.Value F5 ' +
         'from ClassWithTwoForeignKey T1' +
              '/* ClassWithTwoForeignKey -> ClassWithPrimaryKey (AnotherClass) */' +
    'left join ClassWithPrimaryKey T2 ' +
           'on T1.IdAnotherClass=T2.Id' +
              '/* ClassWithTwoForeignKey -> ClassWithPrimaryKey (AnotherClass2) */' +
    'left join ClassWithPrimaryKey T3 ' +
           'on T1.IdAnotherClass2=T3.Id', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTryToSaveAnEntityWithThePrimaryKeyEmptyMustInsertTheEntity;
begin
  var Obj := TMyEntityWithPrimaryKey.Create;

  Builder.Save(Obj);

  Assert.AreEqual('insert into MyEntityWithPrimaryKey(Id)values(0)', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenTryToSaveAnEntityWithThePrimaryKeyFilledMustUpdateTheEntity;
begin
  var Obj := TMyEntityWithPrimaryKey.Create;
  Obj.Value := 12345;
  var ObjCache := TMyEntityWithPrimaryKey.Create;
  ObjCache.Value := 12345;
  ObjCache.Id := 123;

  AddObjectToCache(ObjCache);

  Builder.Save(Obj);

  Assert.AreEqual('update MyEntityWithPrimaryKey set Id=0 where Value=12345', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenUpdateAnEntityWithoutPrimaryKeyMustUpdateAllRecordFromTable;
begin
  var Obj := TMyTestClass.Create;
  var ObjCache := TMyTestClass.Create;
  ObjCache.Field := 1;
  ObjCache.Name := 'Name';
  ObjCache.Value := 2;

  AddObjectToCache(ObjCache);

  Builder.Save(Obj);

  Assert.AreEqual('update MyTestClass set Field=0,Name='''',Value=0', DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenUpdatingAClassWithManyValueAssociationCantPutThisTypeOfFieldInTheUpdateList;
begin
  var MyClass := TMyEntityWithManyValueAssociation.Create;
  MyClass.Id := 12345;

  AddObjectToCache(TMyEntityWithManyValueAssociation.Create, 12345);

  Builder.Update(MyClass);

  Assert.IsEmpty(DatabaseClass.SQL);
end;

procedure TQueryBuilderTest.WhenUseTheOrderByClauseMustLoadTheSQLHasExpected;
begin
  Builder.Select.All.From<TMyTestClass>.OrderBy.Field('Field').Open.All;

  Assert.AreEqual('select T1.Field F1,T1.Name F2,T1.Value F3 from MyTestClass T1 order by T1.Field', DatabaseClass.SQL);
end;

{ TDatabaseTest }

procedure TDatabaseTest.ExecuteDirect(const SQL: String);
begin
  SaveSQL(SQL);
end;

function TDatabaseTest.ExecuteInsert(const SQL: String; const OutputFields: TArray<String>): IDatabaseCursor;
begin
  FOutputFields := OutputFields;
  Result := OpenCursor(SQL);
end;

function TDatabaseTest.OpenCursor(const SQL: String): IDatabaseCursor;
begin
  Result := FCursor;

  SaveSQL(SQL);
end;

procedure TDatabaseTest.SaveSQL(const SQL: String);
begin
  if not FSQL.IsEmpty then
    FSQL := FSQL + #13#10;

  FSQL := FSQL + SQL;
end;

function TDatabaseTest.StartTransaction: IDatabaseTransaction;
begin
  Result := TMock.CreateInterface<IDatabaseTransaction>(True).Instance;
end;

{ TQueryBuilderAllFieldsTest }

procedure TQueryBuilderAllFieldsTest.FieldsOfAnObjectCantBeLoadedInTheListOfFields;
begin
  Builder.Select.All.From<TClassWithTwoForeignKey>;

  for var Field in FBuilderAccess.Fields do
    Assert.IsFalse(Field.Field.PropertyInfo.PropertyType.InheritsFrom(TRttiStructuredType));
end;

procedure TQueryBuilderAllFieldsTest.InASingleClassMustLoadAllFieldsFromThatClass;
begin
  Builder.Select.All.From<TMyTestClass>;

  Assert.AreEqual<Integer>(3, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.TheFieldsMustBeLoadedRecursivelyInAllForeignKeys;
begin
  Builder.Select.All.From<TClassWithForeignKeyRecursive>;

  Assert.AreEqual<Integer>(4, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.TheRecursivelyMustBeRespectedAndLoadAllFieldFromTheClasses;
begin
  Builder.Select.RecursivityLevel(3).All.From<TClassRecursiveFirst>;

  Assert.AreEqual<Integer>(10, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.WhenAFieldIsLazyLoadingThisMustLoadInFieldList;
begin
  Builder.Select.All.From<TLazyClass>;

  Assert.AreEqual<Integer>(2, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.WhenFilterALazyFieldCantLoadTheFieldInTheSelect;
begin
  Builder.Select.All.From<TLazyClass>.Where(Field('Lazy.Name') = 'abc');

  Assert.AreEqual<Integer>(2, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.WhenTheClassHasALazyArrayMustReturnTheCountOfFieldAsExpected;
begin
  Builder.Select.All.From<TLazyArrayClass>;

  Assert.AreEqual<Integer>(2, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.WhenTheClassHaveForeignKeyMustLoadAllFieldsOfAllClassesInvolved;
begin
  Builder.Select.All.From<TClassWithTwoForeignKey>;

  Assert.AreEqual<Integer>(5, Length(FBuilderAccess.Fields));
end;

procedure TQueryBuilderAllFieldsTest.WhenTheClassIsRecursiveItselfCantRaiseAnErrorInTheExecution;
begin
  Builder.Select.All.From<TClassRecursiveFirst>;

  Assert.WillNotRaise(
    procedure
    begin
      FBuilderAccess.Fields;
    end);
end;

procedure TQueryBuilderAllFieldsTest.WhenThePropertyIsAnArrayCantLoadTheFieldInTheList;
begin
  Builder.Select.All.From<TMyEntityWithManyValueAssociation>;

  Assert.AreEqual<Integer>(2, Length(FBuilderAccess.Fields));
end;

{ TQueryBuilderSelectTest }

procedure TQueryBuilderSelectTest.WhenFillTheFirstRecordsMustBuildTheSQLAsExpectedForSQLServer;
begin
  Builder.Select.First(10).All.From<TClassWithForeignKey>;

  Assert.AreEqual('select top 10 T1.Id F1,T2.Id F2,T2.Value F3 from ClassWithForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id', Builder.GetSQL);
end;

procedure TQueryBuilderSelectTest.WhenFillTheFirstRecordsMustLoadThePropertyWithThePassedValue;
begin
  var Select := TQueryBuilderSelect.Create(Builder);

  Assert.AreEqual(20, Select.First(20).FirstRecords);

  Select.Free;
end;

procedure TQueryBuilderSelectTest.WhenIsNotDefinedTheRecursivityLevelMustBeOneTheDefaultValue;
begin
  var Select := TQueryBuilderSelect.Create(Builder);

  Assert.AreEqual(1, Select.RecursivityLevelValue);

  Select.Free;
end;

procedure TQueryBuilderSelectTest.WhenSelectingATableAsAParameterMustUseThisParameterAndNotTryingToFindTheGenericTable;
begin
  Assert.WillNotRaise(
    procedure
    begin
      Builder.Select.All.From<TObject>(TMapper.Default.FindTable(TClassWithForeignKey)).Open;
    end);
end;

procedure TQueryBuilderSelectTest.WhenTheClassHaveForeignKeyMustBuildTheSQLWithTheAliasOfTheJoinMapped;
begin
  Builder.Select.All.From<TClassWithForeignKey>;

  Assert.AreEqual('select T1.Id F1,T2.Id F2,T2.Value F3 from ClassWithForeignKey T1 left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id', Builder.GetSQL);
end;

{ TQueryBuilderComparisonTest }

procedure TQueryBuilderComparisonTest.WhenCallTheFieldFuncitionMustLoadTheFieldNameInTheLeftOperator;
begin
  var Comparison := Field('MyField');

  Assert.AreEqual('MyField', Comparison.Comparison.Field.FieldNames[0]);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenCompareAFieldWithAValueTheIsLoadedMustReturnTrue;
begin
  var Comparison := Field('MyField') = True;

  Assert.IsTrue(Comparison.IsLoaded);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenCompareTheFieldWithAnIntegerValueMustLoadTheComparisonAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Field := Field('MyField');
  var Value := 1234;

  case Operation of
    qbcoBetween: Comparison := Field.Between<Integer>(123, 456);
    qbcoEqual: Comparison := Field = Value;
    qbcoGreaterThan: Comparison := Field > Value;
    qbcoGreaterThanOrEqual: Comparison := Field >= Value;
    qbcoLessThan: Comparison := Field < Value;
    qbcoLessThanOrEqual: Comparison := Field <= Value;
    qbcoLike: Comparison := Field.Like('abc');
    qbcoNotEqual: Comparison := Field <> Value;
    qbcoNotNull: Comparison := Field <> NULL;
    qbcoNull: Comparison := Field = NULL;
    else raise Exception.Create('Not implemented');
  end;

  Assert.AreEqual('MyField', Comparison.Comparison.Left.Field.FieldNames[0]);
  Assert.AreEqual(Operation, Comparison.Comparison.Comparison);

  case Operation of
    qbcoNull,
    qbcoNotNull: Assert.AreEqual(TNullEnumerator.NULL, Comparison.Comparison.Right.Value.AsType<TNullEnumerator>);
    qbcoBetween:
    begin
      var Values := Comparison.Comparison.Right.Value.AsType<TArray<Integer>>;
      Assert.AreEqual(123, Values[0]);
      Assert.AreEqual(456, Values[1]);
    end;
    qbcoLike: Assert.AreEqual('abc', Comparison.Comparison.Right.Value.AsString);
    else Assert.AreEqual(Value, Comparison.Comparison.Right.Value.AsInteger);
  end;

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenCompareTheFieldWithAStringValueMustLoadTheComparisonAsExpected;
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Value := 'abc';

  for var Operation := Low(TQueryBuilderComparisonOperator) to High(TQueryBuilderComparisonOperator) do
  begin
    Comparison := Field('MyField');

    case Operation of
      qbcoEqual: Comparison := Comparison = Value;
      qbcoGreaterThan: Comparison := Comparison > Value;
      qbcoGreaterThanOrEqual: Comparison := Comparison >= Value;
      qbcoLessThan: Comparison := Comparison < Value;
      qbcoLessThanOrEqual: Comparison := Comparison <= Value;
      qbcoNone, qbcoNull, qbcoNotNull, qbcoBetween, qbcoLike:
      begin
        Comparison.Comparison.Free;

        Continue;
      end;
      qbcoNotEqual: Comparison := Comparison <> Value;
      else raise Exception.Create('Not implemented');
    end;

    Assert.AreEqual('MyField', Comparison.Comparison.Left.Field.FieldNames[0]);
    Assert.AreEqual(Operation, Comparison.Comparison.Comparison);
    Assert.AreEqual(Value, Comparison.Comparison.Right.Value.AsString);

    Comparison.Comparison.Free;
  end;
end;

procedure TQueryBuilderComparisonTest.WhenCompareWithALogicalOperatorTheIsLoadedMustReturnTrue;
begin
  var Comparison := (Field('MyField') = True) and (Field('MyField') = True);

  Assert.IsTrue(Comparison.IsLoaded);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenComparisonHelperIsNotLoadedTheFunctionIsLoadedMustReturnFalse;
begin
  var Comparison := TQueryBuilderComparisonHelper.Create;

  Assert.IsFalse(Comparison.IsLoaded);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithFilledComparisons;
begin
  var Comparison := (Field('F1') = 'abc') and (Field('F2') = 'abc');

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorAndHaveToGenerateALogicalOperationWithOperationAndFilled;
begin
  var Comparison := (Field('F1') = 'abc') and (Field('F2') = 'abc');

  Assert.AreEqual(qloAnd, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithFilledComparisons;
begin
  var Comparison := (Field('F1') = 'abc') or (Field('F2') = 'abc');

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenToUseTheOperatorOrHaveToGenerateALogicalOperationWithOperationOrFilled;
begin
  var Comparison := (Field('F1') = 'abc') or (Field('F2') = 'abc');

  Assert.AreEqual(qloOr, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenAndOperatorMustLoadTheOperationWithTheAndValue;
begin
  var Comparison := (Field('MyField') = 'abc') and (Field('MyField2') = 'abc');

  Assert.AreEqual(qloAnd, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInAndOperator;
begin
  var Comparison := ((Field('F1') = 1) and (Field('F2') = 2)) and ((Field('F3') = 3) and (Field('F4') = 4));

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Left.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Comparison.Right.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F4', Comparison.Comparison.Right.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenBothOperatorAreLogicalMustCreateANewLogicalOperationWithBothValuesInOrOperator;
begin
  var Comparison := ((Field('F1') = 1) or (Field('F2') = 2)) or ((Field('F3') = 3) or (Field('F4') = 4));

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Left.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Comparison.Right.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F4', Comparison.Comparison.Right.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationAnd;
begin
  var Comparison := (Field('F1') = 1) and (Field('F2') = 2);

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenForASimpleComparisonYouHaveToAssembleTheLogicalOperatorWithComparisonTypeValuesInOperationOr;
begin
  var Comparison := (Field('F1') = 1) or (Field('F2') = 2);

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheAndOperation;
begin
  var Comparison := (Field('F1') = 1) and ((Field('F2') = 2) and (Field('F3') = 3));

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Right.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Comparison.Right.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenOperationLeftIsAComparisonAndRightIsALogicalOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheValueOfComparisonAndRightWithTheLogicalOperationInTheOrOperation;
begin
  var Comparison := (Field('F1') = 1) or ((Field('F2') = 2) or (Field('F3') = 3));

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Right.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Comparison.Right.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheAndOperation;
begin
  var Comparison := ((Field('F1') = 1) and (Field('F2') = 2)) and (Field('F3') = 3);

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Left.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloAnd, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenOperationLeftIsALogicalAndRightIsAComparisonOperationHaveToAssembleANewLogicalOperatorWithTheLeftWithTheLogicalOperationAndRightWithTheValueOfComparisonInTheOrOperation;
begin
  var Comparison := ((Field('F1') = 1) or (Field('F2') = 2)) or (Field('F3') = 3);

  Assert.AreEqual('F1', Comparison.Comparison.Left.Left.Left.Field.FieldNames[0]);

  Assert.AreEqual('F2', Comparison.Comparison.Left.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual('F3', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Assert.AreEqual(qloOr, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenOrOperatorMustLoadTheOperationWithTheOrValue;
begin
  var Comparison := (Field('MyField') = 'abc') or (Field('MyField2') = 'abc');

  Assert.AreEqual(qloOr, Comparison.Comparison.Logical);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenTheAndOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
begin
  var Comparison := (Field('MyField') = 'abc') and (Field('MyField2') = 'abc');

  Assert.AreEqual('MyField', Comparison.Comparison.Left.Left.Field.FieldNames[0]);
  Assert.AreEqual('MyField2', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Comparison.Comparison.Free;
end;

procedure TQueryBuilderComparisonTest.WhenTheOrOperatorIsCalledMustLoadTheLeftFieldWithTheLeftValueComparisonAndTheRightFieldWithTheRightValueComparision;
begin
  var Comparison := (Field('MyField') = 'abc') or (Field('MyField2') = 'abc');

  Assert.AreEqual('MyField', Comparison.Comparison.Left.Left.Field.FieldNames[0]);
  Assert.AreEqual('MyField2', Comparison.Comparison.Right.Left.Field.FieldNames[0]);

  Comparison.Comparison.Free;
end;

{ TQueryBuilderWhereTest }

procedure TQueryBuilderWhereTest.AComposeLogicalOperationMustBeGeneratedAsExpected;
begin
  Builder.Select.All.From<TWhereClassTest>.Where((Field('Field1') = 1) and (Field('Field2') = 2) or (Field('Field3') = 3));

  Assert.EndsWith(' where ((T1.Field1=1 and T1.Field2=2) or T1.Field3=3)', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.ASimpleLogicalAndOperationMustBeGeneratedAsExpected;
begin
  Builder.Select.All.From<TWhereClassTest>.Where((Field('Field1') = 1111) and (Field('Field2') = 222));

  Assert.EndsWith(' where (T1.Field1=1111 and T1.Field2=222)', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.ASimpleLogicalOrOperationMustBeGeneratedAsExpected;
begin
  Builder.Select.All.From<TWhereClassTest>.Where((Field('Field1') = 1111) or (Field('Field2') = 222));

  Assert.EndsWith(' where (T1.Field1=1111 or T1.Field2=222)', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.IfTheWhereDontFoundTheFieldMustRaiseAnError;
begin
  Assert.WillRaise(
    procedure
    begin
      Builder.Select.All.From<TWhereClassTest>.Where(Field('DontExists') = 1234);
    end, EFieldNotFoundInTable);
end;

procedure TQueryBuilderWhereTest.TheComparisonOfTheValuesMustOccurAsExpected(TypeToConvert, ValueToCompare: String);
begin
  var Value: TValue;
  var Prefix := EmptyStr;

  if TypeToConvert = 'AnsiChar' then
    Value := TValue.From(AnsiChar('C'))
  else if TypeToConvert = 'AnsiString' then
    Value := TValue.From(AnsiString('AnsiString'))
  else if TypeToConvert = 'Char' then
    Value := TValue.From(Char('C'))
  else if TypeToConvert = 'Class' then
  begin
    var Obj := TMyEntityWithPrimaryKey.Create;
    Obj.Value := 1234;
    Prefix := 'Id';
    Value := Obj;
  end
  else if TypeToConvert = 'EmptyClass' then
  begin
    Prefix := 'Id';
    Value := TValue.From<TObject>(nil);
  end
  else if TypeToConvert = 'Enumerator' then
    Value := TValue.From(Enum2)
  else if TypeToConvert = 'Float' then
    Value := 1234.456
  else if TypeToConvert = 'Date' then
    Value := TValue.From(EncodeDate(2020, 1, 31))
  else if TypeToConvert = 'DateTime' then
    Value := TValue.From(EncodeDateTime(2020, 1, 31, 12, 34, 56, 0))
  else if TypeToConvert = 'GUID' then
    Value := TValue.From(StringToGUID('{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}'))
  else if TypeToConvert = 'Integer' then
    Value := 1234
  else if TypeToConvert = 'Int64' then
    Value := Int64(1234)
  else if TypeToConvert = 'String' then
    Value := 'String'
  else if TypeToConvert = 'Time' then
    Value := TValue.From(TTime(EncodeTime(12, 34, 56, 0)))
  else
    raise Exception.Create('Test not mapped!');

  Builder.Select.All.From<TMyEntityWithAllTypeOfFields>.Where(Field(TypeToConvert) = Value);

  Assert.EndsWith(Format(' where T1.%s%s=%s', [Prefix, TypeToConvert, ValueToCompare]), Builder.GetSQL);

  if Value.IsObject then
    Value.AsObject.Free;
end;

procedure TQueryBuilderWhereTest.TheComparisonOperatorsMustBeGeneratedAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Field := Field('MyField');
  var ValueString := String('1');

  case Operation of
    qbcoBetween:
    begin
      Comparison := Field.Between<Integer>(123, 456);
      ValueString := ' between 123 and 456';
    end;
    qbcoEqual: Comparison := Field = 1;
    qbcoGreaterThan: Comparison := Field > 1;
    qbcoGreaterThanOrEqual: Comparison := Field >= 1;
    qbcoLessThan: Comparison := Field < 1;
    qbcoLessThanOrEqual: Comparison := Field <= 1;
    qbcoLike:
    begin
      Comparison := Field.Like('%like operator%');
      ValueString := ' like ''%like operator%''';
    end;
    qbcoNone:
    begin
      Field.Comparison.Free;

      Assert.IsTrue(True);
    end;
    qbcoNotEqual: Comparison := Field <> 1;
    qbcoNotNull:
    begin
      Comparison := Field <> NULL;
      ValueString := ' is not null';
    end;
    qbcoNull:
    begin
      Comparison := Field = NULL;
      ValueString := ' is null';
    end;
    else raise Exception.Create('Test not implemented');
  end;

  if Operation <> qbcoNone then
    Assert.AreEqual(Format(' where T1.MyField%s%s', [COMPARISON_OPERATOR[Operation], ValueString]), Builder.Select.All.From<TWhereClassTest>.Where(Comparison).GetSQL);
end;

procedure TQueryBuilderWhereTest.TheLasNameInTheComposeNameMustBeTheFieldToBeFoundInAClass;
begin
  Builder.Select.All.From<TWhereClassTest>.Where(Field('Where') = 1);

  Assert.EndsWith(' where T1.IdWhere=1', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenAPropertyIsLazyLoadingCantAppearInTheFromClause;
begin
  Builder.Select.All.From<TLazyClass>;

  Assert.EndsWith(' from LazyClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenBothOperationsAreLogicalHaveToGenerateSQLAsExpected;
begin
  Builder.Select.All.From<TWhereClassTest>.Where((Field('Field1') = 1) and (Field('Field2') = 2) or (Field('Field3') = 3) and (Field('Field4') = 4));

  Assert.EndsWith(' where ((T1.Field1=1 and T1.Field2=2) or (T1.Field3=3 and T1.Field4=4))', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenBuildingTheFilterMustCheckTheFieldsJoinsIfExistsAndRaiseAnErrorIfNotFind;
begin
  Assert.WillRaiseWithMessage(
    procedure
    begin
      Builder.Select.RecursivityLevel(5).All.From<TMyTestClass>.Where(Field('NotExitst.Field') = 'abc');
    end, EFieldNotFoundInTable, 'Field "NotExitst" not found in current table!');
end;

procedure TQueryBuilderWhereTest.WhenCompareAFieldWithAnValueMustBuildTheFilterAsExpected;
begin
  Builder.Select.All.From<TWhereClassTest>.Where(Field('Value') = 1234);

  Assert.EndsWith(' where T1.Value=1234', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenComparingEnumeratorTheComparisonMustHappenAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Field := Field('Enumerator');

  case Operation of
    qbcoEqual: Comparison := Field = Enum2;
    qbcoGreaterThan: Comparison := Field > Enum2;
    qbcoGreaterThanOrEqual: Comparison := Field >= Enum2;
    qbcoLessThan: Comparison := Field < Enum2;
    qbcoLessThanOrEqual: Comparison := Field <= Enum2;
    qbcoNotEqual: Comparison := Field <> Enum2;
    qbcoNone, qbcoNull, qbcoNotNull, qbcoBetween:
    begin
      Field.Comparison.Free;

      Assert.IsTrue(True);

      Exit;
    end;
    else raise Exception.Create('Test not implemented');
  end;

  Builder.Select.All.From<TMyEntityWithAllTypeOfFields>.Where(Comparison);

  Assert.EndsWith(Format(' where T1.Enumerator%s1', [COMPARISON_OPERATOR[Operation]]), Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenComparingFieldMustBuildTheFilterAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var FieldLeft := Field('MyField');
  var FieldValue := Field('Value');

  case Operation of
    qbcoEqual: Comparison := FieldLeft = FieldValue;
    qbcoGreaterThan: Comparison := FieldLeft > FieldValue;
    qbcoGreaterThanOrEqual: Comparison := FieldLeft >= FieldValue;
    qbcoLessThan: Comparison := FieldLeft < FieldValue;
    qbcoLessThanOrEqual: Comparison := FieldLeft <= FieldValue;
    qbcoNotEqual: Comparison := FieldLeft <> FieldValue;
    qbcoNone, qbcoNull, qbcoNotNull, qbcoBetween:
    begin
      FieldLeft.Comparison.Free;
      FieldValue.Comparison.Free;

      Assert.IsTrue(True);

      Exit;
    end;
    else raise Exception.Create('Test not implemented');
  end;

  Assert.AreEqual(Format(' where T1.MyField%sT1.Value', [COMPARISON_OPERATOR[Operation]]), Builder.Select.All.From<TWhereClassTest>.Where(Comparison).GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenExistsAJoinLoadedMustPutTheAliasOfTheTableBeforeTheFieldName;
begin
  Builder.Select.All.From<TWhereClassTest>.Where(Field('Field1') = 1);

  Assert.EndsWith(' where T1.Field1=1', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenFilterringALazyFieldWithAManyValuePropertyMustRaiseError;
begin
  Assert.WillRaise(
    procedure
    begin
      Builder.Select.All.From<TFilterClass>.Where(Field('LazyFilterClass.Many.Childs.Id') = 123);
    end, ECantFilterManyValueAssociation);
end;

procedure TQueryBuilderWhereTest.WhenLeftOperationIsASimpleComparisonAndRightIsALogicalOperationItHasToGenerateSQLAsExpected;
begin
  Builder.Select.All.From<TWhereClassTest>.Where((Field('Field1') = 1) and ((Field('Field2') = 2) or (Field('Field3') = 3)));

  Assert.EndsWith(' where (T1.Field1=1 and (T1.Field2=2 or T1.Field3=3))', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenTheClassIsInheritedMustFindTheFieldInTheBaseClass;
begin
  Builder.Select.All.From<TMyEntityInheritedFromSimpleClass>.Where(Field('BaseProperty') = 'abc');

  Assert.EndsWith(' where T2.BaseProperty=''abc''', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenTheClassIsRecursiveInItselfHasToPutTheRightAlias;
begin
  Builder.Select.RecursivityLevel(5).All.From<TClassRecursiveItSelf>.Where(Field('Recursive1.Recursive1.Recursive1.Recursive1.Recursive1') = 1);

  Assert.EndsWith(' where T5.IdRecursive1=1', Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenTheComparisionWithADateMustCreateTheComparisionAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Field := Field('Date');
  var DateVar: TDate := EncodeDate(2021, 01, 01);

  case Operation of
    qbcoEqual: Comparison := Field = DateVar;
    qbcoGreaterThan: Comparison := Field > DateVar;
    qbcoGreaterThanOrEqual: Comparison := Field >= DateVar;
    qbcoLessThan: Comparison := Field < DateVar;
    qbcoLessThanOrEqual: Comparison := Field <= DateVar;
    qbcoNotEqual: Comparison := Field <> DateVar;
    else raise Exception.Create('Test not implemented');
  end;

  Builder.Select.All.From<TMyEntityWithAllTypeOfFields>.Where(Comparison);

  Assert.EndsWith(Format(' where T1.Date%s''2021-01-01''', [COMPARISON_OPERATOR[Operation]]), Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenTheComparisionWithADateTimeMustCreateTheComparisionAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Field := Field('DateTime');
  var DateVar: TDateTime := EncodeDateTime(2021, 01, 01, 12, 34, 56, 0);

  case Operation of
    qbcoEqual: Comparison := Field = DateVar;
    qbcoGreaterThan: Comparison := Field > DateVar;
    qbcoGreaterThanOrEqual: Comparison := Field >= DateVar;
    qbcoLessThan: Comparison := Field < DateVar;
    qbcoLessThanOrEqual: Comparison := Field <= DateVar;
    qbcoNotEqual: Comparison := Field <> DateVar;
    else raise Exception.Create('Test not implemented');
  end;

  Builder.Select.All.From<TMyEntityWithAllTypeOfFields>.Where(Comparison);

  Assert.EndsWith(Format(' where T1.DateTime%s''2021-01-01T12:34:56.000''', [COMPARISON_OPERATOR[Operation]]), Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenTheComparisionWithATimeMustCreateTheComparisionAsExpected(Operation: TQueryBuilderComparisonOperator);
begin
  var Comparison: TQueryBuilderComparisonHelper;
  var Field := Field('Time');
  var DateVar: TTime := EncodeTime(12, 34, 56, 0);

  case Operation of
    qbcoEqual: Comparison := Field = DateVar;
    qbcoGreaterThan: Comparison := Field > DateVar;
    qbcoGreaterThanOrEqual: Comparison := Field >= DateVar;
    qbcoLessThan: Comparison := Field < DateVar;
    qbcoLessThanOrEqual: Comparison := Field <= DateVar;
    qbcoNotEqual: Comparison := Field <> DateVar;
    else raise Exception.Create('Test not implemented');
  end;

  Builder.Select.All.From<TMyEntityWithAllTypeOfFields>.Where(Comparison);

  Assert.EndsWith(Format(' where T1.Time%s''12:34:56''', [COMPARISON_OPERATOR[Operation]]), Builder.GetSQL);
end;

procedure TQueryBuilderWhereTest.WhenTheWhereFilterUsesAFieldFromABaseClassCantRaiseAnyError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      Builder.Select.All.From<TMyClassWithForeignKeyInherited>.Where(Field('MyField.AnotherValues.Id') = 'abc');
    end);
end;

procedure TQueryBuilderWhereTest.WhenUseAnLazyFieldInTheFilterCantRaiseAnyError;
begin
  Assert.WillNotRaise(
    procedure
    begin
      Builder.Select.All.From<TLazyClass>.Where(Field('Lazy.Name') = 'abc');
    end);
end;

procedure TQueryBuilderWhereTest.WhenUsingAComposeNameMustPutTheAliasOfTheTableBeforeTheFieldName;
begin
  Builder.Select.RecursivityLevel(2).All.From<TWhereClassTest>.Where(Field('Where.Class1.Class3.Id') = 1);
  Builder.Options := [boJoinMapping, boBeautifyQuery];

  Assert.EndsWith(' where T4.Id=1', Builder.GetSQL);
end;

{ TQueryBuilderDataManipulationTest }

procedure TQueryBuilderDataManipulationTest.AfterInsertAnObjectInTheDatabaseMustLoadAllFieldsValuesInTheChangeManager;
begin
  FCursorClass.Values := [[123456]];
  var MyClass := TMyEntity.Create;
  MyClass.Name := 'MyName';
  MyClass.Value := 123456;
  var Table := TMapper.Default.FindTable(MyClass.ClassType);

  Builder.Insert(MyClass);

  Assert.AreEqual('123456', FCache.ChangeManager.Changes[MyClass][Table.Field['Id']]);
  Assert.AreEqual('''MyName''', FCache.ChangeManager.Changes[MyClass][Table.Field['Name']]);
  Assert.AreEqual('123456', FCache.ChangeManager.Changes[MyClass][Table.Field['Value']]);
end;

procedure TQueryBuilderDataManipulationTest.AfterUpdateAnObjectTheForeignObjectMustBeDestroyed;
begin
  var DestroyCalled := False;
  var MyClass := TClassWithFunction.Create;
  MyClass.Id := 123;
  var MyClassCache := TClassWithFunction.Create;
  MyClassCache.Id := 123;

  MyClass.DestroyCallFunction :=
    procedure
    begin
      DestroyCalled := True;
    end;

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.IsTrue(DestroyCalled);
end;

procedure TQueryBuilderDataManipulationTest.AfterUpdateTheInternalObjectMustBeUpdatedToo;
begin
  var Cache := TClassWithPrimaryKey.Create;
  Cache.Id := 123;
  Cache.Value := 456;

  var InternalObject := AddObjectToCache(Cache);

  var MyClass := TClassWithPrimaryKey.Create;
  MyClass.Id := 123;
  MyClass.Value := 789;

  Builder.Update(MyClass);

  Assert.AreEqual(789, InternalObject.Value);
end;

procedure TQueryBuilderDataManipulationTest.AfterUpdateTheManyValueAssociationMustUpdateTheReferenceOfTheObjectInTheChildList;
begin
  var MyChild := TManyValueChild.Create;
  MyChild.Id := 123;
  var MyClass := TManyValueParent.Create;
  MyClass.Id := 123;
  MyClass.Childs := [MyChild];
  var MyClassCache := TManyValueParent.Create;
  var MyChildCache := TManyValueChild.Create;

  AddObjectToCache(MyClassCache, 123);

  AddObjectToCache(MyChildCache, 123);

  Builder.Update(MyClass);

  Assert.AreEqual<Pointer>(MyChildCache, MyClassCache.Childs[0]);
end;

procedure TQueryBuilderDataManipulationTest.CantDestroyTheForeignKeyObjectIfItCamesFromTheCacheInTheInsertion;
begin
  var AnotherClass := TClassWithFunction.Create;
  AnotherClass.Id := 123;
  var Destroyed := False;
  var MyClass := TClassWithForeignKeyToClassWithFunction.Create;
  MyClass.ForeignKey := AnotherClass;

  AnotherClass.DestroyCallFunction :=
    procedure
    begin
      Destroyed := True;
    end;

  AddObjectToCache(AnotherClass);

  Builder.Insert(MyClass);

  Assert.IsFalse(Destroyed);
end;

procedure TQueryBuilderDataManipulationTest.CantDestroyTheForeignKeyObjectIfItCamesFromTheCacheInTheUpdate;
begin
  var AnotherClass := TClassWithFunction.Create;
  AnotherClass.Id := 123;
  var Destroyed := False;
  var MyClass := TClassWithForeignKeyToClassWithFunction.Create;
  MyClass.Id := 123;
  MyClass.ForeignKey := AnotherClass;

  AnotherClass.DestroyCallFunction :=
    procedure
    begin
      Destroyed := True;
    end;

  AddObjectToCache(AnotherClass);

  AddObjectToCache(MyClass);

  Builder.Update(MyClass);

  Assert.IsFalse(Destroyed);
end;

procedure TQueryBuilderDataManipulationTest.MustDestroyTheAnotherForeignKeysInsideAnotherObjectsInTheInsertion;
begin
  var Destroyed := False;
  var MyClass := TClassWithForeignKeyToClassTest.Create;
  MyClass.ForeignKey := TClassWithForeignKeyToClassWithFunction.Create;
  MyClass.ForeignKey.Id := 123;
  MyClass.ForeignKey.ForeignKey := TClassWithFunction.Create;
  MyClass.ForeignKey.ForeignKey.Id := 123;
  MyClass.ForeignKey.ForeignKey.DestroyCallFunction :=
    procedure
    begin
      Destroyed := True;
    end;

  AddObjectToCache(TClassWithForeignKeyToClassWithFunction.Create, 123);

  AddObjectToCache(TClassWithFunction.Create, 123);

  Builder.Insert(MyClass);

  Assert.IsTrue(Destroyed);
end;

procedure TQueryBuilderDataManipulationTest.MustDestroyTheAnotherForeignKeysInsideAnotherObjectsInTheUpdate;
begin
  var Destroyed := False;
  var MyClass := TClassWithForeignKeyToClassTest.Create;
  MyClass.Id := 123;
  MyClass.ForeignKey := TClassWithForeignKeyToClassWithFunction.Create;
  MyClass.ForeignKey.Id := 123;
  MyClass.ForeignKey.ForeignKey := TClassWithFunction.Create;
  MyClass.ForeignKey.ForeignKey.Id := 123;
  MyClass.ForeignKey.ForeignKey.DestroyCallFunction :=
    procedure
    begin
      Destroyed := True;
    end;

  AddObjectToCache(TClassWithForeignKeyToClassTest.Create, 123);

  AddObjectToCache(TClassWithForeignKeyToClassWithFunction.Create, 123);

  AddObjectToCache(TClassWithFunction.Create, 123);

  Builder.Update(MyClass);

  Assert.IsTrue(Destroyed);
end;

procedure TQueryBuilderDataManipulationTest.ReadOnlyFieldsCantBeUpdatedInUpdateFunction;
begin
  var MyClass := TMyEntityInheritedFromSimpleClass.Create;
  MyClass.Id := 123;

  AddObjectToCache(TMyEntityInheritedFromSimpleClass.Create, 123);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.SetupData;
begin
  Setup;

  FLazyLoader := TMock.CreateInterface<ILazyLoader>;

  FLazyLoader.Setup.WillReturn(1234).When.GetKey;
end;

procedure TQueryBuilderDataManipulationTest.TearDownData;
begin
  FLazyLoader := nil;

  TearDown;
end;

procedure TQueryBuilderDataManipulationTest.TheDeleteErrorMustRaiseAfterTheRollbackTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteDirect(It.IsAny<String>);

  Assert.WillRaise(
    procedure
    begin
      Builder.Delete(MyClass);
    end);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.TheForeignKeyObjectThatInTheCacheMustBeDestroyedAfterTheInsertion;
begin
  var AnotherClass := TClassWithFunction.Create;
  AnotherClass.Id := 123;
  var Destroyed := False;
  var MyClass := TClassWithForeignKeyToClassWithFunction.Create;
  MyClass.ForeignKey := TClassWithFunction.Create;
  MyClass.ForeignKey.Id := 123;
  MyClass.ForeignKey.DestroyCallFunction :=
    procedure
    begin
      Destroyed := True;
    end;

  AddObjectToCache(AnotherClass);

  Builder.Insert(MyClass);

  Assert.IsTrue(Destroyed);
end;

procedure TQueryBuilderDataManipulationTest.TheForeignKeyObjectThatInTheCacheMustBeDestroyedAfterTheUpdate;
begin
  var AnotherClass := TClassWithFunction.Create;
  AnotherClass.Id := 123;
  var Destroyed := False;
  var MyClass := TClassWithForeignKeyToClassWithFunction.Create;
  MyClass.Id := 123;
  MyClass.ForeignKey := TClassWithFunction.Create;
  MyClass.ForeignKey.Id := 123;
  MyClass.ForeignKey.DestroyCallFunction :=
    procedure
    begin
      Destroyed := True;
    end;

  AddObjectToCache(AnotherClass);

  AddObjectToCache(MyClass);

  Builder.Update(MyClass);

  Assert.IsTrue(Destroyed);
end;

procedure TQueryBuilderDataManipulationTest.TheForeignObjectMustUpdateTheValuesOfTheCachedObjectAfterTheUpdate;
begin
  var Cache := TClassWithPrimaryKey.Create;
  Cache.Id := 123;
  Cache.Value := 456;

  AddObjectToCache(Cache);

  var MyClass := TClassWithPrimaryKey.Create;
  MyClass.Id := 123;
  MyClass.Value := 789;

  Builder.Update(MyClass);

  Assert.AreEqual(789, Cache.Value);
end;

procedure TQueryBuilderDataManipulationTest.TheInsertionErrorMustBeRaiseAfterTheRollbackTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Rollback;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  Assert.WillRaise(
    procedure
    begin
      Builder.Insert(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.TheSaveErrorMustRaiseAfterTheRollbackTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Id := 123;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteDirect(It.IsAny<String>);

  Assert.WillRaise(
    procedure
    begin
      Builder.Save(MyClass);
    end);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.TheUpdateErrorMustRaiseAfterTheRollbackTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteDirect(It.IsAny<String>);

  Assert.WillRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.TheValuesFromTheForeignObjectMustBeLoadedInTheCachedObject;
begin
  var MyClass := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClass.Id := 123;
  MyClass.Field3 := 'abc';
  var MyClassCache := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClassCache.Id := 123;
  MyClassCache.Field3 := '888';

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.AreEqual('abc', MyClassCache.Field3);
end;

procedure TQueryBuilderDataManipulationTest.WhenAnDeleteErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Rollback;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteDirect(It.IsAny<String>);

  try
    Builder.Delete(MyClass);
  except
  end;

  Assert.CheckExpectation(Transaction.CheckExpectations);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.WhenAnInsertErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Rollback;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  try
    Builder.Insert(MyClass);
  except
  end;

  Assert.CheckExpectation(Transaction.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenAnSaveErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Id := 123;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Rollback;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteDirect(It.IsAny<String>);

  try
    Builder.Save(MyClass);
  except
  end;

  Assert.CheckExpectation(Transaction.CheckExpectations);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.WhenAnUpdateErrorOccurrsMustCallRollbackFunctionOfTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Rollback;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillExecute(
    procedure
    begin
      raise Exception.Create('An error message');
    end).When.ExecuteDirect(It.IsAny<String>);

  try
    Builder.Update(MyClass);
  except
  end;

  Assert.CheckExpectation(Transaction.CheckExpectations);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.WhenCallDeleteMustStartATransactionInDatabase;
begin
  var MyClass := TAutoGeneratedClass.Create;

  DatabaseMock.Expect.Once.When.StartTransaction;

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Delete(MyClass);

  Assert.CheckExpectation(DatabaseMock.CheckExpectations);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.WhenCallInsertMustStartATransactionInDatabase;
begin
  var MyClass := TAutoGeneratedClass.Create;

  DatabaseMock.Expect.Once.When.StartTransaction;

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance)).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  Builder.Insert(MyClass);

  Assert.CheckExpectation(DatabaseMock.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenCallSaveMustStartATransactionInDatabase;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Id := 123;

  AddObjectToCache(TAutoGeneratedClass.Create, 123);

  DatabaseMock.Expect.Once.When.StartTransaction;

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Save(MyClass);

  Assert.CheckExpectation(DatabaseMock.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenCallUpdateMustStartATransactionInDatabase;
begin
  var MyClass := TAutoGeneratedClass.Create;

  AddObjectToCache(TAutoGeneratedClass.Create);

  DatabaseMock.Expect.Once.When.StartTransaction;

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Update(MyClass);

  Assert.CheckExpectation(DatabaseMock.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenChangeALazyValueAndTheReferenceObjectHasntTheLazyLoadedMustUpdateTheClassAsExpected;
begin
  var CacheClass := TLazyArrayClass.Create;
  CacheClass.Id := 123;
  var Manipulator := TLazyManipulator.GetManipulator(CacheClass.Lazy);
  Manipulator.Loader := FLazyLoader.Instance;
  var MyClass := TLazyArrayClass.Create;
  MyClass.Id := 123;
  MyClass.Lazy := nil;

  AddObjectToCache(CacheClass);

  Builder.Update(MyClass);

  Assert.AreEqual('update LazyArrayClass set IdLazy=null where Id=123', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenChangeTheValueOfAnObjectAlreadyInTheCacheMustUpdateTheFieldChanged;
begin
  var MyClass := TClassWithPrimaryKey.Create;
  MyClass.Id := 123;
  MyClass.Value := 456;

  AddObjectToCache(MyClass);

  MyClass.Value := 789;

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithPrimaryKey set Value=789 where Id=123', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenClearAForeignKeyMustUpdateTheColumnToNull;
begin
  var Cache := TClassWithForeignKey.Create;
  Cache.Id := 123;
  Cache.AnotherClass := TClassWithPrimaryKey.Create;
  Cache.AnotherClass.Id := 123;
  var MyClass := TClassWithForeignKey.Create;
  MyClass.Id := 123;

  AddObjectToCache(Cache);

  AddObjectToCache(Cache.AnotherClass);

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithForeignKey set IdAnotherClass=null where Id=123', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertAClassWithAutoGeneratedAttributeButTheKeyHasValueMustInsertThisValue;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Id := 1234;
  MyClass.Value := 'abc';

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into AutoGeneratedClass(Id,Value)values(1234,''abc'')', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertAnEntityMustSaveTheForeignKeysFirstAfterThisMustInsertTheEntity;
begin
  FCursorClass.Values := [[123], [123]];
  var ForeignKeySaved := False;
  var MyClass := TClassWithForeignKey.Create;
  MyClass.AnotherClass := TClassWithPrimaryKey.Create;

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      ForeignKeySaved := True;
      Result := TValue.From(FCursor);
    end).When.ExecuteInsert(It(0).IsEqualTo('insert into ClassWithPrimaryKey(Value)values(0)'), It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      Result := TValue.From(FCursor);

      Assert.IsTrue(ForeignKeySaved, 'The foreign key not saved');
    end).When.ExecuteInsert(It(0).IsEqualTo('insert into ClassWithForeignKey(IdAnotherClass)values(123)'), It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Insert(MyClass);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertAnEntityMustSaveTheManyValueAssociationsAfterInsertedTheEntity;
begin
  var CanSaveManyValueAssociation := False;
  var MyClass := TManyValueParent.Create;
  MyClass.Id := 123;
  MyClass.Childs := [TManyValueChild.Create];

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      CanSaveManyValueAssociation := True;
      Result := TValue.From(FCursor);
    end).When.ExecuteInsert(It(0).IsEqualTo('insert into ManyValueParent(Id)values(123)'), It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      Result := TValue.From(FCursor);

      Assert.IsTrue(CanSaveManyValueAssociation, 'The parent entity not saved');
    end).When.ExecuteInsert(It(0).IsEqualTo('insert into ManyValueChild(IdParent)values(123)'), It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Insert(MyClass);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertANewObjectThisObjectMustBeAddedToTheCache;
begin
  var CachedObject: TObject := nil;
  var MyClass := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClass.Id := 123;
  MyClass.Field3 := 'abc';

  MyClass := Builder.Insert(MyClass);

  FCache.Get('Delphi.ORM.Test.Entity.TMyEntityWithPrimaryKeyInLastField.123', CachedObject);

  Assert.AreEqual<Pointer>(MyClass, CachedObject);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertAnObjectWithCircularReferenceMustUpdateTheForeignKeyAfterAllObjectsAreInserted;
begin
  FCursorClass.Values := [[111], [222]];
  var MyClass := TClassWithCircularReference.Create;
  MyClass.CircularReferente1 := TClassWithCircularReferenceForeignKey.Create;
  MyClass.CircularReferente1.CircularReference2 := MyClass;

  Builder.Insert(MyClass);

  Assert.AreEqual(
    'insert into ClassWithCircularReferenceForeignKey()values()'#13#10 +
    'insert into ClassWithCircularReference(IdCircularReferente1)values(111)'#13#10 +
    'update ClassWithCircularReferenceForeignKey set IdCircularReference2=222 where Id=111', FDatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertAnObjectWithEmptyForeignKeyMustLoadTheChangesWithNullValue;
begin
  FCursorClass.Values := [[123456]];
  var MyClass := TClassWithForeignKey.Create;
  var Table := TMapper.Default.FindTable(MyClass.ClassType);

  Builder.Insert(MyClass);

  Assert.AreEqual('null', FCache.ChangeManager.Changes[MyClass][Table.Field['AnotherClass']]);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertAnObjectWithForeignKeysThatIsAlreadyInTheCacheMustUpdateTheReferenceOfTheObjectBeenInserted;
begin
  var AnotherClass := TClassWithPrimaryKey.Create;
  AnotherClass.Id := 123;
  var MyClass := TClassWithTwoForeignKey.Create;
  MyClass.AnotherClass := TClassWithPrimaryKey.Create;
  MyClass.AnotherClass.Id := 123;

  AddObjectToCache(AnotherClass);

  MyClass := Builder.Insert(MyClass);

  Assert.AreEqual<Pointer>(AnotherClass, MyClass.AnotherClass);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAClassMustCopyTheFieldValuesToTheNewObject;
begin
  var MyClass := TClassWithPrimaryKeyAttribute.Create;
  MyClass.Id := 111;
  MyClass.Id2 := 222;
  MyClass.Value := 333;

  MyClass := Builder.Insert(MyClass);

  Assert.AreEqual(111, MyClass.Id);
  Assert.AreEqual(222, MyClass.Id2);
  Assert.AreEqual(333, MyClass.Value);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAClassMustInsertAllForeignKeysInTheClassBeforeInsertTheCurrentClass;
begin
  FCursorClass.Values := [[1], [2], [3]];
  var MyClass := TClassWithCascadeAttribute.Create;
  MyClass.InsertCascade := TClassWithCascadeForeignClass.Create;
  MyClass.UpdateCascade := TClassWithCascadeForeignClass.Create;
  MyClass.UpdateInsertCascade := TClassWithCascadeForeignClass.Create;

  Builder.Insert(MyClass);

  Assert.AreEqual(
    'insert into ClassWithCascadeForeignClass(Value)values(0)'#13#10 +
    'insert into ClassWithCascadeForeignClass(Value)values(0)'#13#10 +
    'insert into ClassWithCascadeForeignClass(Value)values(0)'#13#10 +
    'insert into ClassWithCascadeAttribute(Id,IdInsertCascade,IdUpdateCascade,IdUpdateInsertCascade)values(0,1,2,3)', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAInheritedClassCantRaiseErrorFromDuplicateCacheValue;
begin
  FCursorClass.Values := [[123]];
  var MyClass := TMyEntityInheritedFromSimpleClass.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Insert(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAManyValueClassMustUpdateTheArrayLengthOfTheDestinyClass;
begin
  FCursorClass.Values := [[1], [2]];
  var MyClass := TManyValueParent.Create;
  MyClass.Childs := [TManyValueChild.Create, TManyValueChild.Create];

  MyClass := Builder.Insert(MyClass);

  Assert.AreEqual<NativeInt>(2, Length(MyClass.Childs));
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAnEntityInheritedFromAnotherMustInsertTheParentClassFirst;
begin
  FCursorClass.Values := [[123]];
  var MyClass := TMyEntityInheritedFromSimpleClass.Create;

  Builder.Insert(MyClass);

  Assert.AreEqual(
    'insert into MyEntityInheritedFromSingle(AnotherProperty,BaseProperty)values('''','''')'#13#10 +
    'insert into MyEntityInheritedFromSimpleClass(Id,SimpleProperty)values(123,0)', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAnObjectNotProcessedMustRemoveTheColumnFromTheInsert;
begin
  FCursorClass.Values := [[1], [1], [1]];
  var First := TClassRecursiveFirst.Create;
  var Second := TClassRecursiveSecond.Create;
  Second.Recursive := First;
  var Third := TClassRecursiveThird.Create;
  Third.Recursive := Second;

  First.Recursive := Third;

  Builder.Insert(First);

  Assert.StartsWith('insert into ClassRecursiveSecond()values()', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAnObjectWithAnUnloadedLazyFieldCantRaisAnyError;
begin
  var MyClass := TLazyArrayClass.Create;

  var Manipulator := TLazyManipulator.GetManipulator(MyClass.Lazy);
  Manipulator.Loader := FLazyLoader.Instance;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Insert(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAnObjectWithAnUnloadedLazyMustInsertTheLazyKeyInTheField;
begin
  var MyClass := TLazyArrayClass.Create;

  var Manipulator := TLazyManipulator.GetManipulator(MyClass.Lazy);
  Manipulator.Loader := FLazyLoader.Instance;

  Builder.Insert(MyClass);

  Assert.StartsWith('insert into LazyArrayClass(Id,IdLazy)values(0,1234)', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAnObjectWithCircularReferenceCantRaiseAnyError;
begin
  FCursorClass.Values := [[1], [1], [1]];
  var First := TClassRecursiveFirst.Create;
  var Second := TClassRecursiveSecond.Create;
  Second.Recursive := First;
  var Third := TClassRecursiveThird.Create;
  Third.Recursive := Second;

  First.Recursive := Third;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Insert(First);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenInsertingAnObjectWithCircularReferenceMustInsertTheClassesInTheOrderExpected;
begin
  FCursorClass.Values := [[123], [123], [123]];
  var First := TClassRecursiveFirst.Create;
  var Second := TClassRecursiveSecond.Create;
  Second.Recursive := First;
  var Third := TClassRecursiveThird.Create;
  Third.Recursive := Second;

  First.Recursive := Third;

  Builder.Insert(First);

  Assert.StartsWith(
    'insert into ClassRecursiveSecond()values()'#13#10 +
    'insert into ClassRecursiveThird(IdRecursive)values(123)'#13#10 +
    'insert into ClassRecursiveFirst(IdRecursive)values(123)',
    DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenNoFieldIsUpdatedCantRunAnySQL;
begin
  var MyClass := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClass.Id := 123;
  var MyClassCache := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClassCache.Id := 123;

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.IsEmpty(DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenSafeAClassWithPrimaryKeyIsAnEnumeratorCantRaiseAnyError;
begin
  var MyClass := TClassEnumPrimaryKey.Create;
  MyClass.Id := Enum3;

  AddObjectToCache(MyClass);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Save(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenSaveALoadedLazyForeignKeyMustExecuteTheUpdate;
begin
  FCursorClass.Values := [[111]];
  var LazyCache := TLazyClass.Create;
  LazyCache.Id := 1234;
  var MyClass := TLazyClass.Create;
  MyClass.Id := 1234;
  MyClass.Lazy.Value := TMyEntity.Create;

  AddObjectToCache(LazyCache);

  Builder.Save(MyClass);

  Assert.AreEqual(
    'insert into MyEntity(Name,Value)values('''',0)'#13#10 +
    'update LazyClass set IdLazy=111 where Id=1234', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenSaveAManyValueAssocitationEntityMustAvoidSaveTheParentLinkOfTheChildToAvoidStackOverflow;
begin
  var MyClass := TManyValueParentError.Create;
  MyClass.PassCount := 3;
  MyClass.Values := [TManyValueParentChildError.Create];

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance)).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Insert(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenSaveAManyValueAssocitationEntityMustLoadTheParentObjectInTheChildObjects;
begin
  var MyClass := TManyValueParentError.Create;
  MyClass.PassCount := 4;
  MyClass.Values := [TManyValueParentChildError.Create];

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance)).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  MyClass := Builder.Insert(MyClass);

  Assert.IsNotNull(MyClass.Values[0].ManyValueParentError);
end;

procedure TQueryBuilderDataManipulationTest.WhenSavingAnEntityInheritedFromAnotherTableCantRaiseAnyError;
begin
  var MyClass := TMyEntityInheritedFromSimpleClass.Create;
  MyClass.Id := 123;

  AddObjectToCache(TMyEntityInheritedFromSimpleClass.Create, 123);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance)).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Save(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheClassHasANullableFieldAndTheValueNotLoadedMustOmitTheFieldFromInsert;
begin
  var MyClass := TClassWithNullableProperty.Create;

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into ClassWithNullableProperty(Id)values(0)', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheDeleteOccursSuccessfullyMustCommitTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Commit;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  Builder.Delete(MyClass);

  Assert.CheckExpectation(Transaction.CheckExpectations);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.WhenTheInsertOccursSuccessfullyMustCommitTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Commit;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance)).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  Builder.Insert(MyClass);

  Assert.CheckExpectation(Transaction.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheLazyArrayHasValueButNotLoadedCantRaiseAnyError;
begin
  var CacheClass := TLazyArrayClass.Create;
  CacheClass.Id := 123;
  var MyClass := TLazyArrayClass.Create;
  MyClass.Id := 123;

  TLazyManipulator.GetManipulator(CacheClass.LazyArray).Loader := FLazyLoader.Instance;
  TLazyManipulator.GetManipulator(MyClass.LazyArray).Loader := FLazyLoader.Instance;

  AddObjectToCache(CacheClass);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheLazyArrayInTheCacheIsntLoadedAndTheForeignValueHasTheArrayLoadedCantRaiseAnyErrorWhenUpdate;
begin
  var CacheClass := TLazyArrayClass.Create;
  CacheClass.Id := 123;
  var MyClass := TLazyArrayClass.Create;
  MyClass.Id := 123;
  MyClass.LazyArray := [TLazyArrayClassChild.Create];

  TLazyManipulator.GetManipulator(CacheClass.LazyArray).Loader := FLazyLoader.Instance;

  AddObjectToCache(CacheClass);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheLazyCacheValueIsDiferentFromTheForeignKeyObjectButTheLazyIsntLoadedCantUpdateTheValue;
begin
  var CacheClass := TLazyArrayClass.Create;
  CacheClass.Id := 123;
  var LazyValue := TMyEntity.Create;
  LazyValue.Id := 123;
  var MyClass := TLazyArrayClass.Create;
  MyClass.Id := 123;
  var MyClassManipulator := TLazyManipulator.GetManipulator(MyClass.Lazy);
  MyClassManipulator.Loader := FLazyLoader.Instance;

  CacheClass.Lazy := LazyValue;

  FLazyLoader.Setup.WillReturn(456).When.GetKey;

  AddObjectToCache(CacheClass);

  AddObjectToCache(LazyValue);

  Builder.Update(MyClass);

  Assert.AreEqual(EmptyStr, DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheLazyHasntLoadedCantBeUpdatedThenValuesOfThisFields;
begin
  var LazyCache := TLazyClass.Create;
  LazyCache.Id := 1234;
  var Manipulator := TLazyManipulator.GetManipulator(LazyCache, TMapper.Default.FindTable(TLazyClass).Field['Lazy'].PropertyInfo);
  Manipulator.Loader := FLazyLoader.Instance;
  var MyClass := TLazyClass.Create;
  MyClass.Id := 1234;

  TLazyManipulator.GetManipulator(MyClass.Lazy).Loader := FLazyLoader.Instance;

  AddObjectToCache(LazyCache);

  Builder.Save(MyClass);

  Assert.IsNotNull(Manipulator.Loader);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheLazyHasValueButNotLoadedCantRaiseAnyError;
begin
  var CacheClass := TLazyArrayClass.Create;
  CacheClass.Id := 123;
  var MyClass := TLazyArrayClass.Create;
  MyClass.Id := 123;

  TLazyManipulator.GetManipulator(CacheClass.Lazy).Loader := FLazyLoader.Instance;
  TLazyManipulator.GetManipulator(MyClass.Lazy).Loader := FLazyLoader.Instance;

  AddObjectToCache(CacheClass);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenThenObjectOfAForeignKeyIsNilCantRaiseAnyError;
begin
  var MyClass := TClassWithForeignKey.Create;

  AddObjectToCache(TClassWithForeignKey.Create);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance)).When.ExecuteInsert(It(0).IsAny<String>, It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Assert.WillNotRaise(
  procedure
  begin
    Builder.Update(MyClass);
  end);
end;

procedure TQueryBuilderDataManipulationTest.WhenThePropertyIsReadOnlyTheFieldCantBeInTheInsertSQL;
begin
  var MyClass := TClassWithNoUpdateAttribute.Create;
  MyClass.Id := 'abc';
  MyClass.Value := 'ghi';

  Builder.Insert(MyClass);

  Assert.AreEqual('insert into ClassWithNoUpdateAttribute(Id,Value)values(''abc'',''ghi'')', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenThePropertyIsReadOnlyTheFieldCantBeInTheUpdateSQL;
begin
  var MyClass := TClassWithNoUpdateAttribute.Create;
  MyClass.Id := 'abc';
  MyClass.Value := 'ghi';

  AddObjectToCache(TClassWithNoUpdateAttribute.Create, 'abc');

  Builder.Update(MyClass);

  Assert.AreEqual('update ClassWithNoUpdateAttribute set Value=''ghi'' where Id=''abc''', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheSaveOccursSuccessfullyMustCommitTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  MyClass.Id := 123;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  Transaction.Expect.Once.When.Commit;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  AddObjectToCache(TAutoGeneratedClass.Create, 123);

  Builder.Save(MyClass);

  Assert.CheckExpectation(Transaction.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenTheUpdateOccursSuccessfullyMustCommitTheTransaction;
begin
  var MyClass := TAutoGeneratedClass.Create;
  var Transaction := TMock.CreateInterface<IDatabaseTransaction>(True);

  AddObjectToCache(TAutoGeneratedClass.Create);

  Transaction.Expect.Once.When.Commit;

  DatabaseMock.Setup.WillReturn(TValue.From(Transaction.Instance)).When.StartTransaction;

  Builder.Update(MyClass);

  Assert.CheckExpectation(Transaction.CheckExpectations);
end;

procedure TQueryBuilderDataManipulationTest.WhenTryToUpdateAClassThatIsNotCachedHaveToRaiseAnError;
begin
  var MyClass := TClassWithPrimaryKey.Create;

  Assert.WillRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end, EObjectReferenceWasNotFound);

  MyClass.Free;
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAClassMustUpdateOnlyTheChangedFields;
begin
  var MyClass := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClass.Id := 123;
  MyClass.Field1 := 555;
  MyClass.Field2 := 777;
  MyClass.Field3 := '888';
  var MyClassCache := TMyEntityWithPrimaryKeyInLastField.Create;
  MyClassCache.Id := 123;
  MyClassCache.Field3 := '888';

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.AreEqual('update MyEntityWithPrimaryKeyInLastField set Field1=555,Field2=777 where Id=123', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAClassWithManyValueAssociationMustUpdateTheListOfTheObjectInTheCache;
begin
  var MyClass := TManyValueParent.Create;
  MyClass.Childs := [TManyValueChild.Create];
  var MyClassCache := TManyValueParent.Create;

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.AreEqual<Integer>(1, Length(MyClassCache.Childs));
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnEntityMustSaveTheForeignKeysFirstAfterThisMustUpdateTheEntity;
begin
  FCursorClass.Values := [[123]];
  var ForeignKeySaved := False;
  var MyClass := TClassWithForeignKey.Create;
  MyClass.AnotherClass := TClassWithPrimaryKey.Create;

  AddObjectToCache(TClassWithForeignKey.Create);

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      ForeignKeySaved := True;
      Result := TValue.From(FCursor);
    end).When.ExecuteInsert(It(0).IsEqualTo('insert into ClassWithPrimaryKey(Value)values(0)'), It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      Result := TValue.From(FCursor);

      Assert.IsTrue(ForeignKeySaved, 'The foreign key not saved');
    end).When.ExecuteDirect(It(0).IsEqualTo('update ClassWithForeignKey set IdAnotherClass=123 where Id=0'));

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Update(MyClass);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnEntityMustSaveTheManyValueAssociationsAfterUpdatedTheEntity;
begin
  var CanSaveManyValueAssociation := False;
  var MyClass := TManyValueParent.Create;
  MyClass.Id := 123;
  MyClass.Childs := [TManyValueChild.Create];

  var Cache := TManyValueParent.Create;
  Cache.Id := 123;
  Cache.Child := TManyValueChild.Create;
  Cache.Child.Id := 123;

  AddObjectToCache(Cache);

  AddObjectToCache(Cache.Child);

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      Result := TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance);

      Assert.IsTrue(CanSaveManyValueAssociation, 'The parent entity not saved');
    end).When.ExecuteInsert(It(0).IsEqualTo('insert into ManyValueChild(IdParent)values(123)'), It(1).IsAny<TArray<String>>);

  DatabaseMock.Setup.WillExecute(
    function (const Args: TArray<TValue>): TValue
    begin
      CanSaveManyValueAssociation := True;
      Result := TValue.From(TMock.CreateInterface<IDatabaseCursor>(True).Instance);
    end).When.ExecuteDirect(It(0).IsEqualTo('update ManyValueParent set IdChild=null where Id=123'));

  DatabaseMock.Setup.WillReturn(TValue.From(TMock.CreateInterface<IDatabaseTransaction>(True).Instance)).When.StartTransaction;

  Builder.Update(MyClass);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnEntityWithAnForeignKeyInTheCacheCantRaiseAnyError;
begin
  var ForeignKey := TClassWithCascadeForeignClass.Create;
  ForeignKey.Id := 1;
  var MyClass := TClassWithCascadeAttribute.Create;
  MyClass.Id := 1;
  MyClass.UpdateCascade := TClassWithCascadeForeignClass.Create;
  MyClass.UpdateCascade.Id := 1;

  AddObjectToCache(ForeignKey);

  AddObjectToCache(MyClass);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnInheritedClassCantRaiseAccessViolationInTheDestructionProcess;
begin
  var MyClass := TMyEntityInheritedFromSimpleClass.Create;
  MyClass.Id := 123;

  AddObjectToCache(TMyEntityInheritedFromSimpleClass.Create, 123);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Save(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnObjectMustReturnTheObjectFromTheCache;
begin
  var MyClass := TMyEntityWithPrimaryKey.Create;
  var MyCacheClass := TMyEntityWithPrimaryKey.Create;

  AddObjectToCache(MyCacheClass);

  Assert.AreEqual<Pointer>(MyCacheClass, Builder.Update(MyClass));
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnObjectMustUpdateTheChangeInformationOfTheObject;
begin
  var MyClass := TMyEntity.Create;
  MyClass.Id := 123;
  MyClass.Name := 'MyName';
  MyClass.Value := 123456;
  var Table := TMapper.Default.FindTable(MyClass.ClassType);

  AddObjectToCache(TMyEntity.Create, 123);

  var MyClassUpdated := Builder.Update(MyClass);

  Assert.AreEqual('123', FCache.ChangeManager.Changes[MyClassUpdated][Table.Field['Id']]);
  Assert.AreEqual('''MyName''', FCache.ChangeManager.Changes[MyClassUpdated][Table.Field['Name']]);
  Assert.AreEqual('123456', FCache.ChangeManager.Changes[MyClassUpdated][Table.Field['Value']]);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnObjectWithManyValueAssociationTheParentForeignKeyOfTheChildObjectMustBeTheReferenceToTheCacheObject;
begin
  var MyClass := TManyValueParent.Create;
  MyClass.Id := 123;
  MyClass.Childs := [TManyValueChild.Create];
  var MyClassCache := TManyValueParent.Create;
  MyClassCache.Id := 123;

  AddObjectToCache(MyClassCache);

  Builder.Update(MyClass);

  Assert.AreEqual<Pointer>(MyClassCache, MyClassCache.Childs[0].Parent);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdateAnUnloadedLazyManyValueAssociationCantRaiseAnyError;
begin
  var MyClass := TLazyArrayClass.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Insert(MyClass);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdatingAClassMustInsertAllForeignKeysInTheClassBeforeUpdateTheCurrentClass;
begin
  FCursorClass.Values := [[1], [2], [3]];
  var MyClass := TClassWithCascadeAttribute.Create;
  MyClass.InsertCascade := TClassWithCascadeForeignClass.Create;
  MyClass.UpdateCascade := TClassWithCascadeForeignClass.Create;
  MyClass.UpdateInsertCascade := TClassWithCascadeForeignClass.Create;

  AddObjectToCache(TClassWithCascadeAttribute.Create);

  Builder.Update(MyClass);

  Assert.AreEqual(
    'insert into ClassWithCascadeForeignClass(Value)values(0)'#13#10 +
    'insert into ClassWithCascadeForeignClass(Value)values(0)'#13#10 +
    'insert into ClassWithCascadeForeignClass(Value)values(0)'#13#10 +
    'update ClassWithCascadeAttribute set IdInsertCascade=1,IdUpdateCascade=2,IdUpdateInsertCascade=3 where Id=0', DatabaseClass.SQL);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdatingAnObjectWithCircularReferenceCantRaiseAnyError;
begin
  var First := TClassRecursiveFirst.Create;
  First.Id := 123;
  var Second := TClassRecursiveSecond.Create;
  Second.Id := 123;
  Second.Recursive := First;
  var Third := TClassRecursiveThird.Create;
  Third.Recursive := Second;

  First.Recursive := Third;

  AddObjectToCache(TClassRecursiveFirst.Create, 123);

  AddObjectToCache(TClassRecursiveSecond.Create, 123);

  Assert.WillNotRaise(
    procedure
    begin
      Builder.Update(First);
    end);
end;

procedure TQueryBuilderDataManipulationTest.WhenUpdatingTheCachedObjectCantDestroyTheObject;
begin
  var DestroyCalled := False;
  var MyClass := TClassWithFunction.Create;
  MyClass.Id := 123;

  MyClass.DestroyCallFunction :=
    procedure
    begin
      DestroyCalled := True;
    end;

  AddObjectToCache(MyClass);

  Builder.Update(MyClass);

  Assert.IsFalse(DestroyCalled);
end;

{ TQueryBuilderOrderByTeste }

procedure TQueryBuilderOrderByTeste.EveryTimeTheFieldFunctionFromOrderByIsCalledMustAddTheFieldList;
begin
  var OrderBy := TQueryBuilderOrderBy<TObject>.Create;

  OrderBy.Field('A');

  OrderBy.Field('B');

  OrderBy.Field('C');

  Assert.AreEqual<Integer>(3, Length(OrderBy.Fields));

  OrderBy.Free;
end;

procedure TQueryBuilderOrderByTeste.WhenCallTheFieldFunctionMustAddTheFieldAliasToTheFieldList;
begin
  var OrderBy := TQueryBuilderOrderBy<TObject>.Create;

  OrderBy.Field('A');

  Assert.AreEqual('A', OrderBy.Fields[0].FieldNames[0]);

  OrderBy.Free;
end;

procedure TQueryBuilderOrderByTeste.WhenCallTheFieldProcedureMustResultTheSelfOfTheOrderByClass;
begin
  var OrderBy := TQueryBuilderOrderBy<TObject>.Create;

  Assert.AreEqual(OrderBy, OrderBy.Field('A'));

  OrderBy.Free;
end;

procedure TQueryBuilderOrderByTeste.WhenTheFieldIsDescendingMustLoadTheSQLAsExpected;
begin
  Builder.Select.All.From<TMyTestClass>.OrderBy.Field('Value', False);

  Assert.EndsWith(' order by T1.Value desc', Builder.GetSQL);
end;

procedure TQueryBuilderOrderByTeste.WhenTheFieldListIsEmptyMustReturnAnEmptySQLValue;
begin
  var OrderBy := TQueryBuilderOrderBy<TObject>.Create;

  Assert.AreEqual(EmptyStr, OrderBy.GetSQL);

  OrderBy.Free;
end;

procedure TQueryBuilderOrderByTeste.WhenTheFieldListIsNotEmptyMustReturnTheOrderByClauseWithTheFieldList;
begin
  Builder.Select.All.From<TMyTestClass>.OrderBy.Field('Value').Field('Value').Field('Value');

  Assert.EndsWith(' order by T1.Value,T1.Value,T1.Value', Builder.GetSQL);
end;

{ TQueryBuilderFieldAliasTest }

procedure TQueryBuilderFieldAliasTest.WhenCreateMustLoadThePropertyFieldNameOfTheClass;
begin
  var Field := TQueryBuilderFieldAlias.Create('Test');

  Assert.AreEqual('Test', Field.FieldName);

  Field.Free;
end;

procedure TQueryBuilderFieldAliasTest.WhenTheFieldNameIsSeparetedByDotMustLoadTheFieldNamesWithTheNames;
begin
  var Field := TQueryBuilderFieldAlias.Create('Test1.Test2.Test3');

  Assert.AreEqual('Test1', Field.FieldNames[0]);
  Assert.AreEqual('Test2', Field.FieldNames[1]);
  Assert.AreEqual('Test3', Field.FieldNames[2]);

  Field.Free;
end;

{ TQueryBuilderFromTest }

procedure TQueryBuilderFromTest.WhenCallFromFunctionMustLoadTheTablePropertyWithTheDataOfThatTable;
begin
  Builder.Select.All.From<TClassWithTwoForeignKey>;

  Assert.AreNotEqual<Pointer>(nil, FBuilderAccess.Table);
end;

procedure TQueryBuilderFromTest.WhenCallFromFunctionWithAClassWithTwoForeignKeyAndOneOfThisIsSettedOfPrimaryKeyAttributeMustGenerateJoinComparingRightAliasLikePrimaryKeyOfClassForeign;
begin
  Builder.Select.All.From<TClassWithTwoForeignKeyAndOneIsAPrimaryKey>;

  var ExpectedSQL :=
    ' from ClassWithTwoForeignKeyAndOneIsAPrimaryKey T1 ' +
    'left join ClassWithPrimaryKey T2 on T1.IdAnotherClass=T2.Id ' +
    'left join ClassWithPrimaryKey T3 on T1.IdAnotherClass2=T3.Id';

  Assert.EndsWith(ExpectedSQL, Builder.GetSQL);
end;

procedure TQueryBuilderFromTest.WhenFilterringALazyFieldMustBuildTheJoinsToTheFilterWork;
begin
  Builder.Select.All.From<TLazyClass>.Where(Field('Lazy.Name') = 'abc');

  Assert.EndsWith(
        ' from LazyClass T1 ' +
    'left join MyEntity T2 ' +
           'on T1.IdLazy=T2.Id ' +
        'where T2.Name=''abc''', Builder.GetSQL);
end;

procedure TQueryBuilderFromTest.WhenTheClassHasAnLazyArrayCantCreateTheJoinBetweenTheClasses;
begin
  Builder.Select.All.From<TLazyArrayClass>;

  Assert.EndsWith(' from LazyArrayClass T1', Builder.GetSQL);
end;

procedure TQueryBuilderFromTest.WhenUseALazyFieldInTheFilterMoreThenOnceMustLoadASingleJoin;
begin
  Builder.Select.All.From<TLazyClass>.Where((Field('Lazy.Name') = 'abc') and (Field('Lazy.Name') = 'def'));

  Assert.EndsWith(
        ' from LazyClass T1 ' +
    'left join MyEntity T2 ' +
           'on T1.IdLazy=T2.Id ' +
        'where (T2.Name=''abc''' +
         ' and T2.Name=''def'')', Builder.GetSQL);
end;

{ TQueryBuilderBaseTest }

function TQueryBuilderBaseTest.AddObjectToCache<T>(const Obj: T): T;
begin
  Result := Obj;
  var Table := TMapper.Default.FindTable(TypeInfo(T));

  FCache.ChangeManager.AddInstance(Table, Obj);

  FCache.Add(Table.GetCacheKey(Obj), Obj);
end;

function TQueryBuilderBaseTest.AddObjectToCache<T>(const Obj: T; const PrimaryKeyValue: TValue): T;
begin
  var Table := TMapper.Default.FindTable(TypeInfo(T));

  Table.PrimaryKey.SetValue(Obj, PrimaryKeyValue);

  Result := AddObjectToCache(Obj);
end;

function TQueryBuilderBaseTest.GetBuilder: TQueryBuilder;
begin
  if not Assigned(FBuilder) then
  begin
    FBuilder := TQueryBuilder.Create(Database, FCache);
    FBuilder.Options := [boDestroyForeignObjects];
    FBuilderAccess := FBuilder;
  end;

  Result := FBuilder;
end;

function TQueryBuilderBaseTest.GetDatabase: IDatabaseConnection;
begin
  if not Assigned(FDatabase) then
    if Assigned(FDatabaseMock) then
      FDatabase := DatabaseMock.Instance
    else
      FDatabase := DatabaseClass;

  Result := FDatabase;
end;

function TQueryBuilderBaseTest.GetDatabaseClass: TDatabaseTest;
begin
  if not Assigned(FDatabaseClass) then
  begin
    FDatabaseClass := TDatabaseTest.Create;
    FDatabaseClass.Cursor := FCursor;
  end;

  Result := FDatabaseClass;
end;

function TQueryBuilderBaseTest.GetDatabaseMock: IMock<IDatabaseConnection>;
begin
  if not Assigned(FDatabaseMock) then
    FDatabaseMock := TMock.CreateInterface<IDatabaseConnection>(True);

  Result := FDatabaseMock;
end;

procedure TQueryBuilderBaseTest.Setup;
begin
  FCache := TCache.Create;
  FCursorClass := TCursorMock.Create;

  FCursor := FCursorClass;
end;

procedure TQueryBuilderBaseTest.SetupFixture;
begin
  Setup;

  TearDown;
end;

procedure TQueryBuilderBaseTest.TearDown;
begin
  FBuilderAccess := nil;
  FCache := nil;
  FCursor := nil;
  FCursorClass := nil;
  FDatabase := nil;
  FDatabaseClass := nil;
  FDatabaseMock := nil;

  FreeAndNil(FBuilder);
end;

end.

