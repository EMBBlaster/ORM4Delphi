unit Persisto.Database.Manipulator.Test;

interface

uses System.Rtti, System.Generics.Collections, Data.DB, DUnitX.TestFramework, Translucent.Intf, Persisto, Persisto.Mapping;

type
  [TestFixture]
  TDatabaseManipulatorTest = class
  private
    FConnection: IMock<IDatabaseConnection>;
    FCursor: IMock<IDatabaseCursor>;
    FDatabaseField: TDatabaseField;
    FDatabaseIndex: TDatabaseIndex;
    FDatabaseTable: TDatabaseTable;
    FManager: TManager;
    FMapper: TMapper;
    FMetadataManipulator: IDatabaseManipulator;
    FSQLExecuted: String;
    FTransaction: IMock<IDatabaseTransaction>;
  public
    [Setup]
    procedure Setup;
    [SetupFixture]
    procedure SetupFixture;
    [TearDown]
    procedure TearDown;
    [Test]
    procedure TheFieldDefinitionMustBuildTheSQLHasExpected;
    [Test]
    procedure IfTheFieldIsNullableMustBuildTheSQLHasExpected;
    [Test]
    procedure IfTheFieldHasASpecialTypeMustLoadThisTypeInTheSQL;
    [Test]
    procedure IfTheFieldHasCollationMustLoadTheCollationOfTheField;
    [Test]
    procedure TheFieldDefinitionMustLoadTheSQLWithTheDatabaseNameFieldName;
    [Test]
    procedure WhenTheFieldTypeIsStringMustLoadTheSizeInTheFieldDefinition;
    [Test]
    procedure WhenTheFieldTypeIsCharMustLoadTheSizeInTheFieldDefinition;
    [Test]
    procedure WhenTheFieldIsAndFloatFieldMustLoadThePrecisionAndScaleInTheFieldDefinition;
    [Test]
    procedure IfTheFieldIsASpecialTypeCantLoadTheSizeOfTheField;
    [Test]
    procedure WhenTheFieldHasDefaultValueMustLoadTheDefaultValueHasExpected;
    [Test]
    procedure WhenCreateTheTableMustBuildTheSQLHasExpected;
    [Test]
    procedure WhenCreateAFieldMustBuildTheSQLHasExpected;
    [Test]
    procedure WhenDropAFieldMustExecuteTheSQLHasExpected;
    [Test]
    procedure WhenDropATableMustExecuteTheSQLHasExpected;
    [Test]
    procedure WhenUpdateAFieldMustExecuteTheSQLHasExpected;
    [Test]
    procedure WhenDropADefaultConstratintMustExecuteTheSQLHasExpected;
    [Test]
    procedure WhenGetTheNameOfDefaultContraintFunctionMustReturnTheNameAsExpected;
    [Test]
    procedure WhenDropIndexMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenCreateAForeignKeyMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenCreateAnIndexMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenDropAForeignKeyMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenCreateATableWithManyValueAssociationThisFieldCantBeCreated;
    [Test]
    procedure WhenGetTheFieldDefinitionOfAForeignKeyFieldMustLoadTheInfoFromThePrimaryKeyOfTheForeignKeyTable;
    [Test]
    procedure IfTheForeignKeyFieldIsASpecialTypeMustUseThisTypeInTheFieldCreation;
    [Test]
    procedure WhenCreateAPrimaryKeyIndexMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenInsertARecordMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenCreateATableWithoutPrimaryKeyCantRaiseAnyError;
    [Test]
    procedure WhenCreateATableWithoutPrimaryKeyMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenCreateASequenceMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenDropASequenceMustExecuteTheSQLAsExpected;
    [Test]
    procedure WhenCreateAUniqueIndexMustExecuteTheSQLAsExpected;
    [Test]
    procedure TheDialectMustBuildTheInsertStatementAsExpected;
    [Test]
    procedure WhenTheTableHasTheReturningFieldFilledMustBuildTheReturningClauseInTheInsertStatement;
    [Test]
    procedure WhenBuildTheUpdateCommandMustBuildTheCommandAsExpected;
    [Test]
    procedure WhenBuildTheUpdateCommandFromATableWithoutPrimaryKeyCantBuildTheWhereClause;
    [Test]
    procedure WhenThePrimaryKeyFieldIsInParamListCantBeInTheUpdateCommand;
    [Test]
    procedure WhenBuildTheInserCommandWithoutParamsMustBuildTheInsertCommandWithTheDefaultValuesClause;
  end;

  TMyTableForeingKey = class
  private
    FId: String;
    FValue: TDateTime;
  published
    [Size(50)]
    property Id: String read FId write FId;
    property Value: TDateTime read FValue write FValue;
  end;

  TMyTableForeingKeySpecial = class
  private
    FId: TDateTime;
  published
    property Id: TDateTime read FId write FId;
  end;

  [TableName('MyTableDB')]
  [Index('MyIndex', 'ForeignKeyField;RequiredField')]
  [UniqueKey('MyUniqueKey', 'RequiredField')]
  TMyTable = class
  private
    FDateTimeField: TDateTime;
    FStringField: String;
    FRequiredField: Integer;
    FFloatField: Double;
    FCharField: Char;
    FForeignKeyField: TMyTableForeingKey;
    FAutoGeneratedField: TDateTime;
    FForeignKeyFieldSpecial: TMyTableForeingKeySpecial;
  published
    [CurrentDateTime]
    property AutoGeneratedField: TDateTime read FAutoGeneratedField write FAutoGeneratedField;
    [Size(1)]
    property CharField: Char read FCharField write FCharField;
    property DateTimeField: TDateTime read FDateTimeField write FDateTimeField;
    [FieldName('FKField'), Required, NewUniqueIdentifier]
    property ForeignKeyField: TMyTableForeingKey read FForeignKeyField write FForeignKeyField;
    property ForeignKeyFieldSpecial: TMyTableForeingKeySpecial read FForeignKeyFieldSpecial write FForeignKeyFieldSpecial;
    [Precision(10, 5)]
    property FloatField: Double read FFloatField write FFloatField;
    property RequiredField: Integer read FRequiredField write FRequiredField;
    [Size(250)]
    property StringField: String read FStringField write FStringField;
  end;

implementation

uses System.SysUtils, Translucent, Persisto.Test.Entity;

{ TDatabaseManipulatorTest }

procedure TDatabaseManipulatorTest.IfTheFieldHasASpecialTypeMustLoadThisTypeInTheSQL;
begin
  var Field := FMapper.GetTable(TMyTable).Field['DateTimeField'];

//  Assert.AreEqual('DateTimeField SpecialFieldType not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.IfTheFieldHasCollationMustLoadTheCollationOfTheField;
begin
  var Field := FMapper.GetTable(TMyTable).Field['StringField'];
  Field.Collation := 'MyCollate';

//  Assert.AreEqual('StringField FieldType(250) not null collate MyCollate', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.IfTheFieldIsASpecialTypeCantLoadTheSizeOfTheField;
begin
  var Field := FMapper.GetTable(TMyTable).Field['DateTimeField'];
  Field.Scale := 5;
  Field.Size := 10;

//  Assert.AreEqual('DateTimeField SpecialFieldType not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.IfTheFieldIsNullableMustBuildTheSQLHasExpected;
begin
  var Field := FMapper.GetTable(TMyTable).Field['RequiredField'];
  Field.Required := False;

//  Assert.AreEqual('RequiredField FieldType null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.IfTheForeignKeyFieldIsASpecialTypeMustUseThisTypeInTheFieldCreation;
begin
  var Field := FMapper.GetTable(TMyTable).Field['ForeignKeyFieldSpecial'];

//  Assert.AreEqual('IdForeignKeyFieldSpecial SpecialFieldType null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.Setup;
begin
//  FConnection := TMock.CreateInterface<IDatabaseConnection>(True);
//  FCursor := TMock.CreateInterface<IDatabaseCursor>(True);
//  FDatabaseSchema := TDatabaseSchema.Create;
//  FDatabaseTable := TDatabaseTable.Create(FDatabaseSchema, 'MyTableDB');
//  FManager := TManager.Create(FConnection.Instance, nil);
//  FMapper := TMapper.Create;
//  FSQLExecuted := EmptyStr;
//  FTransaction := TMock.CreateInterface<IDatabaseTransaction>(True);
//
//  FDatabaseField := TDatabaseField.Create(FDatabaseTable, 'MyFieldDB');
//  FDatabaseIndex := TDatabaseIndex.Create(FDatabaseTable, 'MyIndex');
//
//  FMapper.GetTable(TMyTable);
//
//  FMapper.GetTable(TMyEntityWithManyValueAssociation);
//
//  FMapper.GetTable(TMyEntity2);
//
//  FConnection.Setup.WillExecute(
//    procedure (const Params: TArray<TValue>)
//    begin
//      FSQLExecuted := Params[1].AsString;
//    end).When.ExecuteDirect(It.IsAny<String>);
//
//  FConnection.Setup.WillExecute(
//    function (const Params: TArray<TValue>): TValue
//    begin
//      FSQLExecuted := Params[1].AsString;
//      Result := TValue.From(FCursor.Instance);
//    end).When.OpenCursor(It.IsAny<String>);
//
////  FConnection.Setup.WillExecute(
////    function (const Params: TArray<TValue>): TValue
////    begin
////      FSQLExecuted := Params[1].AsString;
////      Result := TValue.From(FCursor.Instance);
////    end).When.ExecuteInsert(It.IsAny<String>, It.IsAny<TArray<String>>);
//
//  FConnection.Setup.WillExecute(
//    function (const Params: TArray<TValue>): TValue
//    begin
//      Result := TValue.From(FTransaction.Instance);
//    end).When.StartTransaction;
end;

procedure TDatabaseManipulatorTest.SetupFixture;
begin
  Setup;

  TearDown;
end;

procedure TDatabaseManipulatorTest.TearDown;
begin
  FConnection := nil;
  FCursor := nil;
  FMetadataManipulator := nil;
  FSQLExecuted := EmptyStr;
  FTransaction := nil;

  FManager.Free;

  FMapper.Free;
end;

procedure TDatabaseManipulatorTest.TheDialectMustBuildTheInsertStatementAsExpected;
begin
  var Params := TParams.Create(nil);

  Params.CreateParam(ftInteger, 'Param1', ptInput);
  Params.CreateParam(ftInteger, 'Param2', ptInput);
  Params.CreateParam(ftInteger, 'Param3', ptInput);

  var SQL := FMetadataManipulator.MakeInsertStatement(FMapper.GetTable(TMySQLiteTable), Params);

  Assert.AreEqual('insert into MySQLiteTable(Param1,Param2,Param3)values(:Param1,:Param2,:Param3)', SQL);

  Params.Free;
end;

procedure TDatabaseManipulatorTest.TheFieldDefinitionMustBuildTheSQLHasExpected;
begin
  var Field := FMapper.GetTable(TMyTable).Field['RequiredField'];

//  Assert.AreEqual('RequiredField FieldType not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.TheFieldDefinitionMustLoadTheSQLWithTheDatabaseNameFieldName;
begin
  var Field := FMapper.GetTable(TMyTable).Field['RequiredField'];
  Field.DatabaseName := 'IdMyField';
  Field.Name := 'MyField';

//  Assert.AreEqual('IdMyField FieldType not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.WhenBuildTheInserCommandWithoutParamsMustBuildTheInsertCommandWithTheDefaultValuesClause;
begin
  var Params := TParams.Create(nil);
  var SQL := FMetadataManipulator.MakeInsertStatement(FMapper.GetTable(TMyEntityWithoutPrimaryKey), Params);

  Assert.AreEqual('insert into MyEntityWithoutPrimaryKey default values ', SQL);

  Params.Free;
end;

procedure TDatabaseManipulatorTest.WhenBuildTheUpdateCommandFromATableWithoutPrimaryKeyCantBuildTheWhereClause;
begin
  var Params := TParams.Create(nil);

  Params.CreateParam(ftInteger, 'Param1', ptInput);
  Params.CreateParam(ftInteger, 'Param2', ptInput);
  Params.CreateParam(ftInteger, 'Param3', ptInput);

  var SQL := FMetadataManipulator.MakeUpdateStatement(FMapper.GetTable(TMyEntityWithoutPrimaryKey), Params);

  Assert.AreEqual('update MyEntityWithoutPrimaryKey set Param1=:Param1,Param2=:Param2,Param3=:Param3', SQL);

  Params.Free;
end;

procedure TDatabaseManipulatorTest.WhenBuildTheUpdateCommandMustBuildTheCommandAsExpected;
begin
  var Params := TParams.Create(nil);

  Params.CreateParam(ftInteger, 'Param1', ptInput);
  Params.CreateParam(ftInteger, 'Param2', ptInput);
  Params.CreateParam(ftInteger, 'Param3', ptInput);

  var SQL := FMetadataManipulator.MakeUpdateStatement(FMapper.GetTable(TMySQLiteTable), Params);

  Assert.AreEqual('update MySQLiteTable set Param1=:Param1,Param2=:Param2,Param3=:Param3 where Id=:Id', SQL);

  Params.Free;
end;

procedure TDatabaseManipulatorTest.WhenCreateAFieldMustBuildTheSQLHasExpected;
begin
  var Field := FMapper.GetTable(TMyTable).Field['RequiredField'];
  var SQL := 'alter table MyTableDB add RequiredField FieldType not null';

  FMetadataManipulator.CreateField(Field);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateAForeignKeyMustExecuteTheSQLAsExpected;
begin
  var SQL := 'alter table MyTableDB add constraint FK_MyTableDB_MyTableForeingKey_FKField foreign key (FKField) references MyTableForeingKey (Id)';

  FMetadataManipulator.CreateForeignKey(FMapper.GetTable(TMyTable).ForeignKeys[0]);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateAnIndexMustExecuteTheSQLAsExpected;
begin
  var SQL := 'create index MyIndex on MyTableDB (FKField,RequiredField)';

  FMetadataManipulator.CreateIndex(FMapper.GetTable(TMyTable).Indexes[0]);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateAPrimaryKeyIndexMustExecuteTheSQLAsExpected;
begin
  var Index := FMapper.GetTable(TMyEntity2).Indexes[0];
  var SQL := 'alter table AnotherTableName add constraint PK_AnotherTableName primary key (Id)';

  FMetadataManipulator.CreateIndex(Index);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateASequenceMustExecuteTheSQLAsExpected;
begin
  var Sequence := TSequence.Create('MySequence');
  var SQL := 'create sequence MySequence increment by 1 start with 1';

  FMetadataManipulator.CreateSequence(Sequence);

  Assert.AreEqual(SQL, FSQLExecuted);

  Sequence.Free;
end;

procedure TDatabaseManipulatorTest.WhenCreateATableWithManyValueAssociationThisFieldCantBeCreated;
begin
  var SQL :=
    'create table MyEntityWithManyValueAssociation (' +
      'Id FieldType not null)';

  FMetadataManipulator.CreateTable(FMapper.GetTable(TMyEntityWithManyValueAssociation));

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateATableWithoutPrimaryKeyCantRaiseAnyError;
begin
  var Table := FMapper.GetTable(TClassWithoutPrimaryKey);

  Assert.WillNotRaise(
    procedure
    begin
      FMetadataManipulator.CreateTable(Table);
    end);
end;

procedure TDatabaseManipulatorTest.WhenCreateATableWithoutPrimaryKeyMustExecuteTheSQLAsExpected;
begin
  var SQL :=
    'create table ClassWithoutPrimaryKey (' +
      'Value FieldType not null)';
  var Table := FMapper.GetTable(TClassWithoutPrimaryKey);

  FMetadataManipulator.CreateTable(Table);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateAUniqueIndexMustExecuteTheSQLAsExpected;
begin
  var SQL := 'create unique index MyUniqueKey on MyTableDB (RequiredField)';

  FMetadataManipulator.CreateIndex(FMapper.GetTable(TMyTable).Indexes[1]);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenCreateTheTableMustBuildTheSQLHasExpected;
begin
  var SQL :=
    'create table MyTableForeingKey (' +
      'Id FieldType(50) not null,' +
      'Value SpecialFieldType not null)';
  var Table := FMapper.GetTable(TMyTableForeingKey);

  FMetadataManipulator.CreateTable(Table);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenDropADefaultConstratintMustExecuteTheSQLHasExpected;
begin
//  var SQL := 'alter table MyTableDB drop constraint MyConstraint';
//
//  TDatabaseDefaultConstraint.Create(FDatabaseField, 'MyConstraint', 'MyValue');
//
//  FMetadataManipulator.DropDefaultConstraint(FDatabaseField);
//
//  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenDropAFieldMustExecuteTheSQLHasExpected;
begin
//  var SQL := 'alter table MyTableDB drop column MyFieldDB';
//
////  FMetadataManipulatorClass.DropField(FDatabaseField);
//
//  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenDropAForeignKeyMustExecuteTheSQLAsExpected;
begin
//  var DatabaseForeignKey := TDatabaseForeignKey.Create(FDatabaseTable, 'MyForeignKey', FDatabaseTable);
//  var SQL := 'alter table MyTableDB drop constraint MyForeignKey';
//
//  FMetadataManipulator.DropForeignKey(DatabaseForeignKey);
//
//  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenDropASequenceMustExecuteTheSQLAsExpected;
begin
//  var Sequence := TDatabaseSequence.Create('MySequence');
//  var SQL := 'drop sequence MySequence';
//
//  FMetadataManipulator.DropSequence(Sequence);
//
//  Assert.AreEqual(SQL, FSQLExecuted);
//
//  Sequence.Free;
end;

procedure TDatabaseManipulatorTest.WhenDropATableMustExecuteTheSQLHasExpected;
begin
//  var SQL := 'drop table MyTableDB';
//
////  FMetadataManipulatorClass.DropTable(FDatabaseTable);
//
//  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenDropIndexMustExecuteTheSQLAsExpected;
begin
//  var SQL := 'drop index MyIndex on MyTableDB';
//
//  FMetadataManipulator.DropIndex(FDatabaseIndex);
//
//  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenGetTheFieldDefinitionOfAForeignKeyFieldMustLoadTheInfoFromThePrimaryKeyOfTheForeignKeyTable;
begin
  var Field := FMapper.GetTable(TMyTable).Field['ForeignKeyField'];

//  Assert.AreEqual('FKField FieldType(50) not null constraint DF_MyTableDB_FKField default(AutoGeneratedValue)', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.WhenGetTheNameOfDefaultContraintFunctionMustReturnTheNameAsExpected;
begin
  var Field := FMapper.GetTable(TMyTable).Field['RequiredField'];
  Field.DatabaseName := 'MyFieldDB';

  Assert.AreEqual('DF_MyTableDB_MyFieldDB', FMetadataManipulator.GetDefaultConstraintName(Field));
end;

procedure TDatabaseManipulatorTest.WhenInsertARecordMustExecuteTheSQLAsExpected;
begin
  var MyClass := TClassWithPrimaryKey.Create;
  MyClass.Value := 123;
  var SQL := 'insert into ClassWithPrimaryKey(Value)values(123)';

//  FMetadataManipulatorClass.InsertRecord(MyClass);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

procedure TDatabaseManipulatorTest.WhenTheFieldHasDefaultValueMustLoadTheDefaultValueHasExpected;
begin
  var Field := FMapper.GetTable(TMyTable).Field['AutoGeneratedField'];

//  Assert.AreEqual('AutoGeneratedField SpecialFieldType not null constraint DF_MyTableDB_AutoGeneratedField default(AutoGeneratedValue)', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.WhenTheFieldIsAndFloatFieldMustLoadThePrecisionAndScaleInTheFieldDefinition;
begin
  var Field := FMapper.GetTable(TMyTable).Field['FloatField'];

//  Assert.AreEqual('FloatField FieldType(10,5) not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.WhenTheFieldTypeIsCharMustLoadTheSizeInTheFieldDefinition;
begin
  var Field := FMapper.GetTable(TMyTable).Field['CharField'];

//  Assert.AreEqual('CharField FieldType(1) not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.WhenTheFieldTypeIsStringMustLoadTheSizeInTheFieldDefinition;
begin
  var Field := FMapper.GetTable(TMyTable).Field['StringField'];

//  Assert.AreEqual('StringField FieldType(250) not null', FMetadataManipulatorClass.GetFieldDefinition(Field));
end;

procedure TDatabaseManipulatorTest.WhenThePrimaryKeyFieldIsInParamListCantBeInTheUpdateCommand;
begin
  var Params := TParams.Create(nil);

  Params.CreateParam(ftInteger, 'Param1', ptInput);
  Params.CreateParam(ftInteger, 'Param2', ptInput);
  Params.CreateParam(ftInteger, 'Param3', ptInput);
  Params.CreateParam(ftInteger, 'Id', ptInput);

  var SQL := FMetadataManipulator.MakeUpdateStatement(FMapper.GetTable(TMySQLiteTable), Params);

  Assert.AreEqual('update MySQLiteTable set Param1=:Param1,Param2=:Param2,Param3=:Param3 where Id=:Id', SQL);

  Params.Free;
end;

procedure TDatabaseManipulatorTest.WhenTheTableHasTheReturningFieldFilledMustBuildTheReturningClauseInTheInsertStatement;
begin
  var Params := TParams.Create(nil);

  Params.CreateParam(ftInteger, 'Param', ptInput);

  var SQL := FMetadataManipulator.MakeInsertStatement(FMapper.GetTable(TAutoGeneratedClass), Params);

  Assert.AreEqual('insert into AutoGeneratedClass(Param)values(:Param)returning Id,AnotherField,FixedValue,Sequence', SQL);

  Params.Free;
end;

procedure TDatabaseManipulatorTest.WhenUpdateAFieldMustExecuteTheSQLHasExpected;
begin
  var SQL := 'update MyTableDB set RequiredField = StringField';
  var Table := FMapper.GetTable(TMyTable);

//  FMetadataManipulatorClass.UpdateField(Table.Field['StringField'], Table.Field['RequiredField']);

  Assert.AreEqual(SQL, FSQLExecuted);
end;

end.

